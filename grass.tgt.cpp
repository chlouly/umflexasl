/*
 *  grass.tgt.cpp
 *
 *  Do not edit this file. It is automatically generated by EPIC.
 *
 *  Date : Mar 18 2021
 *  Time : 22:18:04
 */

#include <epic_struct.h>
#if defined(MGD_TGT) && defined(PSD_HW)
#include "valuesMGD.h"
#endif /* MGD_TGT && PSD_HW */
#include "grass.global.h"
#include <pgen_tmpl.h>
#include <epicfuns.h>
#ifdef PSD_HW
__asm__(".align 8");
#endif

#include "grass.allcv.h"
#include "grass.tgtex.h"
#include "grass.tgtdecl.h"
long _header_source_rev= 1679533467;
/*********************************************************************
 *                   GRASS.E PULSEGEN SECTION                        *
 *                                                                   *
 * Write here the functional code that loads hardware sequencer      *
 * memory with data that will allow it to play out the sequence.     *
 * These functions call pulse generation macros previously defined   *
 * with @pulsedef, and must return SUCCESS or FAILURE.               *
 *********************************************************************/
#include "support_func.h"


	STATUS
pulsegen( void )
{
	sspinit(psd_board_type);

	/* RF wave */
	       
    {
        /* Check for RF waveform generator */
        RFEnvelopeWaveformGeneratorCheck("rf1",
                                         (WF_PROCESSOR)wg_rf1);

        /* First create the pulses */
        pulsename(&gzrf1a,"gzrf1a");
        setWaveformPurpose(gzrf1a, RF_SELECT_GRAD);
        pulsename(&gzrf1,"gzrf1");
        setWaveformPurpose(gzrf1, RF_SELECT_GRAD);
        pulsename(&gzrf1d,"gzrf1d");
        setWaveformPurpose(gzrf1d, RF_SELECT_GRAD);
        pulsename(&rf1,"rf1");

        /*  Now create the slice select trapezoid */
        pg_beta = loggrd.zbeta;
        createramp(&gzrf1a,ZGRAD,pw_gzrf1a,(short)0,
                   MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrf1a/
                       GRAD_UPDATE_TIME)),pg_beta);
        createinstr( &gzrf1a,(long)(1000-pw_gzrf1a),
                     pw_gzrf1a,ia_gzrf1);
        createconst(&gzrf1,ZGRAD,pw_gzrf1,MAX_PG_WAMP);
        createinstr( &gzrf1,(long)(1000),
                     pw_gzrf1,ia_gzrf1);
        createramp(&gzrf1d,ZGRAD,pw_gzrf1d,MAX_PG_WAMP,
                   (short)0,(short)(maxGradRes*(pw_gzrf1d/GRAD_UPDATE_TIME)),
                   pg_beta);
        createinstr( &gzrf1d,(long)(1000+pw_gzrf1),
                     pw_gzrf1d,ia_gzrf1);

        /* Now create the rf pulse */
        createsinc(&rf1,(WF_PROCESSOR)wg_rf1,res_rf1,
                   MAX_PG_WAMP,cyc_rf1, alpha_rf1);
        createinstr( &rf1,(long)(1000) + psd_rf_wait,
                     pw_rf1,ia_rf1);
        linkpulses(4,&rf1,&gzrf1,&gzrf1a,
                   &gzrf1d);
        addrfbits(&rf1,off_rf1,(long)(1000) + psd_rf_wait,
                  pw_rf1);
    }
 

	/* Z Dephaser */
	                 

    setWaveformPurpose(gz1a, gz1.purpose);
    setWaveformPurpose(gz1d, gz1.purpose);
    trapezoid((WF_PROCESSOR)wg_gz1, "gz1", &gz1, &gz1a,
              &gz1d, pw_gz1, pw_gz1a, pw_gz1d,
              ia_gz1, 0, 0, 0, 0, pend(&gzrf1d,"gzrf1d",0)+pw_gz1a-pw_gz1a, TRAP_ALL,
              &loggrd);


	/* X Readout */
	              

    setWaveformPurpose(gxwa, gxw.purpose);
    setWaveformPurpose(gxwd, gxw.purpose);
    trapezoid((WF_PROCESSOR)wg_gxw, "gxw", &gxw, &gxwa,
              &gxwd, pw_gxw, pw_gxwa, pw_gxwd,
              ia_gxw, 0, 0, 0, 0, RUP_GRD(pmid(&gzrf1,"gzrf1",0)+opte-pw_gxw/2)-pw_gxwa, TRAP_ALL,
              &loggrd);


	/* Frequency Dephaser */
	                   

    setWaveformPurpose(gx1a, gx1.purpose);
    setWaveformPurpose(gx1d, gx1.purpose);
    trapezoid((WF_PROCESSOR)wg_gx1, "gx1", &gx1, &gx1a,
              &gx1d, pw_gx1, pw_gx1a, pw_gx1d,
              ia_gx1, 0, 0, 0, 0, pbeg(&gxwa,"gxwa",0)-pw_gx1-pw_gx1d-pw_gx1a, TRAP_ALL,
              &loggrd);


	/* Phase Encoding */
	         
    setWaveformPurpose(gy1a, gy1.purpose);
    setWaveformPurpose(gy1d, gy1.purpose);
    trapezoid((WF_PROCESSOR)wg_gy1,"gy1",
              &gy1,&gy1a,&gy1d,
              pw_gy1,pw_gy1a,pw_gy1d,
              ia_gy1,ia_gy1wa,ia_gy1wb,
              0,0,RDN_GRD(pend(&rf1,"rf1",0)+rfupd),TRAP_ALL_SLOPED,
                          &loggrd);


	/* Data Acquisition */
	        
    {
        pulsename(&echo1,"echo1");
        acqq(&echo1, (long)(pbeg(&gxw,"gxw",0)),(long)(DEFAULTPOS),
             (long)(DEFAULTPOS),(long)filter_echo1,
             (TYPDAB_PACKETS)DABNORM);
    }


	          
    setWaveformPurpose(gyr1a, gyr1.purpose);
    setWaveformPurpose(gyr1d, gyr1.purpose);
    trapezoid((WF_PROCESSOR)wg_gyr1,"gyr1",
              &gyr1,&gyr1a,&gyr1d,
              pw_gyr1,pw_gyr1a,pw_gyr1d,
              ia_gyr1,ia_gyr1wa,ia_gyr1wb,
              0,0,pend(&gxw,"gxw",0),TRAP_ALL_SLOPED,
                          &loggrd);


	/* Z & X Killers */
	           

    setWaveformPurpose(gzka, gzk.purpose);
    setWaveformPurpose(gzkd, gzk.purpose);
    trapezoid((WF_PROCESSOR)wg_gzk, "gzk", &gzk, &gzka,
              &gzkd, pw_gzk, pw_gzka, pw_gzkd,
              ia_gzk, 0, 0, 0, 0, pend(&gxwd,"gxwd",0)+pw_gzka-pw_gzka, TRAP_ALL,
              &loggrd);

	           

    setWaveformPurpose(gxka, gxk.purpose);
    setWaveformPurpose(gxkd, gxk.purpose);
    trapezoid((WF_PROCESSOR)wg_gxk, "gxk", &gxk, &gxka,
              &gxkd, pw_gxk, pw_gxka, pw_gxkd,
              ia_gxk, 0, 0, 0, 0, pend(&gxwd,"gxwd",0)+pw_gxka-pw_gxka, TRAP_ALL,
              &loggrd);


	  
  {
    pulsename(&seqcore,"seqcore");
    createseq(&seqcore,optr, off_seqcore);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqcore );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqcore = %d\n", idx_seqcore );
#endif
  }
 /* set the sequence length to optr */

/*********************************************************************
 *                      PRESCAN.E PG SECTION                         *
 *                          PSpulsegen                               *
 *                                                                   *
 * Write here the functional code that loads hardware sequencer      *
 * memory with data that will allow it to play out the sequence.     *
 * These functions call pulse generation macros previously defined   *
 * with @pulsedef, and must return SUCCESS or FAILURE.               *
 *********************************************************************/
PSpulsegen();
FTGpulsegen();
XTGpulsegen();
ASpulsegen();
RSpulsegen();
DTGpulsegen();
AutoCoilpulsegen();
ExtCalpulsegen();


	 
  {
    pulsename(&endpass,"endpass");
    createpass(&endpass,(long)(49000));
  }
   /* tell Signa system we're done */
	  
  {
    pulsename(&pass,"pass");
    createseq(&pass,50000, off_pass);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_pass );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_pass = %d\n", idx_pass );
#endif
  }


	buildinstr();              /* load the sequencer memory       */

	return SUCCESS;
}   /* end pulsegen() */


/* For Prescan: Pulse Generation functions */
/*********************************************************************
 *                      PRESCAN.E PG SECTION                         *
 *                             PSipg                                 *
 *                                                                   *
 * Write here the functional code that loads hardware sequencer      *
 * memory with data that will allow it to play out the sequence.     *
 * These functions call pulse generation macros previously defined   *
 * with @pulsedef, and must return SUCCESS or FAILURE.               *
 *********************************************************************/

#include "addrfbits.h"
#include "rfsspsummary.h"

int rs_echo2toNdab[16], dtg_echo2toNdab[16];
int rs_echo2toNrba[16], dtg_echo2toNrba[16];
WF_PULSE *rs_echo2toN;
WF_PULSE *dtg_echo2toN;

short dyntg_txatten_bits[EATTEN_SSP_LENGTH_MAX];

/*
 *  PS1pulsegen
 *  
 *  Type: Private Function
 *  
 *  Description:
 *  
 */
STATUS
PS1pulsegen( INT posstart )
{
    INT postemp;
    INT ta_180, tb_180, te_180;
    INT temp_max_pw, temp_max_ypw, temp_max_zpw;

    /***********************************************************************
     * MPS1/APS1 SECTION
     ***********************************************************************/
         
  {
    pulsename(&rf1mps1,"rf1mps1");
    createsinc(&rf1mps1,(WF_PROCESSOR)wg_rf1mps1,res_rf1mps1,
               MAX_PG_WAMP,cyc_rf1mps1,alpha_rf1mps1);
    if ((wg_rf1mps1==TYPRHO1)||(wg_rf1mps1==TYPRHO2) ||
        (wg_rf1mps1==TYPTHETA)||(wg_rf1mps1==TYPOMEGA))
      {
        createinstr( &rf1mps1,(long)(posstart) + psd_rf_wait,
                    pw_rf1mps1,ia_rf1mps1);
        addrfbits(&rf1mps1,off_rf1mps1,(long)(posstart) + psd_rf_wait,
                  pw_rf1mps1);
      }
    else
      {
        createinstr( &rf1mps1,(long)(posstart),
                    pw_rf1mps1,ia_rf1mps1);
      }
  }

    if(PSD_ON == local_tg)
    {
            
                    

    setWaveformPurpose(gyrf1mps1a, gyrf1mps1.purpose);
    setWaveformPurpose(gyrf1mps1d, gyrf1mps1.purpose);
    trapezoid((WF_PROCESSOR)wg_gyrf1mps1, "gyrf1mps1", &gyrf1mps1, &gyrf1mps1a,
              &gyrf1mps1d, pw_gyrf1mps1, pw_gyrf1mps1a, pw_gyrf1mps1d,
              ia_gyrf1mps1, 0, 0, 0, 0, pbegall(&rf1mps1,0)-psd_rf_wait-pw_gyrf1mps1a, TRAP_ALL,
              &ps1loggrd);
  /* same axis as ykiller */

        /* Refocus on slice gradient */
        postemp = RUP_GRD(pend(&gyrf1mps1d,"gyrf1mps1d",0));
             

    setWaveformPurpose(gy1mps1a, gy1mps1.purpose);
    setWaveformPurpose(gy1mps1d, gy1mps1.purpose);
    trapezoid((WF_PROCESSOR)wg_gy1mps1, "gy1mps1", &gy1mps1, &gy1mps1a,
              &gy1mps1d, pw_gy1mps1, pw_gy1mps1a, pw_gy1mps1d,
              ia_gy1mps1, 0, 0, 0, 0, postemp+pw_gy1mps1a-pw_gy1mps1a, TRAP_ALL,
              &ps1loggrd);


        /* read dephaser */
        postemp = RUP_GRD(pend(&gyrf1mps1, "gyrf1mps1", 0)+rfupd+pw_gx1mps1a);

    }
    else
    {
            
                    

    setWaveformPurpose(gzrf1mps1a, gzrf1mps1.purpose);
    setWaveformPurpose(gzrf1mps1d, gzrf1mps1.purpose);
    trapezoid((WF_PROCESSOR)wg_gzrf1mps1, "gzrf1mps1", &gzrf1mps1, &gzrf1mps1a,
              &gzrf1mps1d, pw_gzrf1mps1, pw_gzrf1mps1a, pw_gzrf1mps1d,
              ia_gzrf1mps1, 0, 0, 0, 0, pbegall(&rf1mps1,0)-psd_rf_wait-pw_gzrf1mps1a, TRAP_ALL,
              &ps1loggrd);


        /* Refocus on Z gradient */
        postemp = RUP_GRD(pend(&gzrf1mps1d,"gzrf1mps1d",0));
             

    setWaveformPurpose(gz1mps1a, gz1mps1.purpose);
    setWaveformPurpose(gz1mps1d, gz1mps1.purpose);
    trapezoid((WF_PROCESSOR)wg_gz1mps1, "gz1mps1", &gz1mps1, &gz1mps1a,
              &gz1mps1d, pw_gz1mps1, pw_gz1mps1a, pw_gz1mps1d,
              ia_gz1mps1, 0, 0, 0, 0, postemp+pw_gz1mps1a-pw_gz1mps1a, TRAP_ALL,
              &ps1loggrd);


        /* read dephaser */
        postemp = RUP_GRD(pend(&gzrf1mps1, "gzrf1mps1", 0)+rfupd+pw_gx1mps1a);
    }
         

    setWaveformPurpose(gx1mps1a, gx1mps1.purpose);
    setWaveformPurpose(gx1mps1d, gx1mps1.purpose);
    trapezoid((WF_PROCESSOR)wg_gx1mps1, "gx1mps1", &gx1mps1, &gx1mps1a,
              &gx1mps1d, pw_gx1mps1, pw_gx1mps1a, pw_gx1mps1d,
              ia_gx1mps1, 0, 0, 0, 0, postemp-pw_gx1mps1a, TRAP_ALL,
              &ps1loggrd);


    /****** figure out minimum te from z grad, compare needed 
      time before and after 180 *********/
    if(PSD_ON == local_tg)
    {
        temp_max_ypw = pw_gyrf1mps1d + pw_gy1mps1a + pw_gy1mps1 + pw_gy1mps1d;
        temp_max_zpw = pw_gzrf2lmps1a+pw_gzrf2lmps1+pw_gzrf2lmps1d;
    }
    else
    {
        temp_max_ypw = 0;
        temp_max_zpw = pw_gzrf1mps1d + pw_gz1mps1a + pw_gz1mps1 + pw_gz1mps1d+
            pw_gzrf2lmps1a + pw_gzrf2lmps1 + pw_gzrf2lmps1d;
    }

    temp_max_pw = IMax(3, rfupd+pw_gx1mps1a+pw_gx1mps1+pw_gx1mps1d, temp_max_ypw, temp_max_zpw); 

    tb_180  =  PSoff90 + pw_rf1mps1/2 + temp_max_pw + pw_rf2mps1/2;

    ta_180  = pw_rf2mps1/2 + pw_gzrf2rmps1a + pw_gzrf2rmps1 + pw_gzrf2rmps1d
        + pw_gxwmps1/2 - psd_rf_wait + psd_grd_wait + DABSETUP;

    te_180 = RUP_GRD(2*(IMax(3, ta_180, tb_180, min180te/2)));

    postemp = RUP_GRD( (posstart + pw_rf1mps1/2 - PSoff90)
                       + (te_180/2) - pw_rf2mps1/2 );

         
                    
    {
        /* Check for RF waveform generator */
        RFEnvelopeWaveformGeneratorCheck("rf2mps1",
                                         (WF_PROCESSOR)wg_rf2mps1);

        /* Modify resolution if scaling required */
        temp_res_rf2mps1 = res_rf2mps1;
        if (rfpulseInfo[RF2_APS1_SLOT].change==PSD_ON)
        {
            res_rf2mps1 = rfpulseInfo[RF2_APS1_SLOT].newres;
        }
        /* First create the pulses */
        pulsename(&gzrf2mps1a,"gzrf2mps1a");
        setWaveformPurpose(gzrf2mps1a, RF_SELECT_GRAD);
        pulsename(&gzrf2mps1,"gzrf2mps1");
        setWaveformPurpose(gzrf2mps1, RF_SELECT_GRAD);
        pulsename(&gzrf2mps1d,"gzrf2mps1d");
        setWaveformPurpose(gzrf2mps1d, RF_SELECT_GRAD);
        pulsename(&rf2mps1,"rf2mps1");

        /*  Now create the slice select trapezoid */
        pg_beta = ps1loggrd.zbeta;
        createramp(&gzrf2mps1a,ZGRAD,pw_gzrf2mps1a,(short)0,
                   MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrf2mps1a/
                       GRAD_UPDATE_TIME)),pg_beta);
        createinstr( &gzrf2mps1a,(LONG)(postemp-pw_gzrf2mps1a),
                     pw_gzrf2mps1a,ia_gzrf2mps1);
        createconst(&gzrf2mps1,ZGRAD,pw_gzrf2mps1,MAX_PG_WAMP);
        createinstr( &gzrf2mps1,(LONG)(postemp),
                     pw_gzrf2mps1,ia_gzrf2mps1);
        createramp(&gzrf2mps1d,ZGRAD,pw_gzrf2mps1d,MAX_PG_WAMP,
                   (short)0,(short)(maxGradRes*(pw_gzrf2mps1d/GRAD_UPDATE_TIME)),
                   pg_beta);
        createinstr( &gzrf2mps1d,(LONG)(postemp+pw_gzrf2mps1),
                     pw_gzrf2mps1d,ia_gzrf2mps1);

        /* Now create the rf pulse */
        createsinc(&rf2mps1,(WF_PROCESSOR)wg_rf2mps1,res_rf2mps1,
                   MAX_PG_WAMP,cyc_rf2mps1, alpha_rf2mps1);
        createinstr( &rf2mps1,(LONG)(postemp) + psd_rf_wait,
                     pw_rf2mps1,ia_rf2mps1);
        linkpulses(4,&rf2mps1,&gzrf2mps1,&gzrf2mps1a,
                   &gzrf2mps1d);
        addrfbits(&rf2mps1,off_rf2mps1,(LONG)(postemp) + psd_rf_wait,
                  pw_rf2mps1);
        /* Changed back resolution incase external rf used later in pulsegen. We need
         * original resolution to scale pulses that are external
         */
        if (rfpulseInfo[RF2_APS1_SLOT].change==PSD_ON)
        {
            res_rf2mps1 = temp_res_rf2mps1;
        }
    }


    /* crushers */
    postemp = pbeg(&gzrf2mps1,"gzrf2mps1",0) - pw_gzrf2lmps1 - pw_gzrf2lmps1d;
          

    setWaveformPurpose(gzrf2lmps1a, gzrf2lmps1.purpose);
    setWaveformPurpose(gzrf2lmps1d, gzrf2lmps1.purpose);
    trapezoid((WF_PROCESSOR)wg_gzrf2lmps1, "gzrf2lmps1", &gzrf2lmps1, &gzrf2lmps1a,
              &gzrf2lmps1d, pw_gzrf2lmps1, pw_gzrf2lmps1a, pw_gzrf2lmps1d,
              ia_gzrf2lmps1, 0, 0, 0, 0, postemp-pw_gzrf2lmps1a, TRAP_ALL,
              &ps1loggrd);

  
           

    setWaveformPurpose(gzrf2rmps1a, gzrf2rmps1.purpose);
    setWaveformPurpose(gzrf2rmps1d, gzrf2rmps1.purpose);
    trapezoid((WF_PROCESSOR)wg_gzrf2rmps1, "gzrf2rmps1", &gzrf2rmps1, &gzrf2rmps1a,
              &gzrf2rmps1d, pw_gzrf2rmps1, pw_gzrf2rmps1a, pw_gzrf2rmps1d,
              ia_gzrf2rmps1, 0, 0, 0, 0, pendall(&gzrf2mps1,0)-pw_gzrf2rmps1a, TRAP_ALL,
              &ps1loggrd);

  
    postemp = RUP_GRD(pmid(&gzrf2mps1,"gzrf2mps1",0)+ (te_180/2) - pw_gxwmps1/2);
         

    setWaveformPurpose(gxwmps1a, gxwmps1.purpose);
    setWaveformPurpose(gxwmps1d, gxwmps1.purpose);
    trapezoid((WF_PROCESSOR)wg_gxwmps1, "gxwmps1", &gxwmps1, &gxwmps1a,
              &gxwmps1d, pw_gxwmps1, pw_gxwmps1a, pw_gxwmps1d,
              ia_gxwmps1, 0, 0, 0, 0, postemp-pw_gxwmps1a, TRAP_ALL,
              &ps1loggrd);
    

        
    {
        pulsename(&echo1mps1,"echo1mps1");
        acqq(&echo1mps1, (long)(pbeg(&gxwmps1,"gxwmps1",0)+psd_grd_wait),(long)(DEFAULTPOS),
             (long)(DEFAULTPOS),(long)filter_echo1mps1,
             (TYPDAB_PACKETS)DABNORM);
    }


      
    {
        pulsename(&attenuator_keymps1,"attenuator_keymps1");
        createatten(&attenuator_keymps1, (long)(pend(&gxwmps1,"gxwmps1",0)));
    }


      
  {
    pulsename(&seqmps1,"seqmps1");
    createseq(&seqmps1,ps1_tr, off_seqmps1);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqmps1 );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqmps1 = %d\n", idx_seqmps1 );
#endif
  }


    return SUCCESS;
}

/*
 *  CFLpulsegen
 *  
 *  Type: Private Function
 *  
 *  Description:
 *  
 */
STATUS
CFLpulsegen( INT posstart )
{
    INT postemp;
    INT tsamp_delay_cfl;

    tsamp_delay_cfl = RUP_GRD(1000);

    /*  90 slice sel pulse  */
       
                   
    {
        /* Check for RF waveform generator */
        RFEnvelopeWaveformGeneratorCheck("rf1cfl",
                                         (WF_PROCESSOR)wg_rf1cfl);

        /* Modify resolution if scaling required */
        temp_res_rf1cfl = res_rf1cfl;
        if (rfpulseInfo[RF1_CFL_SLOT].change==PSD_ON)
        {
            res_rf1cfl = rfpulseInfo[RF1_CFL_SLOT].newres;
        }
        /* First create the pulses */
        pulsename(&gzrf1cfla,"gzrf1cfla");
        setWaveformPurpose(gzrf1cfla, RF_SELECT_GRAD);
        pulsename(&gzrf1cfl,"gzrf1cfl");
        setWaveformPurpose(gzrf1cfl, RF_SELECT_GRAD);
        pulsename(&gzrf1cfld,"gzrf1cfld");
        setWaveformPurpose(gzrf1cfld, RF_SELECT_GRAD);
        pulsename(&rf1cfl,"rf1cfl");

        /*  Now create the slice select trapezoid */
        pg_beta = cflloggrd.zbeta;
        createramp(&gzrf1cfla,ZGRAD,pw_gzrf1cfla,(short)0,
                   MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrf1cfla/
                       GRAD_UPDATE_TIME)),pg_beta);
        createinstr( &gzrf1cfla,(LONG)(posstart-pw_gzrf1cfla),
                     pw_gzrf1cfla,ia_gzrf1cfl);
        createconst(&gzrf1cfl,ZGRAD,pw_gzrf1cfl,MAX_PG_WAMP);
        createinstr( &gzrf1cfl,(LONG)(posstart),
                     pw_gzrf1cfl,ia_gzrf1cfl);
        createramp(&gzrf1cfld,ZGRAD,pw_gzrf1cfld,MAX_PG_WAMP,
                   (short)0,(short)(maxGradRes*(pw_gzrf1cfld/GRAD_UPDATE_TIME)),
                   pg_beta);
        createinstr( &gzrf1cfld,(LONG)(posstart+pw_gzrf1cfl),
                     pw_gzrf1cfld,ia_gzrf1cfl);

        /* Now create the rf pulse */
        createsinc(&rf1cfl,(WF_PROCESSOR)wg_rf1cfl,res_rf1cfl,
                   MAX_PG_WAMP,cyc_rf1cfl, alpha_rf1cfl);
        createinstr( &rf1cfl,(LONG)(posstart) + psd_rf_wait,
                     pw_rf1cfl,ia_rf1cfl);
        linkpulses(4,&rf1cfl,&gzrf1cfl,&gzrf1cfla,
                   &gzrf1cfld);
        addrfbits(&rf1cfl,off_rf1cfl,(LONG)(posstart) + psd_rf_wait,
                  pw_rf1cfl);
        /* Changed back resolution incase external rf used later in pulsegen. We need
         * original resolution to scale pulses that are external
         */
        if (rfpulseInfo[RF1_CFL_SLOT].change==PSD_ON)
        {
            res_rf1cfl = temp_res_rf1cfl;
        }
    }

  
    /* Refocusing Pulse */
        
                    

    setWaveformPurpose(gz1cfla, gz1cfl.purpose);
    setWaveformPurpose(gz1cfld, gz1cfl.purpose);
    trapezoid((WF_PROCESSOR)wg_gz1cfl, "gz1cfl", &gz1cfl, &gz1cfla,
              &gz1cfld, pw_gz1cfl, pw_gz1cfla, pw_gz1cfld,
              ia_gz1cfl, 0, 0, 0, 0, pbeg(&gzrf1cfl,"gzrf1cfl",0)+pw_gzrf1cfl+pw_gzrf1cfld+pw_gz1cfla-pw_gz1cfla, TRAP_ALL,
              &cflloggrd);

  
    /* Data Acquisiton with 2K filter */
         
    {
        pulsename(&cfl_fid,"cfl_fid");
        acqq(&cfl_fid, (long)(pendall(&gz1cfl,0)+tsamp_delay_cfl),(long)(DEFAULTPOS),
             (long)(DEFAULTPOS),(long)filter_cfl_fid,
             (TYPDAB_PACKETS)DABNORM);
    }

    /* Assert the ESSP flag on the rf1cfl pulse */
    attenflagon(&rf1cfl, 0);

    postemp = RUP_GRD(pendall(&gz1cfl,0) + tsamp_delay_cfl + cfl_tdaq + pw_gykcfla);

     
    {
        pulsename(&cfl_attenkey,"cfl_attenkey");
        createatten(&cfl_attenkey, (long)(postemp));
    }

         

    setWaveformPurpose(gykcfla, gykcfl.purpose);
    setWaveformPurpose(gykcfld, gykcfl.purpose);
    trapezoid((WF_PROCESSOR)wg_gykcfl, "gykcfl", &gykcfl, &gykcfla,
              &gykcfld, pw_gykcfl, pw_gykcfla, pw_gykcfld,
              ia_gykcfl, 0, 0, 0, 0, postemp-pw_gykcfla, TRAP_ALL,
              &cflloggrd);

  
      
  {
    pulsename(&seqcfl,"seqcfl");
    createseq(&seqcfl,cfl_tr, off_seqcfl);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqcfl );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqcfl = %d\n", idx_seqcfl );
#endif
  }


    return SUCCESS;
}

/*
 *  RCVNpulsegen
 *  
 *  Type: Private Function
 *  
 *  Description:
 *  
 */
STATUS
RCVNpulsegen( INT posstart )
{
    INT postemp, postemp2;
    INT tsamp_delay_rcvn;
    INT unblank_delay_rcvn;

    /* MRIhc47602/MRIhc47515/GEHmr03545 */
    if ( (rcvn_flag == 1) || (rcvn_flag == 3) )
    {
               

    setWaveformPurpose(gxkrcvna, gxkrcvn.purpose);
    setWaveformPurpose(gxkrcvnd, gxkrcvn.purpose);
    trapezoid((WF_PROCESSOR)wg_gxkrcvn, "gxkrcvn", &gxkrcvn, &gxkrcvna,
              &gxkrcvnd, pw_gxkrcvn, pw_gxkrcvna, pw_gxkrcvnd,
              ia_gxkrcvn, 0, 0, 0, 0, RUP_GRD(posstart+pw_gxkrcvna)-pw_gxkrcvna, TRAP_ALL,
              &rcvnloggrd);

               

    setWaveformPurpose(gykrcvna, gykrcvn.purpose);
    setWaveformPurpose(gykrcvnd, gykrcvn.purpose);
    trapezoid((WF_PROCESSOR)wg_gykrcvn, "gykrcvn", &gykrcvn, &gykrcvna,
              &gykrcvnd, pw_gykrcvn, pw_gykrcvna, pw_gykrcvnd,
              ia_gykrcvn, 0, 0, 0, 0, RUP_GRD(posstart+pw_gykrcvna)-pw_gykrcvna, TRAP_ALL,
              &rcvnloggrd);

               

    setWaveformPurpose(gzkrcvna, gzkrcvn.purpose);
    setWaveformPurpose(gzkrcvnd, gzkrcvn.purpose);
    trapezoid((WF_PROCESSOR)wg_gzkrcvn, "gzkrcvn", &gzkrcvn, &gzkrcvna,
              &gzkrcvnd, pw_gzkrcvn, pw_gzkrcvna, pw_gzkrcvnd,
              ia_gzkrcvn, 0, 0, 0, 0, RUP_GRD(posstart+pw_gzkrcvna)-pw_gzkrcvna, TRAP_ALL,
              &rcvnloggrd);


        if(3 == rcvn_flag)   /* Additional gradient waveform for Grad prognostic */
        {
            long ctrl_word;

               
  {
      if( TYPXGRAD == (WF_PROCESSOR)wg_grd_trig || TYPYGRAD == (WF_PROCESSOR)wg_grd_trig || TYPZGRAD == (WF_PROCESSOR)wg_grd_trig
          || TYPBXGRAD == (WF_PROCESSOR)wg_grd_trig || TYPBYGRAD == (WF_PROCESSOR)wg_grd_trig || TYPBZGRAD == (WF_PROCESSOR)wg_grd_trig )
      {
          setWaveformPurpose(grd_trig, WAIT_GRAD);
      }
      else if( TYPRHO1 == (WF_PROCESSOR)wg_grd_trig || TYPRHO2 == (WF_PROCESSOR)wg_grd_trig || TYPTHETA == (WF_PROCESSOR)wg_grd_trig
               || TYPBRHO1 == (WF_PROCESSOR)wg_grd_trig || TYPBRHO2 == (WF_PROCESSOR)wg_grd_trig || TYPBTHETA == (WF_PROCESSOR)wg_grd_trig
               || TYPOMEGA == (WF_PROCESSOR)wg_grd_trig || TYPBOMEGA == (WF_PROCESSOR)wg_grd_trig )
      {
          setWaveformPurpose(grd_trig, WAIT_RF);
      }
      else if( TYPSSP == (WF_PROCESSOR)wg_grd_trig || TYPBSSP == (WF_PROCESSOR)wg_grd_trig )
      {
          setWaveformPurpose(grd_trig, WAIT_SSP);
      }
    pulsename(&grd_trig,"grd_trig");
    createconst(&grd_trig,(WF_PROCESSOR)wg_grd_trig,pw_grd_trig,(short)0); 
    createinstr( &grd_trig,(long)(posstart),pw_grd_trig,0);
  }

            getctrl(&ctrl_word, &grd_trig, 0);
            ctrl_word = ctrl_word | PSD_GRADR_SYNC;
            setctrl(ctrl_word, &grd_trig, 0);
            posstart = RUP_GRD(pendallssp(&grd_trig, 0)); 

            postemp = RUP_GRD(pend(&gxkrcvnd,"gxkrcvnd",0) + pw_gxk2rcvna);
                 

    setWaveformPurpose(gxk2rcvna, gxk2rcvn.purpose);
    setWaveformPurpose(gxk2rcvnd, gxk2rcvn.purpose);
    trapezoid((WF_PROCESSOR)wg_gxk2rcvn, "gxk2rcvn", &gxk2rcvn, &gxk2rcvna,
              &gxk2rcvnd, pw_gxk2rcvn, pw_gxk2rcvna, pw_gxk2rcvnd,
              ia_gxk2rcvn, 0, 0, 0, 0, postemp-pw_gxk2rcvna, TRAP_ALL,
              &rcvnloggrd);


            postemp = RUP_GRD(pend(&gykrcvnd,"gykrcvnd",0) + pw_gyk2rcvna);
                 

    setWaveformPurpose(gyk2rcvna, gyk2rcvn.purpose);
    setWaveformPurpose(gyk2rcvnd, gyk2rcvn.purpose);
    trapezoid((WF_PROCESSOR)wg_gyk2rcvn, "gyk2rcvn", &gyk2rcvn, &gyk2rcvna,
              &gyk2rcvnd, pw_gyk2rcvn, pw_gyk2rcvna, pw_gyk2rcvnd,
              ia_gyk2rcvn, 0, 0, 0, 0, postemp-pw_gyk2rcvna, TRAP_ALL,
              &rcvnloggrd);


            postemp = RUP_GRD(pend(&gzkrcvnd,"gzkrcvnd",0) + pw_gzk2rcvna);
                 

    setWaveformPurpose(gzk2rcvna, gzk2rcvn.purpose);
    setWaveformPurpose(gzk2rcvnd, gzk2rcvn.purpose);
    trapezoid((WF_PROCESSOR)wg_gzk2rcvn, "gzk2rcvn", &gzk2rcvn, &gzk2rcvna,
              &gzk2rcvnd, pw_gzk2rcvn, pw_gzk2rcvna, pw_gzk2rcvnd,
              ia_gzk2rcvn, 0, 0, 0, 0, postemp-pw_gzk2rcvna, TRAP_ALL,
              &rcvnloggrd);

        }
    }
    else if ( rcvn_flag == 2 ) /* extra delay before rcvn */
    {
        
  {
      if( TYPXGRAD == (WF_PROCESSOR)wg_rcvn_wait || TYPYGRAD == (WF_PROCESSOR)wg_rcvn_wait || TYPZGRAD == (WF_PROCESSOR)wg_rcvn_wait
          || TYPBXGRAD == (WF_PROCESSOR)wg_rcvn_wait || TYPBYGRAD == (WF_PROCESSOR)wg_rcvn_wait || TYPBZGRAD == (WF_PROCESSOR)wg_rcvn_wait )
      {
          setWaveformPurpose(rcvn_wait, WAIT_GRAD);
      }
      else if( TYPRHO1 == (WF_PROCESSOR)wg_rcvn_wait || TYPRHO2 == (WF_PROCESSOR)wg_rcvn_wait || TYPTHETA == (WF_PROCESSOR)wg_rcvn_wait
               || TYPBRHO1 == (WF_PROCESSOR)wg_rcvn_wait || TYPBRHO2 == (WF_PROCESSOR)wg_rcvn_wait || TYPBTHETA == (WF_PROCESSOR)wg_rcvn_wait
               || TYPOMEGA == (WF_PROCESSOR)wg_rcvn_wait || TYPBOMEGA == (WF_PROCESSOR)wg_rcvn_wait )
      {
          setWaveformPurpose(rcvn_wait, WAIT_RF);
      }
      else if( TYPSSP == (WF_PROCESSOR)wg_rcvn_wait || TYPBSSP == (WF_PROCESSOR)wg_rcvn_wait )
      {
          setWaveformPurpose(rcvn_wait, WAIT_SSP);
      }
    pulsename(&rcvn_wait,"rcvn_wait");
    createconst(&rcvn_wait,(WF_PROCESSOR)wg_rcvn_wait,pw_rcvn_wait,(short)0); 
    createinstr( &rcvn_wait,(long)(RUP_GRD(posstart)),pw_rcvn_wait,0);
  }

    }
      
  {
    pulsename(&pre_rcvn,"pre_rcvn");
    createseq(&pre_rcvn,RUP_GRD(pre_rcvn_tr+posstart), off_pre_rcvn);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_pre_rcvn );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_pre_rcvn = %d\n", idx_pre_rcvn );
#endif
  }


    unblank_delay_rcvn = RUP_GRD(1000);
    tsamp_delay_rcvn = RUP_GRD(2000);

    /* RCVRUNBLANK & RCVRBLANK mechanism is normally taken care 
       of by the RF pulse itself. However RCVN entry point does
       not have any RF pulse so we wrap data acqusition window. */

    /* Unblank receiver before Data Acquisition window */
    
  {
    rcvrbl_pack[0] = SSPDS+RDC;
    rcvrbl_pack[1] = SSPOC+RFUBL+RSEL_ALL;
    rcvrbl_pack[2] = SSPD+RUBL;
    rcvrbl_pack[3] = SSPDS;

    pulsename(&rcvrbl,"rcvrbl");
    createbits(&rcvrbl,TYPSSP,4,rcvrbl_pack);
    createinstr( &rcvrbl,(long)(unblank_delay_rcvn),4,ia_rcvrbl);
  }

  
    /* Data Acquisiton with 2K filter */
       
    {
        pulsename(&rcvn_fid,"rcvn_fid");
        acqq(&rcvn_fid, (long)(tsamp_delay_rcvn),(long)(DEFAULTPOS),
             (long)(DEFAULTPOS),(long)filter_rcvn_fid,
             (TYPDAB_PACKETS)DABNORM);
    }


    postemp  = RUP_GRD(tsamp_delay_rcvn + rcvn_tdaq);
    postemp2 = RUP_GRD(unblank_delay_rcvn + postemp);

     
    {
        pulsename(&rcvn_attenkey,"rcvn_attenkey");
        createatten(&rcvn_attenkey, (long)(postemp));
    }


    /* Blank receiver after Data Acquisition is completed */
    
  {
    rcvrbl2_pack[0] = SSPDS+RDC;
    rcvrbl2_pack[1] = SSPOC+RFUBL+RSEL_ALL;
    rcvrbl2_pack[2] = SSPD+RBL;
    rcvrbl2_pack[3] = SSPDS;

    pulsename(&rcvrbl2,"rcvrbl2");
    createbits(&rcvrbl2,TYPSSP,4,rcvrbl2_pack);
    createinstr( &rcvrbl2,(long)(postemp2),4,ia_rcvrbl2);
  }

  
      
  {
    pulsename(&seqrcvn,"seqrcvn");
    createseq(&seqrcvn,rcvn_tr, off_seqrcvn);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqrcvn );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqrcvn = %d\n", idx_seqrcvn );
#endif
  }


    return SUCCESS;
}

/*
 *  CFHpulsegen
 *  
 *  Type: Private Function
 *  
 *  Description:
 *  
 */
STATUS
CFHpulsegen( INT posstart )
{
    INT postemp;
    INT cfh_te;   /* Run at operator TE unless below min cfh te.
                     Then run at min cfh te */
    INT cfh_te2;   /* vmx 05/02/95 YO */
    INT cfh_acq_window_pos;   /* vmx 05/02/94 YO */
    INT tsamp_delay_cfh;
    INT start_time = 0;
    INT start_time_CS = 0;
    INT pos_rf2;
    INT newcfh_tr;

    /* variables for presscfh */
    INT pos_rf3 = 0;
    INT pos_rf4 = 0;

    tsamp_delay_cfh = RUP_GRD(1000);

    start_time = posstart;
    start_time_CS = posstart;

    /* Check for CFH Inversion inclusion */
    if (PSD_ON == PSir)
    {
        /* adiabatic pulse */
           
                       
                        
                          
                       
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rf0cfh", 
                                     (WF_PROCESSOR)wg_rf0cfh);

    /* First create the pulses */
    pulsename(&gzrf0cfha,"gzrf0cfha");
    pulsename(&gzrf0cfh,"gzrf0cfh");
    pulsename(&gzrf0cfhd,"gzrf0cfhd");
    pulsename(&rf0cfh,"rf0cfh");

    /*  Now create the slice select trapezoid */
	pg_beta = cfhloggrd.zbeta;
    createramp(&gzrf0cfha,ZGRAD,pw_gzrf0cfha,(short)0,
	       MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrf0cfha/
		   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrf0cfha,(LONG)(posstart-pw_gzrf0cfha),
		pw_gzrf0cfha,ia_gzrf0cfh);
    if ( 0 == PLAY_GFILE)
      {
	/*********************************************************************** 
	 ** Now create the waveform & perform required system safety checks
	 ** create a temporary buffer to modify gradient data using createreserve. Here
	 ** the values of cyc_rf and alpha_rf are irrelevant. Stretch the waveform and
	 ** copy stretched data into permanent waveform memory. It is important to
	 ** to have temp buffer have new resolution size waveform memory.
	 ************************************************************************/
	if (rfpulseInfo[RF0_CFH_SLOT].change==PSD_ON)
	  {
	    createreserve(&gzrf0cfh,ZGRAD,rfpulseInfo[RF0_CFH_SLOT].newres/2);
	    /********************************************************************* 
	     * Change pulse type to external createreserve zero fills resolution
	     * number of points in waveform memory for use.
	     ********************************************************************/
	    gzrf0cfh.type = TYPEXTERNAL;
	    createinstr(&gzrf0cfh,(LONG)(posstart),
			pw_gzrf0cfh,ia_gzrf0cfh);

                movestretchedwave( grad_zrf0cfh, res_gzrf0cfh,
                                   &gzrf0cfh, 0, rfpulseInfo[RF0_CFH_SLOT].newres/2 );
	  }
	else
	  {
	    createextwave(&gzrf0cfh,ZGRAD, 
			  res_gzrf0cfh, grad_zrf0cfh);
	    createinstr(&gzrf0cfh,(LONG)(posstart),
			pw_gzrf0cfh,ia_gzrf0cfh);
	  }
      }
    else
      {
	createconst(&gzrf0cfh,ZGRAD, pw_rf0cfh,MAX_PG_WAMP);
	createinstr( &gzrf0cfh,(LONG)(posstart),
		    pw_gzrf0cfh,ia_gzrf0cfh);
      }
    /* Decay ramp */
    createramp(&gzrf0cfhd,ZGRAD,pw_gzrf0cfhd,MAX_PG_WAMP,
	       (short)0,(short)(maxGradRes*(pw_gzrf0cfhd/
		   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrf0cfhd,(LONG)(posstart+pw_gzrf0cfh),
		pw_gzrf0cfhd,ia_gzrf0cfh);
    
    /*********************************************************************** 
    ** Now create the rf pulse & perform required system safety checks
    ** create a temporary buffer to modify rfpulse data using createsinc. Here
    ** the values of cyc_rf and alpha_rf are irrelevant. Stretch the pulse and
    ** copy stretched data into permanent waveform memory. It is important to
    ** to have temp buffer have new resolution size waveform memory.
    ************************************************************************/
    if (rfpulseInfo[RF0_CFH_SLOT].change==PSD_ON)
      {
	cyc_rf0cfh = 1.0; /* Make sure we have a value for createsinc */
	createsinc(&rf0cfh,(WF_PROCESSOR)wg_rf0cfh,rfpulseInfo[RF0_CFH_SLOT].newres,
		   MAX_PG_WAMP,cyc_rf0cfh,alpha_rf0cfh);
	createinstr(&rf0cfh,(LONG)(posstart) + psd_rf_wait,
		    pw_rf0cfh,ia_rf0cfh);
	linkpulses(4,&rf0cfh,&gzrf0cfh,&gzrf0cfha,
		   &gzrf0cfhd);
	addrfbits(&rf0cfh,off_rf0cfh,(LONG)(posstart) + psd_rf_wait,
		  pw_rf0cfh);

            movestretchedwave( rf_rf0cfh, res_rf0cfh,
                               &rf0cfh, 0, rfpulseInfo[RF0_CFH_SLOT].newres );
      }
    else
      {
	/* No rf scaling required. Use createextwave to read pulse 
	 * and move to HW 
	 */
	createextwave(&rf0cfh,(WF_PROCESSOR)wg_rf0cfh,
		      res_rf0cfh,rf_rf0cfh);
	createinstr(&rf0cfh,(LONG)(posstart) + psd_rf_wait,
		    pw_rf0cfh,ia_rf0cfh);
	linkpulses(4,&rf0cfh,&gzrf0cfh,&gzrf0cfha,
		   &gzrf0cfhd);
	addrfbits(&rf0cfh,off_rf0cfh,(LONG)(posstart) + psd_rf_wait,
		  pw_rf0cfh);
      }
}


           
                   
  {
        INT old_res =  res_omegarf0cfh; /* temp holder for old pulse resolution */

    if ( (wg_omegarf0cfh != TYPRHO1)  && (wg_omegarf0cfh != TYPRHO2) &&
         (wg_omegarf0cfh != TYPTHETA) && (wg_omegarf0cfh != TYPOMEGA) ) {

        fprintf( stderr, "EXTWAVE2 macro must create pulses on RHO1 or RHO2.\n");
        fflush( stderr );

        return FAILURE;
    }

    n_omegarf0cfh += 1;  /* Increment counter */

    /*** Read in waveform if it has not been created yet ***/

    if( omegarf0cfh.ninsts == 0 ) {        

        /* Set pulsename */
        pulsename(&omegarf0cfh,"omegarf0cfh");
        
        /* Scale waveform if needed */
            if( rfpulseInfo[rfslot_omegarf0cfh].change==PSD_ON )
            {
                INT new_res =  rfpulseInfo[rfslot_omegarf0cfh].newres;

            /* ***************************************************************
             *  Create some board waveform space, scale the pulse, and then
             *  move the local memory to the reserved board memory, and set
             *  pulsepointers to new stretched pulse.
             *
             *  Now create the rf pulse & perform required system safety
             *  checks and create a temporary buffer for the stretched RF
             *  pulse. Stretch the pulse and copy stretched data into
             *  permanent waveform memory. It is important to have temp
             *  buffer have new resolution size waveform memory.
             *************************************************************** */

            /* Reserve waveform memory on the RF channel for
               stretched RF pulse */
            createreserve(&omegarf0cfh, (WF_PROCESSOR)wg_omegarf0cfh, new_res);

                movestretchedwave( fileloc_omegarf0cfh, old_res,
                                   &omegarf0cfh, 0, new_res );
            
            /*  Set the resolution of the RF pulse to the resolution of the
             *  stretched RF pulse.  This is done becaused the createinstr()
             *  access the RF pulse structure, which contains a reference to
             *  the resolution of the RF pulse.  When the instruction is
             *  created it must contain the resolution of the stretched RF
             *  pulse.
             */
            res_omegarf0cfh = new_res;
        } else {
            
            /* No rf scaling required. Use createextwave
               to read pulse and move to HW.             */ 
            createextwave(&omegarf0cfh,(WF_PROCESSOR)wg_omegarf0cfh,
                          old_res,fileloc_omegarf0cfh);
        }
    }


    /*** Create Instruction Node ***/
    createinstr( &omegarf0cfh,(LONG)(posstart) + psd_rf_wait, 
                 pw_omegarf0cfh,ia_omegarf0cfh);
    

    /*** Add RF Bits ***/
    addrfbits(&omegarf0cfh,off_omegarf0cfh,(LONG)(posstart) + psd_rf_wait,
              pw_omegarf0cfh);
    

    /*** Reset Resolution ***/
    res_omegarf0cfh = old_res;
    /* Reset the resolution of the RF pulse to the original
       (unstretched) resolution. This is necessary to allow this macro
       to be called multiple times. */
  }


           
                     

    setWaveformPurpose(gyrf0kcfha, gyrf0kcfh.purpose);
    setWaveformPurpose(gyrf0kcfhd, gyrf0kcfh.purpose);
    trapezoid((WF_PROCESSOR)wg_gyrf0kcfh, "gyrf0kcfh", &gyrf0kcfh, &gyrf0kcfha,
              &gyrf0kcfhd, pw_gyrf0kcfh, pw_gyrf0kcfha, pw_gyrf0kcfhd,
              ia_gyrf0kcfh, 0, 0, 0, 0, pend(&gzrf0cfh,"gzrf0cfh",0)+pw_gyrf0kcfha-pw_gyrf0kcfha, TRAP_ALL,
              &cfhloggrd);

    
        /* Setting up WAIT duration */
        /* 1ms is added at the end so that ssp sequencer has no overlap 
           as 'frq', and RF amp unblank pulses are played. */
        dur_invse = RUP_GRD(cfh_ti - pw_rf0cfh/2 - pw_gyrf0kcfha - pw_gyrf0kcfh 
                            - pw_gyrf0kcfhd  - pw_gzrf1cfha - pw_rf1cfh/2 - 1000);
#ifdef PSD_CFH_CHEMSAT
        if ((cs_sat == PSD_ON) && PScs_sat)
        {
            /* GEHmr03577 : Subtract specir_delay in case of SPECIAL. */
#ifdef PSD_CFH_CHEMSAT_SPECIAL
            dur_invse -= RUP_GRD(cs_sattime - specir_delay);
#else
            dur_invse -= RUP_GRD(cs_sattime);
#endif
        }
#endif
        dur_invse = RUP_GRD(dur_invse);

        
  {
      if( TYPXGRAD == (WF_PROCESSOR)wg_zticfh || TYPYGRAD == (WF_PROCESSOR)wg_zticfh || TYPZGRAD == (WF_PROCESSOR)wg_zticfh
          || TYPBXGRAD == (WF_PROCESSOR)wg_zticfh || TYPBYGRAD == (WF_PROCESSOR)wg_zticfh || TYPBZGRAD == (WF_PROCESSOR)wg_zticfh )
      {
          setWaveformPurpose(zticfh, WAIT_GRAD);
      }
      else if( TYPRHO1 == (WF_PROCESSOR)wg_zticfh || TYPRHO2 == (WF_PROCESSOR)wg_zticfh || TYPTHETA == (WF_PROCESSOR)wg_zticfh
               || TYPBRHO1 == (WF_PROCESSOR)wg_zticfh || TYPBRHO2 == (WF_PROCESSOR)wg_zticfh || TYPBTHETA == (WF_PROCESSOR)wg_zticfh
               || TYPOMEGA == (WF_PROCESSOR)wg_zticfh || TYPBOMEGA == (WF_PROCESSOR)wg_zticfh )
      {
          setWaveformPurpose(zticfh, WAIT_RF);
      }
      else if( TYPSSP == (WF_PROCESSOR)wg_zticfh || TYPBSSP == (WF_PROCESSOR)wg_zticfh )
      {
          setWaveformPurpose(zticfh, WAIT_SSP);
      }
    pulsename(&zticfh,"zticfh");
    createconst(&zticfh,(WF_PROCESSOR)wg_zticfh,pw_zticfh,(short)0); 
    createinstr( &zticfh,(long)(pend(&gyrf0kcfhd,"gyrf0kcfhd",0)),pw_zticfh,0);
  }

        
  {
      if( TYPXGRAD == (WF_PROCESSOR)wg_rticfh || TYPYGRAD == (WF_PROCESSOR)wg_rticfh || TYPZGRAD == (WF_PROCESSOR)wg_rticfh
          || TYPBXGRAD == (WF_PROCESSOR)wg_rticfh || TYPBYGRAD == (WF_PROCESSOR)wg_rticfh || TYPBZGRAD == (WF_PROCESSOR)wg_rticfh )
      {
          setWaveformPurpose(rticfh, WAIT_GRAD);
      }
      else if( TYPRHO1 == (WF_PROCESSOR)wg_rticfh || TYPRHO2 == (WF_PROCESSOR)wg_rticfh || TYPTHETA == (WF_PROCESSOR)wg_rticfh
               || TYPBRHO1 == (WF_PROCESSOR)wg_rticfh || TYPBRHO2 == (WF_PROCESSOR)wg_rticfh || TYPBTHETA == (WF_PROCESSOR)wg_rticfh
               || TYPOMEGA == (WF_PROCESSOR)wg_rticfh || TYPBOMEGA == (WF_PROCESSOR)wg_rticfh )
      {
          setWaveformPurpose(rticfh, WAIT_RF);
      }
      else if( TYPSSP == (WF_PROCESSOR)wg_rticfh || TYPBSSP == (WF_PROCESSOR)wg_rticfh )
      {
          setWaveformPurpose(rticfh, WAIT_SSP);
      }
    pulsename(&rticfh,"rticfh");
    createconst(&rticfh,(WF_PROCESSOR)wg_rticfh,pw_rticfh,(short)0); 
    createinstr( &rticfh,(long)(pend(&gyrf0kcfhd,"gyrf0kcfhd",0)),pw_rticfh,0);
  }

        
  {
      if( TYPXGRAD == (WF_PROCESSOR)wg_xticfh || TYPYGRAD == (WF_PROCESSOR)wg_xticfh || TYPZGRAD == (WF_PROCESSOR)wg_xticfh
          || TYPBXGRAD == (WF_PROCESSOR)wg_xticfh || TYPBYGRAD == (WF_PROCESSOR)wg_xticfh || TYPBZGRAD == (WF_PROCESSOR)wg_xticfh )
      {
          setWaveformPurpose(xticfh, WAIT_GRAD);
      }
      else if( TYPRHO1 == (WF_PROCESSOR)wg_xticfh || TYPRHO2 == (WF_PROCESSOR)wg_xticfh || TYPTHETA == (WF_PROCESSOR)wg_xticfh
               || TYPBRHO1 == (WF_PROCESSOR)wg_xticfh || TYPBRHO2 == (WF_PROCESSOR)wg_xticfh || TYPBTHETA == (WF_PROCESSOR)wg_xticfh
               || TYPOMEGA == (WF_PROCESSOR)wg_xticfh || TYPBOMEGA == (WF_PROCESSOR)wg_xticfh )
      {
          setWaveformPurpose(xticfh, WAIT_RF);
      }
      else if( TYPSSP == (WF_PROCESSOR)wg_xticfh || TYPBSSP == (WF_PROCESSOR)wg_xticfh )
      {
          setWaveformPurpose(xticfh, WAIT_SSP);
      }
    pulsename(&xticfh,"xticfh");
    createconst(&xticfh,(WF_PROCESSOR)wg_xticfh,pw_xticfh,(short)0); 
    createinstr( &xticfh,(long)(pend(&gyrf0kcfhd,"gyrf0kcfhd",0)),pw_xticfh,0);
  }

        
  {
      if( TYPXGRAD == (WF_PROCESSOR)wg_yticfh || TYPYGRAD == (WF_PROCESSOR)wg_yticfh || TYPZGRAD == (WF_PROCESSOR)wg_yticfh
          || TYPBXGRAD == (WF_PROCESSOR)wg_yticfh || TYPBYGRAD == (WF_PROCESSOR)wg_yticfh || TYPBZGRAD == (WF_PROCESSOR)wg_yticfh )
      {
          setWaveformPurpose(yticfh, WAIT_GRAD);
      }
      else if( TYPRHO1 == (WF_PROCESSOR)wg_yticfh || TYPRHO2 == (WF_PROCESSOR)wg_yticfh || TYPTHETA == (WF_PROCESSOR)wg_yticfh
               || TYPBRHO1 == (WF_PROCESSOR)wg_yticfh || TYPBRHO2 == (WF_PROCESSOR)wg_yticfh || TYPBTHETA == (WF_PROCESSOR)wg_yticfh
               || TYPOMEGA == (WF_PROCESSOR)wg_yticfh || TYPBOMEGA == (WF_PROCESSOR)wg_yticfh )
      {
          setWaveformPurpose(yticfh, WAIT_RF);
      }
      else if( TYPSSP == (WF_PROCESSOR)wg_yticfh || TYPBSSP == (WF_PROCESSOR)wg_yticfh )
      {
          setWaveformPurpose(yticfh, WAIT_SSP);
      }
    pulsename(&yticfh,"yticfh");
    createconst(&yticfh,(WF_PROCESSOR)wg_yticfh,pw_yticfh,(short)0); 
    createinstr( &yticfh,(long)(pend(&gyrf0kcfhd,"gyrf0kcfhd",0)),pw_yticfh,0);
  }

        
  {
      if( TYPXGRAD == (WF_PROCESSOR)wg_sticfh || TYPYGRAD == (WF_PROCESSOR)wg_sticfh || TYPZGRAD == (WF_PROCESSOR)wg_sticfh
          || TYPBXGRAD == (WF_PROCESSOR)wg_sticfh || TYPBYGRAD == (WF_PROCESSOR)wg_sticfh || TYPBZGRAD == (WF_PROCESSOR)wg_sticfh )
      {
          setWaveformPurpose(sticfh, WAIT_GRAD);
      }
      else if( TYPRHO1 == (WF_PROCESSOR)wg_sticfh || TYPRHO2 == (WF_PROCESSOR)wg_sticfh || TYPTHETA == (WF_PROCESSOR)wg_sticfh
               || TYPBRHO1 == (WF_PROCESSOR)wg_sticfh || TYPBRHO2 == (WF_PROCESSOR)wg_sticfh || TYPBTHETA == (WF_PROCESSOR)wg_sticfh
               || TYPOMEGA == (WF_PROCESSOR)wg_sticfh || TYPBOMEGA == (WF_PROCESSOR)wg_sticfh )
      {
          setWaveformPurpose(sticfh, WAIT_RF);
      }
      else if( TYPSSP == (WF_PROCESSOR)wg_sticfh || TYPBSSP == (WF_PROCESSOR)wg_sticfh )
      {
          setWaveformPurpose(sticfh, WAIT_SSP);
      }
    pulsename(&sticfh,"sticfh");
    createconst(&sticfh,(WF_PROCESSOR)wg_sticfh,pw_sticfh,(short)0); 
    createinstr( &sticfh,(long)(pend(&gyrf0kcfhd,"gyrf0kcfhd",0)),pw_sticfh,0);
  }

    
        setperiod(dur_invse,&zticfh,0);
        setperiod(dur_invse,&rticfh,0);
        setperiod(dur_invse,&xticfh,0);
        setperiod(dur_invse,&yticfh,0);
        setperiod(dur_invse,&sticfh,0);
    
        /* Change start time for the 90 180 sequence; pw_gzrf1cfha added to 
           offset start_time calc in rf1cfh call */
        start_time    = pmid(&gzrf0cfh,"gzrf0cfh",0) + cfh_ti - pw_rf1cfh/2;
        start_time_CS = pend(&gyrf0kcfhd,"gyrf0kcfhd",0) + dur_invse + 300  ;

        amp_gyrf0kcfh = ia_gyrf0kcfh;
    }
    /* End of IR sequence check */
  
  

#ifdef PSD_CFH_CHEMSAT
    if ((cs_sat == PSD_ON) && PScs_sat)
    {
        ChemSatPG(start_time_CS, &cscfh_satindex);
        cscfh_satindex -= 1;
    }
    if( (PSir != PSD_ON) && ( ((oppseq!=PSD_IR)
                               || (ssfse_ir_on == PSD_OFF)) && PScs_sat ) )
    {
        /* MRIge30640 - already caught in SLICESELZ2 call below! */
        /* GEHmr03577 : Subtract specir_delay in case of SPECIAL. */
#ifdef PSD_CFH_CHEMSAT_SPECIAL
        start_time += (cs_sattime - specir_delay);
#else
        start_time += cs_sattime;
#endif
    }
#else /* !defined PSD_CFH_CHEMSAT */
    (void)start_time_CS;
#endif
  
    /*  90 slice sel pulse  */
       
                 
                        
                    
    {
        /* Check for RF waveform generator */
        RFEnvelopeWaveformGeneratorCheck("rf1cfh",
                                         (WF_PROCESSOR)wg_rf1cfh);

        /* Modify resolution if scaling required */
        temp_res_rf1cfh = res_rf1cfh;
        if (rfpulseInfo[RF1_CFH_SLOT].change==PSD_ON)
        {
            res_rf1cfh = rfpulseInfo[RF1_CFH_SLOT].newres;
        }
        /* First create the pulses */
        pulsename(&gzrf1cfha,"gzrf1cfha");
        setWaveformPurpose(gzrf1cfha, RF_SELECT_GRAD);
        pulsename(&gzrf1cfh,"gzrf1cfh");
        setWaveformPurpose(gzrf1cfh, RF_SELECT_GRAD);
        pulsename(&gzrf1cfhd,"gzrf1cfhd");
        setWaveformPurpose(gzrf1cfhd, RF_SELECT_GRAD);
        pulsename(&rf1cfh,"rf1cfh");

        /*  Now create the slice select trapezoid */
        pg_beta = cfhloggrd.zbeta;
        createramp(&gzrf1cfha,ZGRAD,pw_gzrf1cfha,(short)0,
                   MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrf1cfha/
                       GRAD_UPDATE_TIME)),pg_beta);
        createinstr( &gzrf1cfha,(LONG)(RUP_GRD(start_time+pw_gzrf1cfha)-pw_gzrf1cfha),
                     pw_gzrf1cfha,ia_gzrf1cfh);
        createconst(&gzrf1cfh,ZGRAD,pw_gzrf1cfh,MAX_PG_WAMP);
        createinstr( &gzrf1cfh,(LONG)(RUP_GRD(start_time+pw_gzrf1cfha)),
                     pw_gzrf1cfh,ia_gzrf1cfh);
        createramp(&gzrf1cfhd,ZGRAD,pw_gzrf1cfhd,MAX_PG_WAMP,
                   (short)0,(short)(maxGradRes*(pw_gzrf1cfhd/GRAD_UPDATE_TIME)),
                   pg_beta);
        createinstr( &gzrf1cfhd,(LONG)(RUP_GRD(start_time+pw_gzrf1cfha)+pw_gzrf1cfh),
                     pw_gzrf1cfhd,ia_gzrf1cfh);

        /* Now create the rf pulse */
        createsinc(&rf1cfh,(WF_PROCESSOR)wg_rf1cfh,res_rf1cfh,
                   MAX_PG_WAMP,cyc_rf1cfh, alpha_rf1cfh);
        createinstr( &rf1cfh,(LONG)(RUP_GRD(start_time+pw_gzrf1cfha)) + psd_rf_wait,
                     pw_rf1cfh,ia_rf1cfh);
        linkpulses(4,&rf1cfh,&gzrf1cfh,&gzrf1cfha,
                   &gzrf1cfhd);
        addrfbits(&rf1cfh,off_rf1cfh,(LONG)(RUP_GRD(start_time+pw_gzrf1cfha)) + psd_rf_wait,
                  pw_rf1cfh);
        /* Changed back resolution incase external rf used later in pulsegen. We need
         * original resolution to scale pulses that are external
         */
        if (rfpulseInfo[RF1_CFH_SLOT].change==PSD_ON)
        {
            res_rf1cfh = temp_res_rf1cfh;
        }
    }


    if(PSfield_strength <= B0_5000)
    {

        cfh_te = (int)(0.5 * pw_rf1cfh + PSoff90 + pw_rf2cfh
                       + IMax(2, min_ssp,
                              (pw_gzrf1cfhd + pw_gzrf2lcfha
                               + pw_gzrf2lcfh + pw_gzrf2lcfhd))
                       + pw_gzrf2rcfha + pw_gzrf2rcfh + pw_gzrf2rcfhd
                       + (cfh_tdaq  * cfh_ec_position));

        cfh_te2 = (int)((IMax(2, min_ssp,
                         (pw_gzrf2lcfha + pw_gzrf2lcfh + pw_gzrf2lcfhd
                          + pw_gzrf2rcfha + pw_gzrf2rcfh + pw_gzrf2rcfhd))
                    + pw_rf2cfh)/ 2
                   + (cfh_tdaq * cfh_ec_position));
        cfh_te2 *= 2;

        cfh_te = IMax(3, cfh_te, cfh_te2, min180te);

        pos_rf2 = RDN_GRD((int)(pmid(&gzrf1cfh,"gzrf1cfh", 0)
                                + 0.5 * cfh_te - 0.5 * pw_rf2cfh));
    }
    else
    {
        if( presscfh_ctrl == PRESSCFH_NONE )
        {
            cfh_te =  (int)(0.5 * (pw_rf1cfh + pw_rf2cfh) + PSoff90
                            + IMax(2, min_ssp,
                                   (pw_gzrf1cfhd + pw_gzrf2lcfha
                                    + pw_gzrf2lcfh + pw_gzrf2lcfhd)));
            if (opspf == 0)
            {
                cfh_te = 2*IMax(3, cfh_te, pw_gxrf2cfhd, pw_gzrf2rcfha + pw_gzrf2rcfh + pw_gzrf2rcfhd);
            }
            else
            {
                cfh_te = 2*IMax(3, cfh_te, pw_gyrf2cfhd, pw_gzrf2rcfha + pw_gzrf2rcfh + pw_gzrf2rcfhd);
            }

            /* MRIge90312 - use 50ms TE for cfh */
            cfh_te = IMax(3, cfh_te, min180te, eff_cfh_te);

            pos_rf2 = RDN_GRD((int)(pmid(&gzrf1cfh,"gzrf1cfh", 0) - PSoff90 
                                    + 0.5 * cfh_te - 0.5 * pw_rf2cfh));
        }
        else
        {
            int temp_time = 0;

            cfh_te = IMax(2, presscfh_minte, eff_cfh_te);
            if( cfh_steam_flag != PSD_ON )
            {
                int echo1te = 0;

                echo1te =  (int)(0.5 * (pw_rf1cfh + pw_rf2cfh) + PSoff90 +
                                 IMax(2, min_ssp, (pw_gzrf1cfhd + pw_gzrf2lcfha + pw_gzrf2lcfh + pw_gzrf2lcfhd))
                                 + presscfh_wait_rf12);

                echo1te = 2*IMax(3, echo1te, pw_gxrf2cfhd, pw_gzrf2rcfha + pw_gzrf2rcfh + pw_gzrf2rcfhd);

                echo1te = IMax(2, echo1te, min180te);
                pos_rf2 = RDN_GRD((int)(pmid(&gzrf1cfh,"gzrf1cfh", 0) - PSoff90 
                                        + 0.5 * echo1te - 0.5 * pw_rf2cfh));

                if( presscfh_ctrl != PRESSCFH_SHIMVOL_SLICE )
                {
                    temp_time = IMax(2, pw_gyrf3cfha, pw_gzrf3lcfha + pw_gzrf3lcfh + pw_gzrf3lcfhd);
                    cfh_te = IMax(2, 2*temp_time + echo1te + pw_rf3cfh, cfh_te);

                    pos_rf3 = RDN_GRD((int)(pos_rf2 + 0.5*pw_gxrf2cfh + 0.5*cfh_te - 0.5*pw_rf3cfh));
                }
                else
                {
                    int echo2te = 0;    /* interval from echo1 center to echo2 center, not from RF1 to echo2 center */
                    int echo3te = 0;    /* interval from echo2 center to echo3 center, not from RF1 to echo3 center */

                    /* Calculate the position of RF3 */
                    echo2te = (int)(0.5 * pw_rf3cfh
                                    + IMax(3, min_ssp, pw_gyrf3cfha, (pw_gzrf3lcfha + pw_gzrf3lcfh + pw_gzrf3lcfhd))
                                    + presscfh_wait_rf23);
                    echo2te = 2*echo2te;
                    echo2te = IMax(2, echo2te, min180te);

                    pos_rf3 = RDN_GRD((int)(pos_rf2 + 0.5*pw_gxrf2cfh + 0.5*echo1te + 0.5*echo2te - 0.5*pw_rf3cfh));

                    /* Calculate the position of RF4 */
                    echo3te = (int)(0.5 * pw_rf4cfh + pw_gzrf4cfha + pw_isislice + pw_rotslice + isi_sliceextra
                                    + min_ssp + pw_gzrf4lcfha + pw_gzrf4lcfh + pw_gzrf4lcfhd
                                    + presscfh_wait_rf34);

                    echo3te = 2*echo3te;
                    echo3te = IMax(2, echo3te, min180te);

                    cfh_te = IMax(2, echo1te + echo2te + echo3te, cfh_te);
                    pos_rf4 = RDN_GRD((int)(pos_rf3 + 0.5*pw_rf3cfh + 0.5*(cfh_te-echo1te) - 0.5*pw_rf4cfh));
                }
            }
            else
            {
                int mix_time = 0;

                temp_time = IMax(2, 2*min_ssp,  pw_gzrf2rcfha + pw_gzrf2rcfh + pw_gzrf2rcfhd 
                                 + steam_pg_gap + pw_gzrf3lcfha + pw_gzrf3lcfh + pw_gzrf3lcfhd);
                mix_time = RUP_GRD(0.5 * (pw_gxrf2cfh + pw_gyrf3cfh) + temp_time);

                pos_rf2 = RUP_GRD( pmid(&gzrf1cfh,"gzrf1cfh",0) + 0.5*cfh_te - 0.5*pw_gxrf2cfh );
                pos_rf3 = RUP_GRD( pos_rf2 + 0.5*pw_gxrf2cfh + mix_time - 0.5*pw_gyrf3cfh );
            }
        }
    }

    if (rfpulseInfo[RF2_CFH_SLOT].change==PSD_ON)
    {
        res_rf2cfh = rfpulseInfo[RF2_CFH_SLOT].newres;
    }

         
  {
    pulsename(&rf2cfh,"rf2cfh");
    createsinc(&rf2cfh,(WF_PROCESSOR)wg_rf2cfh,res_rf2cfh,
               MAX_PG_WAMP,cyc_rf2cfh,alpha_rf2cfh);
    if ((wg_rf2cfh==TYPRHO1)||(wg_rf2cfh==TYPRHO2) ||
        (wg_rf2cfh==TYPTHETA)||(wg_rf2cfh==TYPOMEGA))
      {
        createinstr( &rf2cfh,(long)(pos_rf2) + psd_rf_wait,
                    pw_rf2cfh,ia_rf2cfh);
        addrfbits(&rf2cfh,off_rf2cfh,(long)(pos_rf2) + psd_rf_wait,
                  pw_rf2cfh);
      }
    else
      {
        createinstr( &rf2cfh,(long)(pos_rf2),
                    pw_rf2cfh,ia_rf2cfh);
      }
  }

    if( presscfh_ctrl != PRESSCFH_NONE )  /* for presscfh_ctrl */
    {
               
  {
    pulsename(&rf3cfh,"rf3cfh");
    createsinc(&rf3cfh,(WF_PROCESSOR)wg_rf3cfh,res_rf3cfh,
               MAX_PG_WAMP,cyc_rf3cfh,alpha_rf3cfh);
    if ((wg_rf3cfh==TYPRHO1)||(wg_rf3cfh==TYPRHO2) ||
        (wg_rf3cfh==TYPTHETA)||(wg_rf3cfh==TYPOMEGA))
      {
        createinstr( &rf3cfh,(long)(pos_rf3) + psd_rf_wait,
                    pw_rf3cfh,ia_rf3cfh);
        addrfbits(&rf3cfh,off_rf3cfh,(long)(pos_rf3) + psd_rf_wait,
                  pw_rf3cfh);
      }
    else
      {
        createinstr( &rf3cfh,(long)(pos_rf3),
                    pw_rf3cfh,ia_rf3cfh);
      }
  }
  
        if( presscfh_ctrl == PRESSCFH_SHIMVOL_SLICE )
        {
                 
  {
    pulsename(&rf4cfh,"rf4cfh");
    createsinc(&rf4cfh,(WF_PROCESSOR)wg_rf4cfh,res_rf4cfh,
               MAX_PG_WAMP,cyc_rf4cfh,alpha_rf4cfh);
    if ((wg_rf4cfh==TYPRHO1)||(wg_rf4cfh==TYPRHO2) ||
        (wg_rf4cfh==TYPTHETA)||(wg_rf4cfh==TYPOMEGA))
      {
        createinstr( &rf4cfh,(long)(pos_rf4) + psd_rf_wait,
                    pw_rf4cfh,ia_rf4cfh);
        addrfbits(&rf4cfh,off_rf4cfh,(long)(pos_rf4) + psd_rf_wait,
                  pw_rf4cfh);
      }
    else
      {
        createinstr( &rf4cfh,(long)(pos_rf4),
                    pw_rf4cfh,ia_rf4cfh);
      }
  }

        }
    } 

    if(PSdebugstate)	/* vmx 05/02/95 YO */
    {
	printf("CFH : TE = %d\n", cfh_te);
	printf("CFH : Mid Position of rf2cfh = %d\n", (int)(pos_rf2+pw_rf2cfh/2));
    }

    /* FOV selective gradients */
    if (opspf == 0 || presscfh_ctrl != PRESSCFH_NONE)
    {
             
                    

    setWaveformPurpose(gxrf2cfha, gxrf2cfh.purpose);
    setWaveformPurpose(gxrf2cfhd, gxrf2cfh.purpose);
    trapezoid((WF_PROCESSOR)wg_gxrf2cfh, "gxrf2cfh", &gxrf2cfh, &gxrf2cfha,
              &gxrf2cfhd, pw_gxrf2cfh, pw_gxrf2cfha, pw_gxrf2cfhd,
              ia_gxrf2cfh, 0, 0, 0, 0, pbegall(&rf2cfh,0)-psd_rf_wait-pw_gxrf2cfha, TRAP_ALL,
              &cfhloggrd);

    }
    else
    {
             
                    

    setWaveformPurpose(gyrf2cfha, gyrf2cfh.purpose);
    setWaveformPurpose(gyrf2cfhd, gyrf2cfh.purpose);
    trapezoid((WF_PROCESSOR)wg_gyrf2cfh, "gyrf2cfh", &gyrf2cfh, &gyrf2cfha,
              &gyrf2cfhd, pw_gyrf2cfh, pw_gyrf2cfha, pw_gyrf2cfhd,
              ia_gyrf2cfh, 0, 0, 0, 0, pbegall(&rf2cfh,0)-psd_rf_wait-pw_gyrf2cfha, TRAP_ALL,
              &cfhloggrd);

    }
    
    /* Z crushers */
        
                      

    setWaveformPurpose(gzrf2lcfha, gzrf2lcfh.purpose);
    setWaveformPurpose(gzrf2lcfhd, gzrf2lcfh.purpose);
    trapezoid((WF_PROCESSOR)wg_gzrf2lcfh, "gzrf2lcfh", &gzrf2lcfh, &gzrf2lcfha,
              &gzrf2lcfhd, pw_gzrf2lcfh, pw_gzrf2lcfha, pw_gzrf2lcfhd,
              ia_gzrf2lcfh, 0, 0, 0, 0, pbegall(&rf2cfh,0)-(pw_gzrf2lcfh+pw_gzrf2lcfhd)-psd_rf_wait-pw_gzrf2lcfha, TRAP_ALL,
              &cfhloggrd);

         
                  

    setWaveformPurpose(gzrf2rcfha, gzrf2rcfh.purpose);
    setWaveformPurpose(gzrf2rcfhd, gzrf2rcfh.purpose);
    trapezoid((WF_PROCESSOR)wg_gzrf2rcfh, "gzrf2rcfh", &gzrf2rcfh, &gzrf2rcfha,
              &gzrf2rcfhd, pw_gzrf2rcfh, pw_gzrf2rcfha, pw_gzrf2rcfhd,
              ia_gzrf2rcfh, 0, 0, 0, 0, pendall(&rf2cfh,0)+pw_gzrf2rcfha-psd_rf_wait-pw_gzrf2rcfha, TRAP_ALL,
              &cfhloggrd);


   if( presscfh_ctrl != PRESSCFH_NONE )
   {
             
                        

    setWaveformPurpose(gyrf3cfha, gyrf3cfh.purpose);
    setWaveformPurpose(gyrf3cfhd, gyrf3cfh.purpose);
    trapezoid((WF_PROCESSOR)wg_gyrf3cfh, "gyrf3cfh", &gyrf3cfh, &gyrf3cfha,
              &gyrf3cfhd, pw_gyrf3cfh, pw_gyrf3cfha, pw_gyrf3cfhd,
              ia_gyrf3cfh, 0, 0, 0, 0, pbegall(&rf3cfh,0)-psd_rf_wait-pw_gyrf3cfha, TRAP_ALL,
              &cfhloggrd);


        /* Z crushers */
            
                          

    setWaveformPurpose(gzrf3lcfha, gzrf3lcfh.purpose);
    setWaveformPurpose(gzrf3lcfhd, gzrf3lcfh.purpose);
    trapezoid((WF_PROCESSOR)wg_gzrf3lcfh, "gzrf3lcfh", &gzrf3lcfh, &gzrf3lcfha,
              &gzrf3lcfhd, pw_gzrf3lcfh, pw_gzrf3lcfha, pw_gzrf3lcfhd,
              ia_gzrf3lcfh, 0, 0, 0, 0, pbegall(&rf3cfh,0)-(pw_gzrf3lcfh+pw_gzrf3lcfhd)-psd_rf_wait-pw_gzrf3lcfha, TRAP_ALL,
              &cfhloggrd);

             
                      

    setWaveformPurpose(gzrf3rcfha, gzrf3rcfh.purpose);
    setWaveformPurpose(gzrf3rcfhd, gzrf3rcfh.purpose);
    trapezoid((WF_PROCESSOR)wg_gzrf3rcfh, "gzrf3rcfh", &gzrf3rcfh, &gzrf3rcfha,
              &gzrf3rcfhd, pw_gzrf3rcfh, pw_gzrf3rcfha, pw_gzrf3rcfhd,
              ia_gzrf3rcfh, 0, 0, 0, 0, pendall(&rf3cfh,0)+pw_gzrf3rcfha-psd_rf_wait-pw_gzrf3rcfha, TRAP_ALL,
              &cfhloggrd);


        /* steam_flag */
        if( cfh_steam_flag == PSD_ON ){
            INT pos_g1cfh = 0;
            pos_g1cfh = RUP_GRD( pbeg(&gzrf2lcfh, "gzrf2lcfh", 0) - pw_gzrf2lcfha 
                                 - pw_gy1cfh - pw_gy1cfhd );
                 

    setWaveformPurpose(gy1cfha, gy1cfh.purpose);
    setWaveformPurpose(gy1cfhd, gy1cfh.purpose);
    trapezoid((WF_PROCESSOR)wg_gy1cfh, "gy1cfh", &gy1cfh, &gy1cfha,
              &gy1cfhd, pw_gy1cfh, pw_gy1cfha, pw_gy1cfhd,
              ia_gy1cfh, 0, 0, 0, 0, pos_g1cfh-pw_gy1cfha, TRAP_ALL,
              &cfhloggrd);

            pos_g1cfh = RUP_GRD( pend(&gzrf3rcfh, "gzrf3rcfh", 0) + pw_gzrf3rcfhd + pw_gx1cfha );
                 

    setWaveformPurpose(gx1cfha, gx1cfh.purpose);
    setWaveformPurpose(gx1cfhd, gx1cfh.purpose);
    trapezoid((WF_PROCESSOR)wg_gx1cfh, "gx1cfh", &gx1cfh, &gx1cfha,
              &gx1cfhd, pw_gx1cfh, pw_gx1cfha, pw_gx1cfhd,
              ia_gx1cfh, 0, 0, 0, 0, pos_g1cfh-pw_gx1cfha, TRAP_ALL,
              &cfhloggrd);

        }
        else if( presscfh_ctrl == PRESSCFH_SHIMVOL_SLICE )
        {
            INT pos_isislice1 = 0;
            INT pos_isislice2 = 0;
            long ctrl_word;

                
                            

    setWaveformPurpose(gzrf4cfha, gzrf4cfh.purpose);
    setWaveformPurpose(gzrf4cfhd, gzrf4cfh.purpose);
    trapezoid((WF_PROCESSOR)wg_gzrf4cfh, "gzrf4cfh", &gzrf4cfh, &gzrf4cfha,
              &gzrf4cfhd, pw_gzrf4cfh, pw_gzrf4cfha, pw_gzrf4cfhd,
              ia_gzrf4cfh, 0, 0, 0, 0, pbegall(&rf4cfh,0)-psd_rf_wait-pw_gzrf4cfha, TRAP_ALL,
              &loggrd);


            pos_isislice1 = pbegallssp(&rf4cfh, 0) - pw_gzrf4cfha - pw_isislice - pw_rotslice - isi_sliceextra;
               
  {
      if( TYPXGRAD == (WF_PROCESSOR)wg_isi_slice1 || TYPYGRAD == (WF_PROCESSOR)wg_isi_slice1 || TYPZGRAD == (WF_PROCESSOR)wg_isi_slice1
          || TYPBXGRAD == (WF_PROCESSOR)wg_isi_slice1 || TYPBYGRAD == (WF_PROCESSOR)wg_isi_slice1 || TYPBZGRAD == (WF_PROCESSOR)wg_isi_slice1 )
      {
          setWaveformPurpose(isi_slice1, WAIT_GRAD);
      }
      else if( TYPRHO1 == (WF_PROCESSOR)wg_isi_slice1 || TYPRHO2 == (WF_PROCESSOR)wg_isi_slice1 || TYPTHETA == (WF_PROCESSOR)wg_isi_slice1
               || TYPBRHO1 == (WF_PROCESSOR)wg_isi_slice1 || TYPBRHO2 == (WF_PROCESSOR)wg_isi_slice1 || TYPBTHETA == (WF_PROCESSOR)wg_isi_slice1
               || TYPOMEGA == (WF_PROCESSOR)wg_isi_slice1 || TYPBOMEGA == (WF_PROCESSOR)wg_isi_slice1 )
      {
          setWaveformPurpose(isi_slice1, WAIT_RF);
      }
      else if( TYPSSP == (WF_PROCESSOR)wg_isi_slice1 || TYPBSSP == (WF_PROCESSOR)wg_isi_slice1 )
      {
          setWaveformPurpose(isi_slice1, WAIT_SSP);
      }
    pulsename(&isi_slice1,"isi_slice1");
    createconst(&isi_slice1,(WF_PROCESSOR)wg_isi_slice1,pw_isi_slice1,(short)0); 
    createinstr( &isi_slice1,(long)(pos_isislice1),pw_isi_slice1,0);
  }

            getctrl(&ctrl_word, &isi_slice1, 0);
            ctrl_word = ctrl_word | PSD_ISI_CFH ;
            setctrl(ctrl_word, &isi_slice1, 0);

               
  {
      if( TYPXGRAD == (WF_PROCESSOR)wg_rot_slice1 || TYPYGRAD == (WF_PROCESSOR)wg_rot_slice1 || TYPZGRAD == (WF_PROCESSOR)wg_rot_slice1
          || TYPBXGRAD == (WF_PROCESSOR)wg_rot_slice1 || TYPBYGRAD == (WF_PROCESSOR)wg_rot_slice1 || TYPBZGRAD == (WF_PROCESSOR)wg_rot_slice1 )
      {
          setWaveformPurpose(rot_slice1, WAIT_GRAD);
      }
      else if( TYPRHO1 == (WF_PROCESSOR)wg_rot_slice1 || TYPRHO2 == (WF_PROCESSOR)wg_rot_slice1 || TYPTHETA == (WF_PROCESSOR)wg_rot_slice1
               || TYPBRHO1 == (WF_PROCESSOR)wg_rot_slice1 || TYPBRHO2 == (WF_PROCESSOR)wg_rot_slice1 || TYPBTHETA == (WF_PROCESSOR)wg_rot_slice1
               || TYPOMEGA == (WF_PROCESSOR)wg_rot_slice1 || TYPBOMEGA == (WF_PROCESSOR)wg_rot_slice1 )
      {
          setWaveformPurpose(rot_slice1, WAIT_RF);
      }
      else if( TYPSSP == (WF_PROCESSOR)wg_rot_slice1 || TYPBSSP == (WF_PROCESSOR)wg_rot_slice1 )
      {
          setWaveformPurpose(rot_slice1, WAIT_SSP);
      }
    pulsename(&rot_slice1,"rot_slice1");
    createconst(&rot_slice1,(WF_PROCESSOR)wg_rot_slice1,pw_rot_slice1,(short)0); 
    createinstr( &rot_slice1,(long)(pos_isislice1+pw_isislice),pw_rot_slice1,0);
  }

            getctrl(&ctrl_word, &rot_slice1, 0);
            ctrl_word = ctrl_word | PSD_MTX_UPDT;
            setctrl(ctrl_word, &rot_slice1, 0);

            pos_isislice2 = pendallssp(&rf4cfh, 0) + pw_gzrf4cfhd;
               
  {
      if( TYPXGRAD == (WF_PROCESSOR)wg_isi_slice2 || TYPYGRAD == (WF_PROCESSOR)wg_isi_slice2 || TYPZGRAD == (WF_PROCESSOR)wg_isi_slice2
          || TYPBXGRAD == (WF_PROCESSOR)wg_isi_slice2 || TYPBYGRAD == (WF_PROCESSOR)wg_isi_slice2 || TYPBZGRAD == (WF_PROCESSOR)wg_isi_slice2 )
      {
          setWaveformPurpose(isi_slice2, WAIT_GRAD);
      }
      else if( TYPRHO1 == (WF_PROCESSOR)wg_isi_slice2 || TYPRHO2 == (WF_PROCESSOR)wg_isi_slice2 || TYPTHETA == (WF_PROCESSOR)wg_isi_slice2
               || TYPBRHO1 == (WF_PROCESSOR)wg_isi_slice2 || TYPBRHO2 == (WF_PROCESSOR)wg_isi_slice2 || TYPBTHETA == (WF_PROCESSOR)wg_isi_slice2
               || TYPOMEGA == (WF_PROCESSOR)wg_isi_slice2 || TYPBOMEGA == (WF_PROCESSOR)wg_isi_slice2 )
      {
          setWaveformPurpose(isi_slice2, WAIT_RF);
      }
      else if( TYPSSP == (WF_PROCESSOR)wg_isi_slice2 || TYPBSSP == (WF_PROCESSOR)wg_isi_slice2 )
      {
          setWaveformPurpose(isi_slice2, WAIT_SSP);
      }
    pulsename(&isi_slice2,"isi_slice2");
    createconst(&isi_slice2,(WF_PROCESSOR)wg_isi_slice2,pw_isi_slice2,(short)0); 
    createinstr( &isi_slice2,(long)(pos_isislice2),pw_isi_slice2,0);
  }

            getctrl(&ctrl_word, &isi_slice2, 0);
            ctrl_word = ctrl_word | PSD_ISI_CFH ;
            setctrl(ctrl_word, &isi_slice2, 0);

               
  {
      if( TYPXGRAD == (WF_PROCESSOR)wg_rot_slice2 || TYPYGRAD == (WF_PROCESSOR)wg_rot_slice2 || TYPZGRAD == (WF_PROCESSOR)wg_rot_slice2
          || TYPBXGRAD == (WF_PROCESSOR)wg_rot_slice2 || TYPBYGRAD == (WF_PROCESSOR)wg_rot_slice2 || TYPBZGRAD == (WF_PROCESSOR)wg_rot_slice2 )
      {
          setWaveformPurpose(rot_slice2, WAIT_GRAD);
      }
      else if( TYPRHO1 == (WF_PROCESSOR)wg_rot_slice2 || TYPRHO2 == (WF_PROCESSOR)wg_rot_slice2 || TYPTHETA == (WF_PROCESSOR)wg_rot_slice2
               || TYPBRHO1 == (WF_PROCESSOR)wg_rot_slice2 || TYPBRHO2 == (WF_PROCESSOR)wg_rot_slice2 || TYPBTHETA == (WF_PROCESSOR)wg_rot_slice2
               || TYPOMEGA == (WF_PROCESSOR)wg_rot_slice2 || TYPBOMEGA == (WF_PROCESSOR)wg_rot_slice2 )
      {
          setWaveformPurpose(rot_slice2, WAIT_RF);
      }
      else if( TYPSSP == (WF_PROCESSOR)wg_rot_slice2 || TYPBSSP == (WF_PROCESSOR)wg_rot_slice2 )
      {
          setWaveformPurpose(rot_slice2, WAIT_SSP);
      }
    pulsename(&rot_slice2,"rot_slice2");
    createconst(&rot_slice2,(WF_PROCESSOR)wg_rot_slice2,pw_rot_slice2,(short)0); 
    createinstr( &rot_slice2,(long)(pos_isislice2+pw_isislice),pw_rot_slice2,0);
  }

            getctrl(&ctrl_word, &rot_slice2, 0);
            ctrl_word = ctrl_word | PSD_MTX_UPDT;
            setctrl(ctrl_word, &rot_slice2, 0);
            
            /* Z crushers */
                    
                        

    setWaveformPurpose(gzrf4lcfha, gzrf4lcfh.purpose);
    setWaveformPurpose(gzrf4lcfhd, gzrf4lcfh.purpose);
    trapezoid((WF_PROCESSOR)wg_gzrf4lcfh, "gzrf4lcfh", &gzrf4lcfh, &gzrf4lcfha,
              &gzrf4lcfhd, pw_gzrf4lcfh, pw_gzrf4lcfha, pw_gzrf4lcfhd,
              ia_gzrf4lcfh, 0, 0, 0, 0, RDN_GRD(pos_isislice1-(pw_gzrf4lcfh+pw_gzrf4lcfhd)-psd_rf_wait)-pw_gzrf4lcfha, TRAP_ALL,
              &cfhloggrd);

                        
                        

    setWaveformPurpose(gzrf4rcfha, gzrf4rcfh.purpose);
    setWaveformPurpose(gzrf4rcfhd, gzrf4rcfh.purpose);
    trapezoid((WF_PROCESSOR)wg_gzrf4rcfh, "gzrf4rcfh", &gzrf4rcfh, &gzrf4rcfha,
              &gzrf4rcfhd, pw_gzrf4rcfh, pw_gzrf4rcfha, pw_gzrf4rcfhd,
              ia_gzrf4rcfh, 0, 0, 0, 0, RUP_GRD(pos_isislice2+pw_isislice+pw_rotslice+isi_sliceextra+pw_gzrf4rcfha-psd_rf_wait)-pw_gzrf4rcfha, TRAP_ALL,
              &cfhloggrd);


        }
    }

    /* Data Acquisiton with .5K/.25k filter */
    if(PSfield_strength <= B0_5000)	/* vmx 05/02/94 */
    {
	cfh_acq_window_pos = RUP_GRD( (int)(pmid(&gzrf1cfh,"gzrf1cfh", 0)
                                            + cfh_te - (cfh_tdaq * cfh_ec_position)));
    }
    else
    {
       if( presscfh_ctrl == PRESSCFH_NONE )
       {
	    cfh_acq_window_pos = RUP_GRD(pendall(&gzrf2rcfh,0) + tsamp_delay_cfh);
       }
       else
       {
           if( cfh_steam_flag != PSD_ON )
           {
               if( presscfh_ctrl != PRESSCFH_SHIMVOL_SLICE )
               {
	        cfh_acq_window_pos = RUP_GRD(pendall(&gzrf3rcfh,0) + tsamp_delay_cfh);
               }
               else
               {
                   cfh_acq_window_pos = RUP_GRD(pendall(&gzrf4rcfh,0) + tsamp_delay_cfh);
               }
           }
           else
           {
                cfh_acq_window_pos = RUP_GRD(pendall(&gx1cfh,0) + tsamp_delay_cfh);
            }
        }
    }

    if(PSdebugstate)	/* vmx 05/02/95 YO */
    {
	printf("CFH : Start of data window = %d\n", cfh_acq_window_pos);
    }

          
    {
        pulsename(&cfh_fid,"cfh_fid");
        acqq(&cfh_fid, (long)(cfh_acq_window_pos),(long)(DEFAULTPOS),
             (long)(DEFAULTPOS),(long)filter_cfh_fid,
             (TYPDAB_PACKETS)DABNORM);
    }

    /* vmx 05/02/05 YO */
    /* Assert the ESSP flag on the rf1cfh  and rf2cfh pulse */
    attenflagon(&rf1cfh, 0);  
    attenflagon(&rf2cfh, 0);
    if(presscfh_ctrl != PRESSCFH_NONE)
   {
        attenflagon(&rf3cfh, 0); /* for presscfh */
       if( presscfh_ctrl == PRESSCFH_SHIMVOL_SLICE )
       {
           attenflagon(&rf4cfh, 0);
       }
   }

    postemp = RUP_GRD(cfh_acq_window_pos + cfh_tdaq + pw_gykcfha);
     
    {
        pulsename(&cfh_attenkey,"cfh_attenkey");
        createatten(&cfh_attenkey, (long)(postemp));
    }

         

    setWaveformPurpose(gykcfha, gykcfh.purpose);
    setWaveformPurpose(gykcfhd, gykcfh.purpose);
    trapezoid((WF_PROCESSOR)wg_gykcfh, "gykcfh", &gykcfh, &gykcfha,
              &gykcfhd, pw_gykcfh, pw_gykcfha, pw_gykcfhd,
              ia_gykcfh, 0, 0, 0, 0, postemp-pw_gykcfha, TRAP_ALL,
              &cfhloggrd);


    /*  If the TE is so long that the readout and killer are pushed out beyond
        the default cfh_tr, cfh_tr must be increased.  Setting cfh_tr to the
        end of the killer + 10ms (time_ssi should never be more than 10ms) 
        should do the trick.   */

    newcfh_tr = RUP_GRD( (((pendall(&gykcfh,0)+10000)>cfh_tr) ? (pendall(&gykcfh,0)+10000) : cfh_tr) );

    if(PSdebugstate)	/* vmx 05/02/95 YO */
    {
	printf("CFH : TR = %d\n", newcfh_tr);
    }

      
  {
    pulsename(&seqcfh,"seqcfh");
    createseq(&seqcfh,newcfh_tr, off_seqcfh);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqcfh );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqcfh = %d\n", idx_seqcfh );
#endif
  }


      
  {
    pulsename(&seqcfhwait,"seqcfhwait");
    createseq(&seqcfhwait,wait_time_before_cfh, off_seqcfhwait);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqcfhwait );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqcfhwait = %d\n", idx_seqcfhwait );
#endif
  }


    return SUCCESS;
}


/*
 *  CoilSwitchPG
 *  
 *  Type: Private Function
 *  
 *  Description: Creates a ssp sequence which can set RF HUB index on
 *  RFHUBSEL. The sequence length needs to change depending upon
 *  setrcvportimm flag. If setrcvportimm needs to be called we need to
 *  provide additional time before starting to acquire as there is time
 *  delay in setting HW. So we add a wait pulse whos pulsewidth will be
 *  decided based on setrcvportimm flag. We also need a 'delay' sequence
 *  as explained in MRIhc14300.
 *  
 */
STATUS
CoilSwitchPG( void )
{
    INT PosContRFHubSel;

    /* SSP Packet for setting the hub index corresponding to the desired
     * coil configuration */
    short dcontrfhubsel[4] = {
        SSPDS,
        (short)(SSPOC | RFHUBSEL),
        SSPD,
        SSPDS
    };

    /* SSP Packet for changing receiver input */
    short dcontrfsel[4] = {     
        SSPDS,
        (short)(SSPOC | RRFSEL),
        (short)(SSPD | RFAUX),
        SSPDS
    };

    PosContRFHubSel = 15   + delay_rfhubsel;

    /* SSP sequence for changing RF Hub index for coil switch */
        
  {
    pulsename(&contrfhubsel,"contrfhubsel");
    createbits(&contrfhubsel,TYPSSP,sizeof(dcontrfhubsel)/2,dcontrfhubsel);
    createinstr( &contrfhubsel,(long)(PosContRFHubSel),
		pw_contrfhubsel,ia_contrfhubsel);
  }


    /* SSP Sequence for changing receiver input */
         
  {
    pulsename(&contrfsel,"contrfsel");
    createbits(&contrfsel,TYPSSP,sizeof(dcontrfsel)/2,dcontrfsel);
    createinstr( &contrfsel,(long)(pendallssp(&contrfhubsel,0)),
		pw_contrfsel,ia_contrfsel);
  }


    /* Insert a wait pulse to allow us to change the actual TR when
       a setrcvportimm() call is necessary */
        
  {
      if( TYPXGRAD == (WF_PROCESSOR)wg_csw_wait || TYPYGRAD == (WF_PROCESSOR)wg_csw_wait || TYPZGRAD == (WF_PROCESSOR)wg_csw_wait
          || TYPBXGRAD == (WF_PROCESSOR)wg_csw_wait || TYPBYGRAD == (WF_PROCESSOR)wg_csw_wait || TYPBZGRAD == (WF_PROCESSOR)wg_csw_wait )
      {
          setWaveformPurpose(csw_wait, WAIT_GRAD);
      }
      else if( TYPRHO1 == (WF_PROCESSOR)wg_csw_wait || TYPRHO2 == (WF_PROCESSOR)wg_csw_wait || TYPTHETA == (WF_PROCESSOR)wg_csw_wait
               || TYPBRHO1 == (WF_PROCESSOR)wg_csw_wait || TYPBRHO2 == (WF_PROCESSOR)wg_csw_wait || TYPBTHETA == (WF_PROCESSOR)wg_csw_wait
               || TYPOMEGA == (WF_PROCESSOR)wg_csw_wait || TYPBOMEGA == (WF_PROCESSOR)wg_csw_wait )
      {
          setWaveformPurpose(csw_wait, WAIT_RF);
      }
      else if( TYPSSP == (WF_PROCESSOR)wg_csw_wait || TYPBSSP == (WF_PROCESSOR)wg_csw_wait )
      {
          setWaveformPurpose(csw_wait, WAIT_SSP);
      }
    pulsename(&csw_wait,"csw_wait");
    createconst(&csw_wait,(WF_PROCESSOR)wg_csw_wait,pw_csw_wait,(short)0); 
    createinstr( &csw_wait,(long)(pendallssp(&contrfsel,0)),pw_csw_wait,0);
  }


    csw_tr = 15   + delay_rfhubsel + pw_contrfhubsel + pw_contrfsel
        + SSP_UPDATE_TIME + csw_time_ssi;

    if( csw_tr < 1000 ) {
        /* Switch time needs to be long enough for RF Hub to switch the coils.
           This is much less than 1ms. */
        csw_tr = RUP_GRD(1000);
    }
        
  {
    pulsename(&seqcsw,"seqcsw");
    createseq(&seqcsw,RUP_GRD(csw_tr-csw_time_ssi), off_seqcsw);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqcsw );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqcsw = %d\n", idx_seqcsw );
#endif
  }


    /* MRIhc14300: Short wait pulse before setrcvportimm to avoid race
       condition with SCP */
      
  {
    pulsename(&seqcswWaitBefore,"seqcswWaitBefore");
    createseq(&seqcswWaitBefore,RUP_GRD(csw_wait_before), off_seqcswWaitBefore);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqcswWaitBefore );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqcswWaitBefore = %d\n", idx_seqcswWaitBefore );
#endif
  }


    return SUCCESS;
}

/*
 *  PSpulsegen
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
PSpulsegen( void )
{
    INT posstart;

    /* MRIge82455 */
    psc_vol_index = 0;

    if(PSD_ON == local_tg)
    {
        posstart = RUP_GRD(IMax(2, pw_gyrf1mps1a, pw_gzrf1cfla) + 1000);
    }
    else
    {
        posstart = RUP_GRD(IMax(2, pw_gzrf1mps1a, pw_gzrf1cfla) + 1000);
    }

    /***********************************************************************
     * MPS1/APS1 SECTION
     ***********************************************************************/

    PS1pulsegen( posstart );

    /***********************************************************************
     * CFL SECTION
     ***********************************************************************/

    CFLpulsegen( posstart );

    /***********************************************************************
     * RCVN SECTION
     ***********************************************************************/

    /* GEHmr03545 */
    RCVNpulsegen( posstart );

    /***********************************************************************
     * CFH SECTION
     ***********************************************************************/

    CFHpulsegen( posstart );

    /***********************************************************************
     * CoilSwitch SECTION
     ***********************************************************************/

    CoilSwitchPG( );

    return SUCCESS;
}   /* end PSpulsegen() */


/*
 *  FTGpulsegen
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
FTGpulsegen( void )
{
    INT ftgl_tr = 2000000;
    INT PosGz1FTG;          /* Slice dephaser location   */
    INT PosReadoutWindow;   /* Readout window location   */
    INT PosReadoutWindow2;  /* Readout window location   */
    INT postemp;
    INT prescan_start;

    ftgl_tr = ftgtr;

    /* MRIge30645 */
    /* Need to change posstart to eliminate dwnld failures with .8 G/cm. */
    prescan_start = RUP_GRD(pw_gzrf1ftga + 1000);

    /* Z-axis slice selective with x readout gradient for 1-d projection
       after theta2 pulse; positioning of signals after theta3 pulse */

    /* Theta1 selective pulse */
         
                 
    {
        /* Check for RF waveform generator */
        RFEnvelopeWaveformGeneratorCheck("rf1ftg",
                                         (WF_PROCESSOR)wg_rf1ftg);

        /* Modify resolution if scaling required */
        temp_res_rf1ftg = res_rf1ftg;
        if (rfpulseInfo[RF1_FTG_SLOT].change==PSD_ON)
        {
            res_rf1ftg = rfpulseInfo[RF1_FTG_SLOT].newres;
        }
        /* First create the pulses */
        pulsename(&gzrf1ftga,"gzrf1ftga");
        setWaveformPurpose(gzrf1ftga, RF_SELECT_GRAD);
        pulsename(&gzrf1ftg,"gzrf1ftg");
        setWaveformPurpose(gzrf1ftg, RF_SELECT_GRAD);
        pulsename(&gzrf1ftgd,"gzrf1ftgd");
        setWaveformPurpose(gzrf1ftgd, RF_SELECT_GRAD);
        pulsename(&rf1ftg,"rf1ftg");

        /*  Now create the slice select trapezoid */
        pg_beta = ps1loggrd.zbeta;
        createramp(&gzrf1ftga,ZGRAD,pw_gzrf1ftga,(short)0,
                   MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrf1ftga/
                       GRAD_UPDATE_TIME)),pg_beta);
        createinstr( &gzrf1ftga,(LONG)(prescan_start-pw_gzrf1ftga),
                     pw_gzrf1ftga,ia_gzrf1ftg);
        createconst(&gzrf1ftg,ZGRAD,pw_gzrf1ftg,MAX_PG_WAMP);
        createinstr( &gzrf1ftg,(LONG)(prescan_start),
                     pw_gzrf1ftg,ia_gzrf1ftg);
        createramp(&gzrf1ftgd,ZGRAD,pw_gzrf1ftgd,MAX_PG_WAMP,
                   (short)0,(short)(maxGradRes*(pw_gzrf1ftgd/GRAD_UPDATE_TIME)),
                   pg_beta);
        createinstr( &gzrf1ftgd,(LONG)(prescan_start+pw_gzrf1ftg),
                     pw_gzrf1ftgd,ia_gzrf1ftg);

        /* Now create the rf pulse */
        createsinc(&rf1ftg,(WF_PROCESSOR)wg_rf1ftg,res_rf1ftg,
                   MAX_PG_WAMP,cyc_rf1ftg, alpha_rf1ftg);
        createinstr( &rf1ftg,(LONG)(prescan_start) + psd_rf_wait,
                     pw_rf1ftg,ia_rf1ftg);
        linkpulses(4,&rf1ftg,&gzrf1ftg,&gzrf1ftga,
                   &gzrf1ftgd);
        addrfbits(&rf1ftg,off_rf1ftg,(LONG)(prescan_start) + psd_rf_wait,
                  pw_rf1ftg);
        /* Changed back resolution incase external rf used later in pulsegen. We need
         * original resolution to scale pulses that are external
         */
        if (rfpulseInfo[RF1_FTG_SLOT].change==PSD_ON)
        {
            res_rf1ftg = temp_res_rf1ftg;
        }
    }


    /* Theta1 rephaser - split into two parts, 2nd part after rf2tg */
    /*                   is defined.                                */
    PosGz1FTG = pendall(&gzrf1ftg, 0) + pw_gz1ftga;

           

    setWaveformPurpose(gz1ftga, gz1ftg.purpose);
    setWaveformPurpose(gz1ftgd, gz1ftg.purpose);
    trapezoid((WF_PROCESSOR)wg_gz1ftg, "gz1ftg", &gz1ftg, &gz1ftga,
              &gz1ftgd, pw_gz1ftg, pw_gz1ftga, pw_gz1ftgd,
              ia_gz1ftg, 0, 0, 0, 0, PosGz1FTG-pw_gz1ftga, TRAP_ALL,
              &ps1loggrd);



    /* Theta2 selective pulse */
    postemp = (int) (pend(&rf1ftg,"gzrf1ftg",0)-pw_rf1ftg/2+FTGtau1-pw_rf2ftg/2);

       
                   
    {
        /* Check for RF waveform generator */
        RFEnvelopeWaveformGeneratorCheck("rf2ftg",
                                         (WF_PROCESSOR)wg_rf2ftg);

        /* Modify resolution if scaling required */
        temp_res_rf2ftg = res_rf2ftg;
        if (rfpulseInfo[RF2_FTG_SLOT].change==PSD_ON)
        {
            res_rf2ftg = rfpulseInfo[RF2_FTG_SLOT].newres;
        }
        /* First create the pulses */
        pulsename(&gzrf2ftga,"gzrf2ftga");
        setWaveformPurpose(gzrf2ftga, RF_SELECT_GRAD);
        pulsename(&gzrf2ftg,"gzrf2ftg");
        setWaveformPurpose(gzrf2ftg, RF_SELECT_GRAD);
        pulsename(&gzrf2ftgd,"gzrf2ftgd");
        setWaveformPurpose(gzrf2ftgd, RF_SELECT_GRAD);
        pulsename(&rf2ftg,"rf2ftg");

        /*  Now create the slice select trapezoid */
        pg_beta = ps1loggrd.zbeta;
        createramp(&gzrf2ftga,ZGRAD,pw_gzrf2ftga,(short)0,
                   MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrf2ftga/
                       GRAD_UPDATE_TIME)),pg_beta);
        createinstr( &gzrf2ftga,(LONG)(RUP_GRD(postemp)-pw_gzrf2ftga),
                     pw_gzrf2ftga,ia_gzrf2ftg);
        createconst(&gzrf2ftg,ZGRAD,pw_gzrf2ftg,MAX_PG_WAMP);
        createinstr( &gzrf2ftg,(LONG)(RUP_GRD(postemp)),
                     pw_gzrf2ftg,ia_gzrf2ftg);
        createramp(&gzrf2ftgd,ZGRAD,pw_gzrf2ftgd,MAX_PG_WAMP,
                   (short)0,(short)(maxGradRes*(pw_gzrf2ftgd/GRAD_UPDATE_TIME)),
                   pg_beta);
        createinstr( &gzrf2ftgd,(LONG)(RUP_GRD(postemp)+pw_gzrf2ftg),
                     pw_gzrf2ftgd,ia_gzrf2ftg);

        /* Now create the rf pulse */
        createsinc(&rf2ftg,(WF_PROCESSOR)wg_rf2ftg,res_rf2ftg,
                   MAX_PG_WAMP,cyc_rf2ftg, alpha_rf2ftg);
        createinstr( &rf2ftg,(LONG)(RUP_GRD(postemp)) + psd_rf_wait,
                     pw_rf2ftg,ia_rf2ftg);
        linkpulses(4,&rf2ftg,&gzrf2ftg,&gzrf2ftga,
                   &gzrf2ftgd);
        addrfbits(&rf2ftg,off_rf2ftg,(LONG)(RUP_GRD(postemp)) + psd_rf_wait,
                  pw_rf2ftg);
        /* Changed back resolution incase external rf used later in pulsegen. We need
         * original resolution to scale pulses that are external
         */
        if (rfpulseInfo[RF2_FTG_SLOT].change==PSD_ON)
        {
            res_rf2ftg = temp_res_rf2ftg;
        }
    }


    /* Theta2 rephaser - split into two parts: gz2tg and gz2btg (below) */
    PosGz1FTG = pendall(&gzrf2ftg, 0)+pw_gz2ftga;

           

    setWaveformPurpose(gz2ftga, gz2ftg.purpose);
    setWaveformPurpose(gz2ftgd, gz2ftg.purpose);
    trapezoid((WF_PROCESSOR)wg_gz2ftg, "gz2ftg", &gz2ftg, &gz2ftga,
              &gz2ftgd, pw_gz2ftg, pw_gz2ftga, pw_gz2ftgd,
              ia_gz2ftg, 0, 0, 0, 0, PosGz1FTG-pw_gz2ftga, TRAP_ALL,
              &ps1loggrd);



    /* Theta3 selective pulse */
    postemp = (int) (pend(&rf1ftg,"gzrf1ftg",0)-pw_rf1ftg/2+FTGtau2-pw_rf3ftg/2);

       
                   
    {
        /* Check for RF waveform generator */
        RFEnvelopeWaveformGeneratorCheck("rf3ftg",
                                         (WF_PROCESSOR)wg_rf3ftg);

        /* Modify resolution if scaling required */
        temp_res_rf3ftg = res_rf3ftg;
        if (rfpulseInfo[RF3_FTG_SLOT].change==PSD_ON)
        {
            res_rf3ftg = rfpulseInfo[RF3_FTG_SLOT].newres;
        }
        /* First create the pulses */
        pulsename(&gzrf3ftga,"gzrf3ftga");
        setWaveformPurpose(gzrf3ftga, RF_SELECT_GRAD);
        pulsename(&gzrf3ftg,"gzrf3ftg");
        setWaveformPurpose(gzrf3ftg, RF_SELECT_GRAD);
        pulsename(&gzrf3ftgd,"gzrf3ftgd");
        setWaveformPurpose(gzrf3ftgd, RF_SELECT_GRAD);
        pulsename(&rf3ftg,"rf3ftg");

        /*  Now create the slice select trapezoid */
        pg_beta = ps1loggrd.zbeta;
        createramp(&gzrf3ftga,ZGRAD,pw_gzrf3ftga,(short)0,
                   MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrf3ftga/
                       GRAD_UPDATE_TIME)),pg_beta);
        createinstr( &gzrf3ftga,(LONG)(RUP_GRD(postemp)-pw_gzrf3ftga),
                     pw_gzrf3ftga,ia_gzrf3ftg);
        createconst(&gzrf3ftg,ZGRAD,pw_gzrf3ftg,MAX_PG_WAMP);
        createinstr( &gzrf3ftg,(LONG)(RUP_GRD(postemp)),
                     pw_gzrf3ftg,ia_gzrf3ftg);
        createramp(&gzrf3ftgd,ZGRAD,pw_gzrf3ftgd,MAX_PG_WAMP,
                   (short)0,(short)(maxGradRes*(pw_gzrf3ftgd/GRAD_UPDATE_TIME)),
                   pg_beta);
        createinstr( &gzrf3ftgd,(LONG)(RUP_GRD(postemp)+pw_gzrf3ftg),
                     pw_gzrf3ftgd,ia_gzrf3ftg);

        /* Now create the rf pulse */
        createsinc(&rf3ftg,(WF_PROCESSOR)wg_rf3ftg,res_rf3ftg,
                   MAX_PG_WAMP,cyc_rf3ftg, alpha_rf3ftg);
        createinstr( &rf3ftg,(LONG)(RUP_GRD(postemp)) + psd_rf_wait,
                     pw_rf3ftg,ia_rf3ftg);
        linkpulses(4,&rf3ftg,&gzrf3ftg,&gzrf3ftga,
                   &gzrf3ftgd);
        addrfbits(&rf3ftg,off_rf3ftg,(LONG)(RUP_GRD(postemp)) + psd_rf_wait,
                  pw_rf3ftg);
        /* Changed back resolution incase external rf used later in pulsegen. We need
         * original resolution to scale pulses that are external
         */
        if (rfpulseInfo[RF3_FTG_SLOT].change==PSD_ON)
        {
            res_rf3ftg = temp_res_rf3ftg;
        }
    }


    /* Theta3 rephaser */
    PosGz1FTG = pendall(&gzrf3ftg, 0)+pw_gz3ftga;

           

    setWaveformPurpose(gz3ftga, gz3ftg.purpose);
    setWaveformPurpose(gz3ftgd, gz3ftg.purpose);
    trapezoid((WF_PROCESSOR)wg_gz3ftg, "gz3ftg", &gz3ftg, &gz3ftga,
              &gz3ftgd, pw_gz3ftg, pw_gz3ftga, pw_gz3ftgd,
              ia_gz3ftg, 0, 0, 0, 0, PosGz1FTG-pw_gz3ftga, TRAP_ALL,
              &ps1loggrd);


    /*----------------------------------------------------------*/
    /* Readout windows and dephasers                            */ 
    /*----------------------------------------------------------*/

    postemp = (int) (pbeg(&rf2ftg,"gzrf2ftga",0)-pw_gx1ftg-pw_gx1ftgd);

           

    setWaveformPurpose(gx1ftga, gx1ftg.purpose);
    setWaveformPurpose(gx1ftgd, gx1ftg.purpose);
    trapezoid((WF_PROCESSOR)wg_gx1ftg, "gx1ftg", &gx1ftg, &gx1ftga,
              &gx1ftgd, pw_gx1ftg, pw_gx1ftga, pw_gx1ftgd,
              ia_gx1ftg, 0, 0, 0, 0, RUP_GRD(postemp)-pw_gx1ftga, TRAP_ALL,
              &ps1loggrd);


    postemp = (int) (pendall(&gzrf2ftg,0) + pw_gx1bftga);

          

    setWaveformPurpose(gx1bftga, gx1bftg.purpose);
    setWaveformPurpose(gx1bftgd, gx1bftg.purpose);
    trapezoid((WF_PROCESSOR)wg_gx1bftg, "gx1bftg", &gx1bftg, &gx1bftga,
              &gx1bftgd, pw_gx1bftg, pw_gx1bftga, pw_gx1bftgd,
              ia_gx1bftg, 0, 0, 0, 0, RUP_GRD(postemp)-pw_gx1bftga, TRAP_ALL,
              &ps1loggrd);


    PosReadoutWindow=RUP_GRD((int)(pend(&rf1ftg,"gzrf1ftg",0) - pw_rf1ftg/2 + 2*FTGtau1 - pw_gxw1ftg/2));

    /* HD--Error Check For Gradient Overlapp. If gradients gx1bftg
     * and gxw1ftg overlap then shift the start of gxw1ftg after end of
     * gx1bftg 
     */
    if ( pendall(&gx1bftg,0) >= (PosReadoutWindow - pw_gxw1ftga)){
        PosReadoutWindow = pendall(&gx1bftg,0) + pw_gxw1ftga ;
    }

           

    setWaveformPurpose(gxw1ftga, gxw1ftg.purpose);
    setWaveformPurpose(gxw1ftgd, gxw1ftg.purpose);
    trapezoid((WF_PROCESSOR)wg_gxw1ftg, "gxw1ftg", &gxw1ftg, &gxw1ftga,
              &gxw1ftgd, pw_gxw1ftg, pw_gxw1ftga, pw_gxw1ftgd,
              ia_gxw1ftg, 0, 0, 0, 0, PosReadoutWindow-pw_gxw1ftga, TRAP_ALL,
              &ps1loggrd);


    PosReadoutWindow=RUP_GRD((int)(pend(&gxw1ftg,"gxw1ftgd",0))+pw_postgxw1ftga);

           

    setWaveformPurpose(postgxw1ftga, postgxw1ftg.purpose);
    setWaveformPurpose(postgxw1ftgd, postgxw1ftg.purpose);
    trapezoid((WF_PROCESSOR)wg_postgxw1ftg, "postgxw1ftg", &postgxw1ftg, &postgxw1ftga,
              &postgxw1ftgd, pw_postgxw1ftg, pw_postgxw1ftga, pw_postgxw1ftgd,
              ia_postgxw1ftg, 0, 0, 0, 0, PosReadoutWindow-pw_postgxw1ftga, TRAP_ALL,
              &ps1loggrd);


    PosReadoutWindow =  RUP_GRD((int)(pend(&gxw1ftg, "gxw1ftga", 0)));

         
    {
        pulsename(&echo1ftg,"echo1ftg");
        acqq(&echo1ftg, (long)(PosReadoutWindow+psd_grd_wait),(long)(DEFAULTPOS),
             (long)(DEFAULTPOS),(long)filter_echo1ftg,
             (TYPDAB_PACKETS)DABNORM);
    }


    /* Second part of theta2 rephaser */
    PosGz1FTG = pbegall(&rf3ftg, 0)-(pw_gz2bftg + pw_gz2bftgd + pw_gzrf3ftga);

          

    setWaveformPurpose(gz2bftga, gz2bftg.purpose);
    setWaveformPurpose(gz2bftgd, gz2bftg.purpose);
    trapezoid((WF_PROCESSOR)wg_gz2bftg, "gz2bftg", &gz2bftg, &gz2bftga,
              &gz2bftgd, pw_gz2bftg, pw_gz2bftga, pw_gz2bftgd,
              ia_gz2bftg, 0, 0, 0, 0, PosGz1FTG-pw_gz2bftga, TRAP_ALL,
              &ps1loggrd);


    /* Another refocusing pulse to insure S1 forms tau1 ms after
       center of rf3.  This is the time at which we want to
       the S1 signal to refocus:  */
    PosReadoutWindow =  RUP_GRD((int)(pendall(&rf3ftg, 0) + pw_gx2ftga));

          

    setWaveformPurpose(gx2ftga, gx2ftg.purpose);
    setWaveformPurpose(gx2ftgd, gx2ftg.purpose);
    trapezoid((WF_PROCESSOR)wg_gx2ftg, "gx2ftg", &gx2ftg, &gx2ftga,
              &gx2ftgd, pw_gx2ftg, pw_gx2ftga, pw_gx2ftgd,
              ia_gx2ftg, 0, 0, 0, 0, PosReadoutWindow-pw_gx2ftga, TRAP_ALL,
              &ps1loggrd);


    /* Second readout window */
    PosReadoutWindow2 = RUP_GRD((int)(pmidall(&rf3ftg, 0) + FTGtau1 - pw_gxw2ftgleft));

    /* HD--Error Check For Gradient Overlapp. If gradients gx2ftg and
     * gxw2ftg overlap then shift the start of gxw2ftg after end of
     * gx2ftg 
     */
    if ( pendall(&gx2ftg,0) >= (PosReadoutWindow2 - pw_gxw2ftga)){
        PosReadoutWindow2 = pendall(&gx2ftg,0) + pw_gxw2ftga ;
    }

           

    setWaveformPurpose(gxw2ftga, gxw2ftg.purpose);
    setWaveformPurpose(gxw2ftgd, gxw2ftg.purpose);
    trapezoid((WF_PROCESSOR)wg_gxw2ftg, "gxw2ftg", &gxw2ftg, &gxw2ftga,
              &gxw2ftgd, pw_gxw2ftg, pw_gxw2ftga, pw_gxw2ftgd,
              ia_gxw2ftg, 0, 0, 0, 0, PosReadoutWindow2-pw_gxw2ftga, TRAP_ALL,
              &ps1loggrd);


    if (FTGtestpulse == 1)
    {
        PosReadoutWindow =  RUP_GRD((int)(pbegall(&rf3ftg, 0)+pw_gx2test + pw_gx2testd));
              

    setWaveformPurpose(gx2testa, gx2test.purpose);
    setWaveformPurpose(gx2testd, gx2test.purpose);
    trapezoid((WF_PROCESSOR)wg_gx2test, "gx2test", &gx2test, &gx2testa,
              &gx2testd, pw_gx2test, pw_gx2testa, pw_gx2testd,
              ia_gx2test, 0, 0, 0, 0, PosReadoutWindow-pw_gx2testa, TRAP_ALL,
              &ps1loggrd);

    }    

    PosReadoutWindow =  RUP_GRD((int)(pend(&gxw2ftg, "gxw2ftga", 0)));

        
    {
        pulsename(&echo2ftg,"echo2ftg");
        acqq(&echo2ftg, (long)(PosReadoutWindow+psd_grd_wait),(long)(DEFAULTPOS),
             (long)(DEFAULTPOS),(long)filter_echo2ftg,
             (TYPDAB_PACKETS)DABNORM);
    }


         
    {
        pulsename(&ftg_attenkey,"ftg_attenkey");
        createatten(&ftg_attenkey, (long)(RUP_GRD(pbegall(&gxw2ftg,0)+1000+pw_gxw2ftg)));
    }


      
  {
    pulsename(&seqftg,"seqftg");
    createseq(&seqftg,ftgl_tr, off_seqftg);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqftg );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqftg = %d\n", idx_seqftg );
#endif
  }


    return SUCCESS;
}   /* end FTGpulsegen() */


/*
 *  XTGpulsegen
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
XTGpulsegen( void )
{
    INT xtgl_tr = 2000000;
    INT PosGyKXTG;          /* Y Killer pulse location          */
    INT PosOffResXTG;       /* Off resonance pulse location     */
    INT PosGzDephaserXTG;   /* Slice dephaser location          */
    INT PosGzRephaserXTG;   /* Slice rephaser location          */
    INT PosReadoutWindow;   /* Readout window location          */
    INT postemp;
    INT prescan_start;

    xtgl_tr = RUP_GRD(xtgtr);

    /* MRIge30645 */
    /* Need to change posstart to eliminate dwnld failures with .8 G/cm. */
    if(PSD_ON == local_tg)
    {
        prescan_start = RUP_GRD(pw_gyrf1xtga + 1000);
    }
    else
    {
        prescan_start = RUP_GRD(pw_gzrf1xtga + 1000);
    }

    /* rf1xtg Theta1 selective pulse */
         
  {
    pulsename(&rf1xtg,"rf1xtg");
    createsinc(&rf1xtg,(WF_PROCESSOR)wg_rf1xtg,res_rf1xtg,
               MAX_PG_WAMP,cyc_rf1xtg,alpha_rf1xtg);
    if ((wg_rf1xtg==TYPRHO1)||(wg_rf1xtg==TYPRHO2) ||
        (wg_rf1xtg==TYPTHETA)||(wg_rf1xtg==TYPOMEGA))
      {
        createinstr( &rf1xtg,(long)(prescan_start) + psd_rf_wait,
                    pw_rf1xtg,ia_rf1xtg);
        addrfbits(&rf1xtg,off_rf1xtg,(long)(prescan_start) + psd_rf_wait,
                  pw_rf1xtg);
      }
    else
      {
        createinstr( &rf1xtg,(long)(prescan_start),
                    pw_rf1xtg,ia_rf1xtg);
      }
  }

    if(PSD_ON == local_tg)
    {
            
                    

    setWaveformPurpose(gyrf1xtga, gyrf1xtg.purpose);
    setWaveformPurpose(gyrf1xtgd, gyrf1xtg.purpose);
    trapezoid((WF_PROCESSOR)wg_gyrf1xtg, "gyrf1xtg", &gyrf1xtg, &gyrf1xtga,
              &gyrf1xtgd, pw_gyrf1xtg, pw_gyrf1xtga, pw_gyrf1xtgd,
              ia_gyrf1xtg, 0, 0, 0, 0, pbegall(&rf1xtg,0)-psd_rf_wait-pw_gyrf1xtga, TRAP_ALL,
              &ps1loggrd);
  /* same axis as ykiller */
    }
    else
    {
            
                    

    setWaveformPurpose(gzrf1xtga, gzrf1xtg.purpose);
    setWaveformPurpose(gzrf1xtgd, gzrf1xtg.purpose);
    trapezoid((WF_PROCESSOR)wg_gzrf1xtg, "gzrf1xtg", &gzrf1xtg, &gzrf1xtga,
              &gzrf1xtgd, pw_gzrf1xtg, pw_gzrf1xtga, pw_gzrf1xtgd,
              ia_gzrf1xtg, 0, 0, 0, 0, pbegall(&rf1xtg,0)-psd_rf_wait-pw_gzrf1xtga, TRAP_ALL,
              &ps1loggrd);

    }

    /* Set timing for YKillerL */
    if ( XTG_minimizeYKillerGap == PSD_ON )
    {
        /* Apply YKillerL at same time as ZDephaser */
        PosGyKXTG = RUP_GRD(pend(&rf1xtg,"rf1xtg",0) - pw_rf1xtg/2 + XTGtau1 -
                            pw_rf2xtg/2 - IMax(2, pw_gykxtgla+pw_gykxtgl+pw_gykxtgld,
                            pw_gz1xtga+pw_gz1xtg+pw_gz1xtgd + pw_gzrf2xtga) + pw_gykxtgla);
    }
    else
    {
        /* Apply YKillerL after RF1 */
        if(PSD_ON == local_tg)
        {
            /* RF1 + GyRF1d + YKillerLa */
            PosGyKXTG = RUP_GRD(pend(&rf1xtg,"rf1xtg",0) + pw_gyrf1xtgd + pw_gykxtgla);
        }
        else
        {
            /* RF1 + YKillerLa */
            PosGyKXTG = RUP_GRD(pend(&rf1xtg,"rf1xtg",0) + pw_gykxtgla);
        }
    }
    /* Create YKillerL */
           

    setWaveformPurpose(gykxtgla, gykxtgl.purpose);
    setWaveformPurpose(gykxtgld, gykxtgl.purpose);
    trapezoid((WF_PROCESSOR)wg_gykxtgl, "gykxtgl", &gykxtgl, &gykxtgla,
              &gykxtgld, pw_gykxtgl, pw_gykxtgla, pw_gykxtgld,
              ia_gykxtgl, 0, 0, 0, 0, PosGyKXTG-pw_gykxtgla, TRAP_ALL,
              &ps1loggrd);


    /* Set timing for FermiL, accounting for min_ssp */
    if ( XTG_minimizeYKillerGap == PSD_ON )
    {
        /* Apply FermiL after RF1 */
        if(PSD_ON == local_tg)
        {
            /* RF1 + GyRF1d */
            PosOffResXTG = RUP_GRD(pend(&rf1xtg,"rf1xtg",0) + IMax(2, min_ssp, pw_gyrf1xtgd));
        }
        else
        {
            /* RF1 + GzRF1d */
            PosOffResXTG = RUP_GRD(pend(&rf1xtg,"rf1xtg",0) + IMax(2, min_ssp, pw_gzrf1xtgd));
        }
    }
    else
    {
        /* Apply FermiL after YKillerL */
        PosOffResXTG = RUP_GRD(IMax(2, pend(&rf1xtg,"rf1xtg",0) + min_ssp, pendall(&gykxtgl,0)));
    }
    /* Create FermiL */
       
   {

       EXTERN_FILENAME ext_filename;

       /* Check for RF waveform generator */
       RFEnvelopeWaveformGeneratorCheck("rf3xtg", 
                                        (WF_PROCESSOR)wg_rf3xtg);

       pulsename(&rf3xtg,"rf3xtg");
       pulsename(&phs_rf3xtg,"phs_rf3xtg");
       sprintf(ext_filename,"bls.rho");

       createextwave( &rf3xtg, (WF_PROCESSOR)wg_rf3xtg, res_rf3xtg, ext_filename);
       createinstr( &rf3xtg,(long)(PosOffResXTG) + psd_rf_wait, pw_rf3xtg,ia_rf3xtg);

       createconst( &phs_rf3xtg,THETA,pw_rf3xtg,MAX_PG_WAMP);
       createinstr( &phs_rf3xtg,(long)(PosOffResXTG) + psd_rf_wait, pw_rf3xtg,ia_phs_rf3xtg);


       addrfbits(&rf3xtg,off_rf3xtg,(long)(PosOffResXTG) + 
                 psd_rf_wait, pw_rf3xtg);
   }


    /* theta1 Slice Dephaser */
    /* Note that Slice Dephaser/Rephaser pair is implemented in two parts:
     * 1) Theta1 dephaser before rf2xtg, and 2) Theta2 rephaser after rf2xtg */
    PosGzDephaserXTG = RUP_GRD(pend(&rf1xtg,"rf1xtg",0) - pw_rf1xtg/2 + XTGtau1 -
                               pw_rf2xtg/2 - pw_gzrf2xtga - pw_gz1xtgd - pw_gz1xtg);
           

    setWaveformPurpose(gz1xtga, gz1xtg.purpose);
    setWaveformPurpose(gz1xtgd, gz1xtg.purpose);
    trapezoid((WF_PROCESSOR)wg_gz1xtg, "gz1xtg", &gz1xtg, &gz1xtga,
              &gz1xtgd, pw_gz1xtg, pw_gz1xtga, pw_gz1xtgd,
              ia_gz1xtg, 0, 0, 0, 0, PosGzDephaserXTG-pw_gz1xtga, TRAP_ALL,
              &ps1loggrd);


    /* rf2xtg Theta2 selective pulse */
    postemp = (int) (pend(&rf1xtg,"rf1xtg",0) - pw_rf1xtg/2 + XTGtau1 - pw_rf2xtg/2);
       
                   
    {
        /* Check for RF waveform generator */
        RFEnvelopeWaveformGeneratorCheck("rf2xtg",
                                         (WF_PROCESSOR)wg_rf2xtg);

        /* Modify resolution if scaling required */
        temp_res_rf2xtg = res_rf2xtg;
        if (rfpulseInfo[RF2_XTG_SLOT].change==PSD_ON)
        {
            res_rf2xtg = rfpulseInfo[RF2_XTG_SLOT].newres;
        }
        /* First create the pulses */
        pulsename(&gzrf2xtga,"gzrf2xtga");
        setWaveformPurpose(gzrf2xtga, RF_SELECT_GRAD);
        pulsename(&gzrf2xtg,"gzrf2xtg");
        setWaveformPurpose(gzrf2xtg, RF_SELECT_GRAD);
        pulsename(&gzrf2xtgd,"gzrf2xtgd");
        setWaveformPurpose(gzrf2xtgd, RF_SELECT_GRAD);
        pulsename(&rf2xtg,"rf2xtg");

        /*  Now create the slice select trapezoid */
        pg_beta = ps1loggrd.zbeta;
        createramp(&gzrf2xtga,ZGRAD,pw_gzrf2xtga,(short)0,
                   MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrf2xtga/
                       GRAD_UPDATE_TIME)),pg_beta);
        createinstr( &gzrf2xtga,(LONG)(RUP_GRD(postemp)-pw_gzrf2xtga),
                     pw_gzrf2xtga,ia_gzrf2xtg);
        createconst(&gzrf2xtg,ZGRAD,pw_gzrf2xtg,MAX_PG_WAMP);
        createinstr( &gzrf2xtg,(LONG)(RUP_GRD(postemp)),
                     pw_gzrf2xtg,ia_gzrf2xtg);
        createramp(&gzrf2xtgd,ZGRAD,pw_gzrf2xtgd,MAX_PG_WAMP,
                   (short)0,(short)(maxGradRes*(pw_gzrf2xtgd/GRAD_UPDATE_TIME)),
                   pg_beta);
        createinstr( &gzrf2xtgd,(LONG)(RUP_GRD(postemp)+pw_gzrf2xtg),
                     pw_gzrf2xtgd,ia_gzrf2xtg);

        /* Now create the rf pulse */
        createsinc(&rf2xtg,(WF_PROCESSOR)wg_rf2xtg,res_rf2xtg,
                   MAX_PG_WAMP,cyc_rf2xtg, alpha_rf2xtg);
        createinstr( &rf2xtg,(LONG)(RUP_GRD(postemp)) + psd_rf_wait,
                     pw_rf2xtg,ia_rf2xtg);
        linkpulses(4,&rf2xtg,&gzrf2xtg,&gzrf2xtga,
                   &gzrf2xtgd);
        addrfbits(&rf2xtg,off_rf2xtg,(LONG)(RUP_GRD(postemp)) + psd_rf_wait,
                  pw_rf2xtg);
        /* Changed back resolution incase external rf used later in pulsegen. We need
         * original resolution to scale pulses that are external
         */
        if (rfpulseInfo[RF2_XTG_SLOT].change==PSD_ON)
        {
            res_rf2xtg = temp_res_rf2xtg;
        }
    }


    /* theta2 Slice Rephaser */ 
    /* Note that Slice Dephaser/Rephaser pair is implemented in two parts:
     * 1) Theta1 dephaser before rf2xtg, and 2) Theta2 rephaser after rf2xtg */
    PosGzRephaserXTG = pendall(&gzrf2xtg, 0) + pw_gz2xtga;
           

    setWaveformPurpose(gz2xtga, gz2xtg.purpose);
    setWaveformPurpose(gz2xtgd, gz2xtg.purpose);
    trapezoid((WF_PROCESSOR)wg_gz2xtg, "gz2xtg", &gz2xtg, &gz2xtga,
              &gz2xtgd, pw_gz2xtg, pw_gz2xtga, pw_gz2xtgd,
              ia_gz2xtg, 0, 0, 0, 0, PosGzRephaserXTG-pw_gz2xtga, TRAP_ALL,
              &ps1loggrd);


    /* Set timing for FermiR, account for min_ssp */
    if ( XTG_minimizeYKillerGap == PSD_ON )
    {
        /* Apply FermiR after both ZRephaser and YKillerR */
        PosOffResXTG = RUP_GRD(pendall(&gzrf2xtg,0) - pw_gzrf2xtgd +
                               IMax(2, min_ssp, IMax(2, pw_gzrf2xtgd + pw_gz2xtga+pw_gz2xtg+pw_gz2xtgd,
                                                     pw_gykxtgra+pw_gykxtgr+pw_gykxtgrd)));
    }
    else
    {
        /* Apply FermiR after ZRephaser */
        PosOffResXTG = RUP_GRD(IMax(2, pend(&rf2xtg,"rf2xtg",0) + min_ssp, pendall(&gz2xtg,0)));
    }
    /* Create FermiR */
       
   {

       EXTERN_FILENAME ext_filename;

       /* Check for RF waveform generator */
       RFEnvelopeWaveformGeneratorCheck("rf4xtg", 
                                        (WF_PROCESSOR)wg_rf4xtg);

       pulsename(&rf4xtg,"rf4xtg");
       pulsename(&phs_rf4xtg,"phs_rf4xtg");
       sprintf(ext_filename,"bls.rho");

       createextwave( &rf4xtg, (WF_PROCESSOR)wg_rf4xtg, res_rf4xtg, ext_filename);
       createinstr( &rf4xtg,(long)(PosOffResXTG) + psd_rf_wait, pw_rf4xtg,ia_rf4xtg);

       createconst( &phs_rf4xtg,THETA,pw_rf4xtg,MAX_PG_WAMP);
       createinstr( &phs_rf4xtg,(long)(PosOffResXTG) + psd_rf_wait, pw_rf4xtg,ia_phs_rf4xtg);


       addrfbits(&rf4xtg,off_rf4xtg,(long)(PosOffResXTG) + 
                 psd_rf_wait, pw_rf4xtg);
   }


    /* Set timing for YKillerR */
    if ( XTG_minimizeYKillerGap == PSD_ON )
    {
        /* Apply YKillerR after GzRF2 */
        PosGyKXTG = pendall(&gzrf2xtg,0) + pw_gykxtgra;
    }
    else
    {
        /* Apply YKillerR after FermiR */
        PosGyKXTG = RUP_GRD(pendall(&rf4xtg,0) + pw_gykxtgra);
    }
    /* Create YKillerR */
         

    setWaveformPurpose(gykxtgra, gykxtgr.purpose);
    setWaveformPurpose(gykxtgrd, gykxtgr.purpose);
    trapezoid((WF_PROCESSOR)wg_gykxtgr, "gykxtgr", &gykxtgr, &gykxtgra,
              &gykxtgrd, pw_gykxtgr, pw_gykxtgra, pw_gykxtgrd,
              ia_gykxtgr, 0, 0, 0, 0, PosGyKXTG-pw_gykxtgra, TRAP_ALL,
              &ps1loggrd);


    /* X Readout dephaser */
    postemp = RUP_GRD(pendall(&rf2xtg,0) - pw_rf2xtg/2 + XTGtau1 - 
                      pw_gxw1xtg/2-pw_gxw1xtga - pw_gx1bxtgd - pw_gx1bxtg);
          

    setWaveformPurpose(gx1bxtga, gx1bxtg.purpose);
    setWaveformPurpose(gx1bxtgd, gx1bxtg.purpose);
    trapezoid((WF_PROCESSOR)wg_gx1bxtg, "gx1bxtg", &gx1bxtg, &gx1bxtga,
              &gx1bxtgd, pw_gx1bxtg, pw_gx1bxtga, pw_gx1bxtgd,
              ia_gx1bxtg, 0, 0, 0, 0, RUP_GRD(postemp)-pw_gx1bxtga, TRAP_ALL,
              &ps1loggrd);


    /* X Readout window */
    PosReadoutWindow=RUP_GRD((int)(pend(&rf1xtg,"rf1xtg",0) - pw_rf1xtg/2 +
                                   2*XTGtau1 - pw_gxw1xtg/2));
    /* HD--Error Check For Gradient Overlap. If gradients gx1bftg
     * and gxw1ftg overlap then shift the start of gxw1ftg after end of
     * gx1bftg
     */
    if ( pendall(&gx1bxtg,0) >= (PosReadoutWindow - pw_gxw1xtga))
    {
        PosReadoutWindow = pendall(&gx1bxtg,0) + pw_gxw1xtga ;
    }
           

    setWaveformPurpose(gxw1xtga, gxw1xtg.purpose);
    setWaveformPurpose(gxw1xtgd, gxw1xtg.purpose);
    trapezoid((WF_PROCESSOR)wg_gxw1xtg, "gxw1xtg", &gxw1xtg, &gxw1xtga,
              &gxw1xtgd, pw_gxw1xtg, pw_gxw1xtga, pw_gxw1xtgd,
              ia_gxw1xtg, 0, 0, 0, 0, PosReadoutWindow-pw_gxw1xtga, TRAP_ALL,
              &ps1loggrd);

    PosReadoutWindow =  RUP_GRD((int)(pend(&gxw1xtg, "gxw1xtga", 0))); /* Update PosReadoutWindow to final value */
         
    {
        pulsename(&echo1xtg,"echo1xtg");
        acqq(&echo1xtg, (long)(PosReadoutWindow+psd_grd_wait),(long)(DEFAULTPOS),
             (long)(DEFAULTPOS),(long)filter_echo1xtg,
             (TYPDAB_PACKETS)DABNORM);
    }


    /* position for ATTENUATOR */
    postemp = RUP_GRD(pbegall(&gxw1xtg,0) + 1000 + pw_gxw1xtg);
     
    {
        pulsename(&xtg_attenkey,"xtg_attenkey");
        createatten(&xtg_attenkey, (long)(postemp));
    }


      
  {
    pulsename(&seqxtg,"seqxtg");
    createseq(&seqxtg,xtgl_tr, off_seqxtg);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqxtg );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqxtg = %d\n", idx_seqxtg );
#endif
  }


    getperiod( (long*)&init_xtg_deadtime, &seqxtg, 0 );

    return SUCCESS;
}   /* end XTGpulsegen() */


/*
 *  ASpulsegen
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
ASpulsegen( void )
{
    INT PosTemp;

    /***************************************
     * Z board
     ***************************************/
    /* Z gradient slice select */
    PosTemp = RUP_GRD(td0as + tleadas - rfupa + pw_gzrf1asa);
          
                   
    {
        /* Check for RF waveform generator */
        RFEnvelopeWaveformGeneratorCheck("rf1as",
                                         (WF_PROCESSOR)wg_rf1as);

        /* Modify resolution if scaling required */
        temp_res_rf1as = res_rf1as;
        if (rfpulseInfo[RF1_AUTOSHIM].change==PSD_ON)
        {
            res_rf1as = rfpulseInfo[RF1_AUTOSHIM].newres;
        }
        /* First create the pulses */
        pulsename(&gzrf1asa,"gzrf1asa");
        setWaveformPurpose(gzrf1asa, RF_SELECT_GRAD);
        pulsename(&gzrf1as,"gzrf1as");
        setWaveformPurpose(gzrf1as, RF_SELECT_GRAD);
        pulsename(&gzrf1asd,"gzrf1asd");
        setWaveformPurpose(gzrf1asd, RF_SELECT_GRAD);
        pulsename(&rf1as,"rf1as");

        /*  Now create the slice select trapezoid */
        pg_beta = asloggrd.zbeta;
        createramp(&gzrf1asa,ZGRAD,pw_gzrf1asa,(short)0,
                   MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrf1asa/
                       GRAD_UPDATE_TIME)),pg_beta);
        createinstr( &gzrf1asa,(LONG)(PosTemp-pw_gzrf1asa),
                     pw_gzrf1asa,ia_gzrf1as);
        createconst(&gzrf1as,ZGRAD,pw_gzrf1as,MAX_PG_WAMP);
        createinstr( &gzrf1as,(LONG)(PosTemp),
                     pw_gzrf1as,ia_gzrf1as);
        createramp(&gzrf1asd,ZGRAD,pw_gzrf1asd,MAX_PG_WAMP,
                   (short)0,(short)(maxGradRes*(pw_gzrf1asd/GRAD_UPDATE_TIME)),
                   pg_beta);
        createinstr( &gzrf1asd,(LONG)(PosTemp+pw_gzrf1as),
                     pw_gzrf1asd,ia_gzrf1as);

        /* Now create the rf pulse */
        createsinc(&rf1as,(WF_PROCESSOR)wg_rf1as,res_rf1as,
                   MAX_PG_WAMP,cyc_rf1as, alpha_rf1as);
        createinstr( &rf1as,(LONG)(PosTemp) + psd_rf_wait,
                     pw_rf1as,ia_rf1as);
        linkpulses(4,&rf1as,&gzrf1as,&gzrf1asa,
                   &gzrf1asd);
        addrfbits(&rf1as,off_rf1as,(LONG)(PosTemp) + psd_rf_wait,
                  pw_rf1as);
        /* Changed back resolution incase external rf used later in pulsegen. We need
         * original resolution to scale pulses that are external
         */
        if (rfpulseInfo[RF1_AUTOSHIM].change==PSD_ON)
        {
            res_rf1as = temp_res_rf1as;
        }
    }
 

    /* Assert the ESSP flag on the rf1as pulse */
    attenflagon(&rf1as, 0);

    /* Z gradient rephaser */
    PosTemp = pendall(&gzrf1as, 0) + pw_gz1asa;
          
                

    setWaveformPurpose(gz1asa, gz1as.purpose);
    setWaveformPurpose(gz1asd, gz1as.purpose);
    trapezoid((WF_PROCESSOR)wg_gz1as, "gz1as", &gz1as, &gz1asa,
              &gz1asd, pw_gz1as, pw_gz1asa, pw_gz1asd,
              ia_gz1as, 0, 0, 0, 0, pendall(&gzrf1as,0)+pw_gz1asa-pw_gz1asa, TRAP_ALL,
              &asloggrd);


    /***************************************
     * X board
     ***************************************/
    PosTemp = RUP_GRD(pmid(&gzrf1as,"gzrf1as",0)-off90as+te_as-pw_gxwas/2);
           

    setWaveformPurpose(gxwasa, gxwas.purpose);
    setWaveformPurpose(gxwasd, gxwas.purpose);
    trapezoid((WF_PROCESSOR)wg_gxwas, "gxwas", &gxwas, &gxwasa,
              &gxwasd, pw_gxwas, pw_gxwasa, pw_gxwasd,
              ia_gxwas, 0, 0, 0, 0, PosTemp-pw_gxwasa, TRAP_ALL,
              &asloggrd);


    PosTemp = RUP_GRD(PosTemp+psd_grd_wait);
        
    {
        pulsename(&echo1as,"echo1as");
        acqq(&echo1as, (long)(PosTemp),(long)(DEFAULTPOS),
             (long)(DEFAULTPOS),(long)filter_echo1as,
             (TYPDAB_PACKETS)DABNORM);
    }

    attenflagon(&echo1as,0);

    /* frequency dephaser */
    PosTemp = RUP_GRD(pbegall(&gxwas,0) - (pw_gx1as+pw_gx1asd));
           

    setWaveformPurpose(gx1asa, gx1as.purpose);
    setWaveformPurpose(gx1asd, gx1as.purpose);
    trapezoid((WF_PROCESSOR)wg_gx1as, "gx1as", &gx1as, &gx1asa,
              &gx1asd, pw_gx1as, pw_gx1asa, pw_gx1asd,
              ia_gx1as, 0, 0, 0, 0, PosTemp-pw_gx1asa, TRAP_ALL,
              &asloggrd);


    /*****************************************
     * Attenuator lock
     *****************************************/
    PosTemp = RUP_GRD( pend(&gxwas, "gxwas",0) );
     
    {
        pulsename(&attenuator_keyas,"attenuator_keyas");
        createatten(&attenuator_keyas, (long)(PosTemp));
    }


    /*****************************************
     * Y board
     *****************************************/
    /* HSI - changed SINUSOID to TRAPEZOID2 */
    /* encode */
    PosTemp = RUP_GRD(pend(&gz1asd,"gz1asd",0));
           
    setWaveformPurpose(gy1asa, gy1as.purpose);
    setWaveformPurpose(gy1asd, gy1as.purpose);
    trapezoid((WF_PROCESSOR)wg_gy1as,"gy1as",
              &gy1as,&gy1asa,&gy1asd,
              pw_gy1as,pw_gy1asa,pw_gy1asd,
              ia_gy1as,ia_gy1aswa,ia_gy1aswb,
              0,0,PosTemp,TRAP_ALL_SLOPED,
                          &asloggrd);


    /* rewind */
    PosTemp= RUP_GRD(pend(&gxwas,"gxwas",0));
           
    setWaveformPurpose(gy1rasa, gy1ras.purpose);
    setWaveformPurpose(gy1rasd, gy1ras.purpose);
    trapezoid((WF_PROCESSOR)wg_gy1ras,"gy1ras",
              &gy1ras,&gy1rasa,&gy1rasd,
              pw_gy1ras,pw_gy1rasa,pw_gy1rasd,
              ia_gy1ras,ia_gy1raswa,ia_gy1raswb,
              0,0,PosTemp,TRAP_ALL_SLOPED,
                          &asloggrd);



    /*******************
     * X and Z Killers
     *******************/
    PosTemp= RUP_GRD(pend(&gxwasd,"gxwasd",0) + pw_gxkasa);
         

    setWaveformPurpose(gxkasa, gxkas.purpose);
    setWaveformPurpose(gxkasd, gxkas.purpose);
    trapezoid((WF_PROCESSOR)wg_gxkas, "gxkas", &gxkas, &gxkasa,
              &gxkasd, pw_gxkas, pw_gxkasa, pw_gxkasd,
              ia_gxkas, 0, 0, 0, 0, PosTemp-pw_gxkasa, TRAP_ALL,
              &asloggrd);


    PosTemp= RUP_GRD(pend(&gxwasd,"gxwasd",0) + pw_gzkasa);
         

    setWaveformPurpose(gzkasa, gzkas.purpose);
    setWaveformPurpose(gzkasd, gzkas.purpose);
    trapezoid((WF_PROCESSOR)wg_gzkas, "gzkas", &gzkas, &gzkasa,
              &gzkasd, pw_gzkas, pw_gzkasa, pw_gzkasd,
              ia_gzkas, 0, 0, 0, 0, PosTemp-pw_gzkasa, TRAP_ALL,
              &asloggrd);


    /**************
     * dixon shifts
     **************/
    PosTemp = RUP_GRD(td0as + tleadas - rfupa);
         
  {
    pulsename(&xdixon,"xdixon");
    createconst(&xdixon,(WF_PROCESSOR)wg_xdixon,
                pw_xdixon,MAX_PG_WAMP);
    createinstr( &xdixon,(long)(PosTemp),
		pw_xdixon,ia_xdixon);
    if ((wg_xdixon==TYPRHO1)||(wg_xdixon==TYPRHO2))
      {
	addrfbits(&xdixon,0,(long)(PosTemp),pw_xdixon);
      }
  }

         
  {
    pulsename(&ydixon,"ydixon");
    createconst(&ydixon,(WF_PROCESSOR)wg_ydixon,
                pw_ydixon,MAX_PG_WAMP);
    createinstr( &ydixon,(long)(PosTemp),
		pw_ydixon,ia_ydixon);
    if ((wg_ydixon==TYPRHO1)||(wg_ydixon==TYPRHO2))
      {
	addrfbits(&ydixon,0,(long)(PosTemp),pw_ydixon);
      }
  }


    PosTemp = pend(&gz1asd,"gz1asd",0);
         
  {
    pulsename(&zdixon,"zdixon");
    createconst(&zdixon,(WF_PROCESSOR)wg_zdixon,
                pw_zdixon,MAX_PG_WAMP);
    createinstr( &zdixon,(long)(PosTemp),
		pw_zdixon,ia_zdixon);
    if ((wg_zdixon==TYPRHO1)||(wg_zdixon==TYPRHO2))
      {
	addrfbits(&zdixon,0,(long)(PosTemp),pw_zdixon);
      }
  }


    /* just pad the ssp somewhere beyond the rf unblank */
    disableRfSspControl();
    PosTemp = RUP_RF(pend(&rf1as,"rf1as",0) + rfupd + 12);
         
  {
    pulsename(&sdixon,"sdixon");
    createconst(&sdixon,(WF_PROCESSOR)wg_sdixon,
                pw_sdixon,MAX_PG_WAMP);
    createinstr( &sdixon,(long)(PosTemp),
		pw_sdixon,ia_sdixon);
    if ((wg_sdixon==TYPRHO1)||(wg_sdixon==TYPRHO2))
      {
	addrfbits(&sdixon,0,(long)(PosTemp),pw_sdixon);
      }
  }


    PosTemp = RUP_RF(pbeg(&gzkas,"gzkas",0));
         
  {
    pulsename(&sdixon2,"sdixon2");
    createconst(&sdixon2,(WF_PROCESSOR)wg_sdixon2,
                pw_sdixon2,MAX_PG_WAMP);
    createinstr( &sdixon2,(long)(PosTemp),
		pw_sdixon2,ia_sdixon2);
    if ((wg_sdixon2==TYPRHO1)||(wg_sdixon2==TYPRHO2))
      {
	addrfbits(&sdixon2,0,(long)(PosTemp),pw_sdixon2);
      }
  }

    enableRfSspControl();

        
  {
    pulsename(&seqaushim,"seqaushim");
    createseq(&seqaushim,RUP_GRD((int)(tr_as-time_ssias)), off_seqaushim);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqaushim );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqaushim = %d\n", idx_seqaushim );
#endif
  }

    attenflagon(&seqaushim, 0);

    /***********************************************************
     * Pass Packet sequence
     ***********************************************************/
     
  {
    pulsename(&pass_aushim,"pass_aushim");
    createpass(&pass_aushim,(long)(RUP_GRD(PSTR_PASS-1000)));
  }

      
  {
    pulsename(&seqpassas,"seqpassas");
    createseq(&seqpassas,RUP_GRD(PSTR_PASS), off_seqpassas);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqpassas );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqpassas = %d\n", idx_seqpassas );
#endif
  }


    return SUCCESS;
}   /* end ASpulsegen() */


/*
 *  RSpulsegen
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
RSpulsegen( void )
{
    EXTERN_FILENAME ext_filename;
    INT PosTemp, PosRead1;
    INT DabSetUp, PosDabPkt, PosXtrPkt;
    INT PosDabPkt2toN, PosXtrPkt2toN;
    INT temp_res, temp_time;
    INT echoind;
    short *wave_space;
    short *temp_wave_space;
    short DDIQ_length = DDIQ_LENGTH;
    short DDIQ_bits[DDIQ_LENGTH] = {SSPDS, SSPOC, SSPD, SSPDS};

    DDIQ_bits[0]=SSPDS|EDC;
    DDIQ_bits[1]=SSPOC|DDIQSWOC;

    /* DD IQ Channel */
        
  {
    pulsename(&dDDIQ,"dDDIQ");
    createbits(&dDDIQ,TYPSSP,sizeof(DDIQ_bits)/2,DDIQ_bits);
    createinstr( &dDDIQ,(long)(GRAD_UPDATE_TIME+tleadrs),
		DDIQ_length,ia_dDDIQ);
  }

    DD_delay = 2000;
      
  {
    pulsename(&seqIQControl,"seqIQControl");
    createseq(&seqIQControl,RUP_GRD(DD_delay), off_seqIQControl);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqIQControl );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqIQControl = %d\n", idx_seqIQControl );
#endif
  }


    /* selective RF1 */
    PosTemp = td0rs + pw_gzrf1rsa;
    temp_res = res_rf1rs;

    switch (rf1rs_type)
    {
        case B1RF1_SINC:
            if(PSD_ON == rfpulseInfo[RF1_RFSHIM_SLOT].change)
            {
                res_rf1rs = rfpulseInfo[RF1_RFSHIM_SLOT].newres;
            }
            wave_space = (short *)AllocNode(res_rf1rs*sizeof(short));
            usinc(wave_space, (short)res_rf1rs, (short)max_pg_wamp, cyc_rf1rs, 0.46);
            break;
        case B1RF1_TBW:
        default:
            strcpy(ext_filename,"tbw6_01_01_600.rho");
            /* Set new resolution and stretch external pulse */
            temp_wave_space = (short *)AllocNode(res_rf1rs*sizeof(short));
            uextwave(temp_wave_space, res_rf1rs, ext_filename);
            /* Stretch rf pw if needed */
            if (rfpulseInfo[RF1_RFSHIM_SLOT].change==PSD_ON)
            {
                wave_space = (short *)AllocNode(rfpulseInfo[RF1_RFSHIM_SLOT].newres*
                                                sizeof(short));
                stretchpulse((int)temp_res, (int)rfpulseInfo[RF1_RFSHIM_SLOT].newres,
                             temp_wave_space,wave_space);

                res_rf1rs = rfpulseInfo[RF1_RFSHIM_SLOT].newres;

                FreeNode(temp_wave_space);
            }
            else
            {
                wave_space = temp_wave_space;
            }

            break;
    }
      
  {
    pulsename(&rf1rs,"rf1rs");
    createreserve(&rf1rs,(WF_PROCESSOR)wg_rf1rs,
		  res_rf1rs);
  }

    createinstr( &rf1rs, PosTemp+psd_rf_wait, pw_rf1rs, ia_rf1rs );
    addrfbits(&rf1rs, 0, PosTemp+psd_rf_wait, pw_rf1rs);
    movewaveimm(wave_space, &rf1rs, (int)0, res_rf1rs, TOHARDWARE);

    FreeNode(wave_space);
    setiamp(ia_rf1rs, &rf1rs, 0);

    res_rf1rs = temp_res;
    /* Z slice selective for rf1 */
           

    setWaveformPurpose(gzrf1rsa, gzrf1rs.purpose);
    setWaveformPurpose(gzrf1rsd, gzrf1rs.purpose);
    trapezoid((WF_PROCESSOR)wg_gzrf1rs, "gzrf1rs", &gzrf1rs, &gzrf1rsa,
              &gzrf1rsd, pw_gzrf1rs, pw_gzrf1rsa, pw_gzrf1rsd,
              ia_gzrf1rs, 0, 0, 0, 0, PosTemp-pw_gzrf1rsa, TRAP_ALL,
              &rsloggrd);


    /*******************************
                X BS Killer
     *******************************/
           

    setWaveformPurpose(gxkbsrsa, gxkbsrs.purpose);
    setWaveformPurpose(gxkbsrsd, gxkbsrs.purpose);
    trapezoid((WF_PROCESSOR)wg_gxkbsrs, "gxkbsrs", &gxkbsrs, &gxkbsrsa,
              &gxkbsrsd, pw_gxkbsrs, pw_gxkbsrsa, pw_gxkbsrsd,
              ia_gxkbsrs, 0, 0, 0, 0, RUP_GRD(pend(&rf1rs,"rf1rs",0)+pw_gxkbsrsa)-pw_gxkbsrsa, TRAP_ALL,
              &rsloggrd);


    PosTemp = RUP_GRD(pendall( &gzrf1rs, 0 ) + pw_gz1rsa);

          

    setWaveformPurpose(gz1rsa, gz1rs.purpose);
    setWaveformPurpose(gz1rsd, gz1rs.purpose);
    trapezoid((WF_PROCESSOR)wg_gz1rs, "gz1rs", &gz1rs, &gz1rsa,
              &gz1rsd, pw_gz1rs, pw_gz1rsa, pw_gz1rsd,
              ia_gz1rs, 0, 0, 0, 0, PosTemp-pw_gz1rsa, TRAP_ALL,
              &rsloggrd);


    /* RFBRS: BLS RF pulse */
    temp_time = IMax(3, pw_gzrf1rsd+pw_gz1rsa+pw_gz1rs+pw_gz1rsd, pw_gxkbsrsa + pw_gxkbsrs + pw_gxkbsrsd,
                     minimumPreRfSspTime() + minimumPostRfSspTime() );

    PosTemp = RUP_GRD(pend(&rf1rs, "rf1rs", 0)+ temp_time);

         
               
  {
        INT old_res =  res_rfbrs; /* temp holder for old pulse resolution */

    if ( (wg_rfbrs != TYPRHO1)  && (wg_rfbrs != TYPRHO2) &&
         (wg_rfbrs != TYPTHETA) && (wg_rfbrs != TYPOMEGA) ) {

        fprintf( stderr, "EXTWAVE2 macro must create pulses on RHO1 or RHO2.\n");
        fflush( stderr );

        return FAILURE;
    }

    n_rfbrs += 1;  /* Increment counter */

    /*** Read in waveform if it has not been created yet ***/

    if( rfbrs.ninsts == 0 ) {        

        /* Set pulsename */
        pulsename(&rfbrs,"rfbrs");
        
        /* Scale waveform if needed */
            if( rfpulseInfo[rfslot_rfbrs].change==PSD_ON )
            {
                INT new_res =  rfpulseInfo[rfslot_rfbrs].newres;

            /* ***************************************************************
             *  Create some board waveform space, scale the pulse, and then
             *  move the local memory to the reserved board memory, and set
             *  pulsepointers to new stretched pulse.
             *
             *  Now create the rf pulse & perform required system safety
             *  checks and create a temporary buffer for the stretched RF
             *  pulse. Stretch the pulse and copy stretched data into
             *  permanent waveform memory. It is important to have temp
             *  buffer have new resolution size waveform memory.
             *************************************************************** */

            /* Reserve waveform memory on the RF channel for
               stretched RF pulse */
            createreserve(&rfbrs, (WF_PROCESSOR)wg_rfbrs, new_res);

                movestretchedwave( fileloc_rfbrs, old_res,
                                   &rfbrs, 0, new_res );
            
            /*  Set the resolution of the RF pulse to the resolution of the
             *  stretched RF pulse.  This is done becaused the createinstr()
             *  access the RF pulse structure, which contains a reference to
             *  the resolution of the RF pulse.  When the instruction is
             *  created it must contain the resolution of the stretched RF
             *  pulse.
             */
            res_rfbrs = new_res;
        } else {
            
            /* No rf scaling required. Use createextwave
               to read pulse and move to HW.             */ 
            createextwave(&rfbrs,(WF_PROCESSOR)wg_rfbrs,
                          old_res,fileloc_rfbrs);
        }
    }


    /*** Create Instruction Node ***/
    createinstr( &rfbrs,(LONG)(PosTemp) + psd_rf_wait, 
                 pw_rfbrs,ia_rfbrs);
    

    /*** Add RF Bits ***/
    addrfbits(&rfbrs,off_rfbrs,(LONG)(PosTemp) + psd_rf_wait,
              pw_rfbrs);
    

    /*** Reset Resolution ***/
    res_rfbrs = old_res;
    /* Reset the resolution of the RF pulse to the original
       (unstretched) resolution. This is necessary to allow this macro
       to be called multiple times. */
  }

         
               
  {
        INT old_res =  res_thetarfbrs; /* temp holder for old pulse resolution */

    if ( (wg_thetarfbrs != TYPRHO1)  && (wg_thetarfbrs != TYPRHO2) &&
         (wg_thetarfbrs != TYPTHETA) && (wg_thetarfbrs != TYPOMEGA) ) {

        fprintf( stderr, "EXTWAVE2 macro must create pulses on RHO1 or RHO2.\n");
        fflush( stderr );

        return FAILURE;
    }

    n_thetarfbrs += 1;  /* Increment counter */

    /*** Read in waveform if it has not been created yet ***/

    if( thetarfbrs.ninsts == 0 ) {        

        /* Set pulsename */
        pulsename(&thetarfbrs,"thetarfbrs");
        
        /* Scale waveform if needed */
            if( rfpulseInfo[rfslot_thetarfbrs].change==PSD_ON )
            {
                INT new_res =  rfpulseInfo[rfslot_thetarfbrs].newres;

            /* ***************************************************************
             *  Create some board waveform space, scale the pulse, and then
             *  move the local memory to the reserved board memory, and set
             *  pulsepointers to new stretched pulse.
             *
             *  Now create the rf pulse & perform required system safety
             *  checks and create a temporary buffer for the stretched RF
             *  pulse. Stretch the pulse and copy stretched data into
             *  permanent waveform memory. It is important to have temp
             *  buffer have new resolution size waveform memory.
             *************************************************************** */

            /* Reserve waveform memory on the RF channel for
               stretched RF pulse */
            createreserve(&thetarfbrs, (WF_PROCESSOR)wg_thetarfbrs, new_res);

                movestretchedwave( fileloc_thetarfbrs, old_res,
                                   &thetarfbrs, 0, new_res );
            
            /*  Set the resolution of the RF pulse to the resolution of the
             *  stretched RF pulse.  This is done becaused the createinstr()
             *  access the RF pulse structure, which contains a reference to
             *  the resolution of the RF pulse.  When the instruction is
             *  created it must contain the resolution of the stretched RF
             *  pulse.
             */
            res_thetarfbrs = new_res;
        } else {
            
            /* No rf scaling required. Use createextwave
               to read pulse and move to HW.             */ 
            createextwave(&thetarfbrs,(WF_PROCESSOR)wg_thetarfbrs,
                          old_res,fileloc_thetarfbrs);
        }
    }


    /*** Create Instruction Node ***/
    createinstr( &thetarfbrs,(LONG)(PosTemp) + psd_rf_wait, 
                 pw_thetarfbrs,ia_thetarfbrs);
    

    /*** Add RF Bits ***/
    addrfbits(&thetarfbrs,off_thetarfbrs,(LONG)(PosTemp) + psd_rf_wait,
              pw_thetarfbrs);
    

    /*** Reset Resolution ***/
    res_thetarfbrs = old_res;
    /* Reset the resolution of the RF pulse to the original
       (unstretched) resolution. This is necessary to allow this macro
       to be called multiple times. */
  }


    setiamp(ia_rfbrs, &rfbrs, 0);
    setiamp(ia_thetarfbrs, &thetarfbrs, 0);

    /*******************************
     *        Z BS Killer
     *******************************/
    PosTemp = PosTemp + pw_rfbrs;
       

    setWaveformPurpose(gzkbsrsa, gzkbsrs.purpose);
    setWaveformPurpose(gzkbsrsd, gzkbsrs.purpose);
    trapezoid((WF_PROCESSOR)wg_gzkbsrs, "gzkbsrs", &gzkbsrs, &gzkbsrsa,
              &gzkbsrsd, pw_gzkbsrs, pw_gzkbsrsa, pw_gzkbsrsd,
              ia_gzkbsrs, 0, 0, 0, 0, RUP_GRD(PosTemp+pw_gzkbsrsa)-pw_gzkbsrsa, TRAP_ALL,
              &rsloggrd);


    /***************************************
     * X board
     ***************************************/
    PosTemp = RUP_GRD(pend(&gzrf1rs, "gzrf1rs", 0) - rs_iso_delay + min_rste - pw_gxwrs/2.0);
    DabSetUp = IMax(2,DABSETUP,(XTRSETLNG+XTR_length[bd_index]+DAB_length[bd_index]));
    PosDabPkt = RUP_GRD(PosTemp+psd_grd_wait-DabSetUp);
    PosXtrPkt = RUP_GRD(PosTemp+psd_grd_wait-XTR_length[bd_index]-XTRSETLNG);

           

    setWaveformPurpose(gxwrsa, gxwrs.purpose);
    setWaveformPurpose(gxwrsd, gxwrs.purpose);
    trapezoid((WF_PROCESSOR)wg_gxwrs, "gxwrs", &gxwrs, &gxwrsa,
              &gxwrsd, pw_gxwrs, pw_gxwrsa, pw_gxwrsd,
              ia_gxwrs, 0, 0, 0, 0, PosTemp-pw_gxwrsa, TRAP_ALL,
              &rsloggrd);


        
    {
        pulsename(&echo1rs,"echo1rs");
        acqq(&echo1rs, (long)(PosTemp+psd_grd_wait),(long)(PosDabPkt),
             (long)(PosXtrPkt),(long)filter_echo1rs,
             (TYPDAB_PACKETS)DABNORM);
    }

    PosRead1 = PosTemp;

    if(rfshim_etl >=2)
    {
        char pulse_name[20];

        rs_echo2toN = (WF_PULSE *)AllocNode(rfshim_etl*sizeof(WF_PULSE));

        for(echoind=0; echoind < (rfshim_etl-1); echoind++)
        {
            PosTemp = RUP_GRD(pendall( &gxwrs, 0 ) + pw_gx2rsa + echoind*rs_esp);
                   

    setWaveformPurpose(gx2rsa, gx2rs.purpose);
    setWaveformPurpose(gx2rsd, gx2rs.purpose);
    trapezoid((WF_PROCESSOR)wg_gx2rs, "gx2rs", &gx2rs, &gx2rsa,
              &gx2rsd, pw_gx2rs, pw_gx2rsa, pw_gx2rsd,
              ia_gx2rs, 0, 0, 0, 0, PosTemp-pw_gx2rsa, TRAP_ALL,
              &rsloggrd);


            PosTemp = RUP_GRD(pendall( &gxwrs, 0 ) +  echoind*rs_esp);
                
    setWaveformPurpose(gy2rsa, gy2rs.purpose);
    setWaveformPurpose(gy2rsd, gy2rs.purpose);
    trapezoid((WF_PROCESSOR)wg_gy2rs,"gy2rs",
              &gy2rs,&gy2rsa,&gy2rsd,
              pw_gy2rs,pw_gy2rsa,pw_gy2rsd,
              ia_gy2rs,ia_gy2rswa,ia_gy2rswb,
              0,0,PosTemp,TRAP_ALL_SLOPED,
                          &rsloggrd);


            PosDabPkt2toN = RUP_GRD(PosDabPkt + (echoind+1)*rs_esp);
            PosTemp = RUP_GRD(PosRead1 + (echoind+1)*rs_esp);
            PosXtrPkt2toN = RUP_GRD(PosXtrPkt + (echoind+1)*rs_esp);
                   

    setWaveformPurpose(gxw2rsa, gxw2rs.purpose);
    setWaveformPurpose(gxw2rsd, gxw2rs.purpose);
    trapezoid((WF_PROCESSOR)wg_gxw2rs, "gxw2rs", &gxw2rs, &gxw2rsa,
              &gxw2rsd, pw_gxw2rs, pw_gxw2rsa, pw_gxw2rsd,
              ia_gxw2rs, 0, 0, 0, 0, PosTemp-pw_gxw2rsa, TRAP_ALL,
              &rsloggrd);


            sprintf(pulse_name,"rs_echo2toN%d",echoind);
            pulsename(&(rs_echo2toN[echoind]),pulse_name);

            acqq(&(rs_echo2toN[echoind]), (long) (PosTemp+psd_grd_wait), (long) PosDabPkt2toN,(long)(PosXtrPkt2toN),filter_echo1rs,(TYPDAB_PACKETS)DABNORM);
        }

    }

    attenflagon(&echo1rs,0);

    PosTemp = RUP_GRD(pbegall(&gxwrs, 0)-pw_gx1rsd-pw_gx1rs);
           

    setWaveformPurpose(gx1rsa, gx1rs.purpose);
    setWaveformPurpose(gx1rsd, gx1rs.purpose);
    trapezoid((WF_PROCESSOR)wg_gx1rs, "gx1rs", &gx1rs, &gx1rsa,
              &gx1rsd, pw_gx1rs, pw_gx1rsa, pw_gx1rsd,
              ia_gx1rs, 0, 0, 0, 0, PosTemp-pw_gx1rsa, TRAP_ALL,
              &rsloggrd);


    /*******************************************
     *  Y phase encoding and possible rewinder *
     *******************************************/
    if(rfshim_etl >=2)
    {
        PosTemp = RUP_GRD(pend(&gxw2rs,"gxw2rs", gxw2rs.ninsts-1));
    }
    else
    {
        PosTemp = RUP_GRD(pend( &gxwrs, "gxwrs", 0 ));
    }
           
    setWaveformPurpose(gy1rrsa, gy1rrs.purpose);
    setWaveformPurpose(gy1rrsd, gy1rrs.purpose);
    trapezoid((WF_PROCESSOR)wg_gy1rrs,"gy1rrs",
              &gy1rrs,&gy1rrsa,&gy1rrsd,
              pw_gy1rrs,pw_gy1rrsa,pw_gy1rrsd,
              ia_gy1rrs,ia_gy1rrswa,ia_gy1rrswb,
              0,0,PosTemp,TRAP_ALL_SLOPED,
                          &rsloggrd);


    PosTemp = RUP_GRD(pbeg( &gxwrs, "gxwrs", 0 ) - pw_gy1rsd - pw_gy1rs - pw_gy1rsa);
           
    setWaveformPurpose(gy1rsa, gy1rs.purpose);
    setWaveformPurpose(gy1rsd, gy1rs.purpose);
    trapezoid((WF_PROCESSOR)wg_gy1rs,"gy1rs",
              &gy1rs,&gy1rsa,&gy1rsd,
              pw_gy1rs,pw_gy1rsa,pw_gy1rsd,
              ia_gy1rs,ia_gy1rswa,ia_gy1rswb,
              0,0,PosTemp,TRAP_ALL_SLOPED,
                          &rsloggrd);


    /* Z crusher */
    if(rfshim_etl >=2)
    {
        PosTemp = RUP_GRD(pend(&gxw2rs,"gxw2rs", gxw2rs.ninsts-1));
    }
    else
    {
        PosTemp = RUP_GRD(pend( &gxwrs, "gxwrs", 0 ));
    }
           

    setWaveformPurpose(gzkrsa, gzkrs.purpose);
    setWaveformPurpose(gzkrsd, gzkrs.purpose);
    trapezoid((WF_PROCESSOR)wg_gzkrs, "gzkrs", &gzkrs, &gzkrsa,
              &gzkrsd, pw_gzkrs, pw_gzkrsa, pw_gzkrsd,
              ia_gzkrs, 0, 0, 0, 0, RUP_GRD(PosTemp+pw_gzkrsa)-pw_gzkrsa, TRAP_ALL,
              &rsloggrd);


    /* X crusher */
           

    setWaveformPurpose(gxkrsa, gxkrs.purpose);
    setWaveformPurpose(gxkrsd, gxkrs.purpose);
    trapezoid((WF_PROCESSOR)wg_gxkrs, "gxkrs", &gxkrs, &gxkrsa,
              &gxkrsd, pw_gxkrs, pw_gxkrsa, pw_gxkrsd,
              ia_gxkrs, 0, 0, 0, 0, RUP_GRD(PosTemp+pw_gxwrsd+pw_gxkrsa)-pw_gxkrsa, TRAP_ALL,
              &rsloggrd);


    /*****************************************
     * Attenuator lock
     *****************************************/
     
    {
        pulsename(&attenuator_keyrs,"attenuator_keyrs");
        createatten(&attenuator_keyrs, (long)(RUP_GRD(PosTemp+psd_grd_wait)));
    }


      
  {
    pulsename(&seqrs,"seqrs");
    createseq(&seqrs,RUP_GRD(tr_rs), off_seqrs);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqrs );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqrs = %d\n", idx_seqrs );
#endif
  }

    attenflagon(&seqrs, 0);

    /***********************************************************
     * Pass Packet sequence
     ***********************************************************/
     
  {
    pulsename(&pass_rs,"pass_rs");
    createpass(&pass_rs,(long)(RUP_GRD(TR_PSCPASS-1000)));
  }

      
  {
    pulsename(&seqpassrs,"seqpassrs");
    createseq(&seqpassrs,RUP_GRD(TR_PSCPASS), off_seqpassrs);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqpassrs );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqpassrs = %d\n", idx_seqpassrs );
#endif
  }


    return SUCCESS;
}

/*
 *  DTGpulsegen
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
DTGpulsegen( void )
{
    EXTERN_FILENAME ext_filename;
    INT PosTemp, PosRead1;
    INT DabSetUp, PosDabPkt, PosXtrPkt;
    INT PosDabPkt2toN, PosXtrPkt2toN;
    INT temp_time;
    INT temp_res;
    INT echoind;
    short *wave_space;
    short *temp_wave_space;

    /* selective RF1 */
    PosTemp = td0dtg + pw_gzrf1dtga;
    temp_res = res_rf1dtg;

    switch (rf1dtg_type)
    {
        case B1RF1_SINC:
            if(PSD_ON == rfpulseInfo[RF1_DYNTG_SLOT].change)
            {
                res_rf1dtg = rfpulseInfo[RF1_DYNTG_SLOT].newres;
            }
            wave_space = (short *)AllocNode(res_rf1dtg*sizeof(short));
            usinc(wave_space, (short)res_rf1dtg, (short)max_pg_wamp, cyc_rf1dtg, 0.46);
            break;
        case B1RF1_TBW:
        default:
            strcpy(ext_filename,"tbw6_01_01_600.rho");
            /* Set new resolution and stretch external pulse */
            temp_wave_space = (short *)AllocNode(res_rf1dtg*sizeof(short));
            uextwave(temp_wave_space, res_rf1dtg, ext_filename);
            /* Stretch rf pw if needed */
            if (rfpulseInfo[RF1_DYNTG_SLOT].change==PSD_ON)
            {
                wave_space = (short *)AllocNode(rfpulseInfo[RF1_DYNTG_SLOT].newres*
                                                sizeof(short));
                stretchpulse((int)temp_res, (int)rfpulseInfo[RF1_DYNTG_SLOT].newres,
                             temp_wave_space,wave_space);

                res_rf1dtg = rfpulseInfo[RF1_DYNTG_SLOT].newres;

                FreeNode(temp_wave_space);
            }
            else
            {
                wave_space = temp_wave_space;
            }

            break;
    }
      
  {
    pulsename(&rf1dtg,"rf1dtg");
    createreserve(&rf1dtg,(WF_PROCESSOR)wg_rf1dtg,
		  res_rf1dtg);
  }

    createinstr( &rf1dtg, PosTemp+psd_rf_wait, pw_rf1dtg, ia_rf1dtg );
    addrfbits(&rf1dtg, 0, PosTemp+psd_rf_wait, pw_rf1dtg);
    movewaveimm(wave_space, &rf1dtg, (int)0, res_rf1dtg, TOHARDWARE);

    FreeNode(wave_space);
    setiamp(ia_rf1dtg, &rf1dtg, 0);

    res_rf1dtg = temp_res;
    /* Z slice selective for rf1dtg */
           

    setWaveformPurpose(gzrf1dtga, gzrf1dtg.purpose);
    setWaveformPurpose(gzrf1dtgd, gzrf1dtg.purpose);
    trapezoid((WF_PROCESSOR)wg_gzrf1dtg, "gzrf1dtg", &gzrf1dtg, &gzrf1dtga,
              &gzrf1dtgd, pw_gzrf1dtg, pw_gzrf1dtga, pw_gzrf1dtgd,
              ia_gzrf1dtg, 0, 0, 0, 0, PosTemp-pw_gzrf1dtga, TRAP_ALL,
              &dtgloggrd);


    /*******************************
           X BS Killer
    *******************************/
           

    setWaveformPurpose(gxkbsdtga, gxkbsdtg.purpose);
    setWaveformPurpose(gxkbsdtgd, gxkbsdtg.purpose);
    trapezoid((WF_PROCESSOR)wg_gxkbsdtg, "gxkbsdtg", &gxkbsdtg, &gxkbsdtga,
              &gxkbsdtgd, pw_gxkbsdtg, pw_gxkbsdtga, pw_gxkbsdtgd,
              ia_gxkbsdtg, 0, 0, 0, 0, RUP_GRD(pend(&rf1dtg,"rf1dtg",0)+pw_gxkbsdtga)-pw_gxkbsdtga, TRAP_ALL,
              &dtgloggrd);


    PosTemp = RUP_GRD(pendall( &gzrf1dtg, 0 ) + pw_gz1dtga);

           

    setWaveformPurpose(gz1dtga, gz1dtg.purpose);
    setWaveformPurpose(gz1dtgd, gz1dtg.purpose);
    trapezoid((WF_PROCESSOR)wg_gz1dtg, "gz1dtg", &gz1dtg, &gz1dtga,
              &gz1dtgd, pw_gz1dtg, pw_gz1dtga, pw_gz1dtgd,
              ia_gz1dtg, 0, 0, 0, 0, PosTemp-pw_gz1dtga, TRAP_ALL,
              &dtgloggrd);


    /* RFBDTG: BLS RF pulse */
    temp_time = IMax(3, pw_gzrf1dtgd+pw_gz1dtga+pw_gz1dtg+pw_gz1dtgd, pw_gxkbsdtga + pw_gxkbsdtg + pw_gxkbsdtgd,
                     minimumPreRfSspTime() + minimumPostRfSspTime() );

    PosTemp = RUP_GRD(pend(&rf1dtg, "rf1dtg", 0)+ temp_time);

         
               
  {
        INT old_res =  res_rfbdtg; /* temp holder for old pulse resolution */

    if ( (wg_rfbdtg != TYPRHO1)  && (wg_rfbdtg != TYPRHO2) &&
         (wg_rfbdtg != TYPTHETA) && (wg_rfbdtg != TYPOMEGA) ) {

        fprintf( stderr, "EXTWAVE2 macro must create pulses on RHO1 or RHO2.\n");
        fflush( stderr );

        return FAILURE;
    }

    n_rfbdtg += 1;  /* Increment counter */

    /*** Read in waveform if it has not been created yet ***/

    if( rfbdtg.ninsts == 0 ) {        

        /* Set pulsename */
        pulsename(&rfbdtg,"rfbdtg");
        
        /* Scale waveform if needed */
            if( rfpulseInfo[rfslot_rfbdtg].change==PSD_ON )
            {
                INT new_res =  rfpulseInfo[rfslot_rfbdtg].newres;

            /* ***************************************************************
             *  Create some board waveform space, scale the pulse, and then
             *  move the local memory to the reserved board memory, and set
             *  pulsepointers to new stretched pulse.
             *
             *  Now create the rf pulse & perform required system safety
             *  checks and create a temporary buffer for the stretched RF
             *  pulse. Stretch the pulse and copy stretched data into
             *  permanent waveform memory. It is important to have temp
             *  buffer have new resolution size waveform memory.
             *************************************************************** */

            /* Reserve waveform memory on the RF channel for
               stretched RF pulse */
            createreserve(&rfbdtg, (WF_PROCESSOR)wg_rfbdtg, new_res);

                movestretchedwave( fileloc_rfbdtg, old_res,
                                   &rfbdtg, 0, new_res );
            
            /*  Set the resolution of the RF pulse to the resolution of the
             *  stretched RF pulse.  This is done becaused the createinstr()
             *  access the RF pulse structure, which contains a reference to
             *  the resolution of the RF pulse.  When the instruction is
             *  created it must contain the resolution of the stretched RF
             *  pulse.
             */
            res_rfbdtg = new_res;
        } else {
            
            /* No rf scaling required. Use createextwave
               to read pulse and move to HW.             */ 
            createextwave(&rfbdtg,(WF_PROCESSOR)wg_rfbdtg,
                          old_res,fileloc_rfbdtg);
        }
    }


    /*** Create Instruction Node ***/
    createinstr( &rfbdtg,(LONG)(PosTemp) + psd_rf_wait, 
                 pw_rfbdtg,ia_rfbdtg);
    

    /*** Add RF Bits ***/
    addrfbits(&rfbdtg,off_rfbdtg,(LONG)(PosTemp) + psd_rf_wait,
              pw_rfbdtg);
    

    /*** Reset Resolution ***/
    res_rfbdtg = old_res;
    /* Reset the resolution of the RF pulse to the original
       (unstretched) resolution. This is necessary to allow this macro
       to be called multiple times. */
  }

         
               
  {
        INT old_res =  res_thetarfbdtg; /* temp holder for old pulse resolution */

    if ( (wg_thetarfbdtg != TYPRHO1)  && (wg_thetarfbdtg != TYPRHO2) &&
         (wg_thetarfbdtg != TYPTHETA) && (wg_thetarfbdtg != TYPOMEGA) ) {

        fprintf( stderr, "EXTWAVE2 macro must create pulses on RHO1 or RHO2.\n");
        fflush( stderr );

        return FAILURE;
    }

    n_thetarfbdtg += 1;  /* Increment counter */

    /*** Read in waveform if it has not been created yet ***/

    if( thetarfbdtg.ninsts == 0 ) {        

        /* Set pulsename */
        pulsename(&thetarfbdtg,"thetarfbdtg");
        
        /* Scale waveform if needed */
            if( rfpulseInfo[rfslot_thetarfbdtg].change==PSD_ON )
            {
                INT new_res =  rfpulseInfo[rfslot_thetarfbdtg].newres;

            /* ***************************************************************
             *  Create some board waveform space, scale the pulse, and then
             *  move the local memory to the reserved board memory, and set
             *  pulsepointers to new stretched pulse.
             *
             *  Now create the rf pulse & perform required system safety
             *  checks and create a temporary buffer for the stretched RF
             *  pulse. Stretch the pulse and copy stretched data into
             *  permanent waveform memory. It is important to have temp
             *  buffer have new resolution size waveform memory.
             *************************************************************** */

            /* Reserve waveform memory on the RF channel for
               stretched RF pulse */
            createreserve(&thetarfbdtg, (WF_PROCESSOR)wg_thetarfbdtg, new_res);

                movestretchedwave( fileloc_thetarfbdtg, old_res,
                                   &thetarfbdtg, 0, new_res );
            
            /*  Set the resolution of the RF pulse to the resolution of the
             *  stretched RF pulse.  This is done becaused the createinstr()
             *  access the RF pulse structure, which contains a reference to
             *  the resolution of the RF pulse.  When the instruction is
             *  created it must contain the resolution of the stretched RF
             *  pulse.
             */
            res_thetarfbdtg = new_res;
        } else {
            
            /* No rf scaling required. Use createextwave
               to read pulse and move to HW.             */ 
            createextwave(&thetarfbdtg,(WF_PROCESSOR)wg_thetarfbdtg,
                          old_res,fileloc_thetarfbdtg);
        }
    }


    /*** Create Instruction Node ***/
    createinstr( &thetarfbdtg,(LONG)(PosTemp) + psd_rf_wait, 
                 pw_thetarfbdtg,ia_thetarfbdtg);
    

    /*** Add RF Bits ***/
    addrfbits(&thetarfbdtg,off_thetarfbdtg,(LONG)(PosTemp) + psd_rf_wait,
              pw_thetarfbdtg);
    

    /*** Reset Resolution ***/
    res_thetarfbdtg = old_res;
    /* Reset the resolution of the RF pulse to the original
       (unstretched) resolution. This is necessary to allow this macro
       to be called multiple times. */
  }


    setiamp(ia_rfbdtg, &rfbdtg, 0);
    setiamp(ia_thetarfbdtg, &thetarfbdtg, 0);

    /*******************************
       Z BS Killer
    *******************************/
    PosTemp = PosTemp + pw_rfbdtg; 
       

    setWaveformPurpose(gzkbsdtga, gzkbsdtg.purpose);
    setWaveformPurpose(gzkbsdtgd, gzkbsdtg.purpose);
    trapezoid((WF_PROCESSOR)wg_gzkbsdtg, "gzkbsdtg", &gzkbsdtg, &gzkbsdtga,
              &gzkbsdtgd, pw_gzkbsdtg, pw_gzkbsdtga, pw_gzkbsdtgd,
              ia_gzkbsdtg, 0, 0, 0, 0, RUP_GRD(PosTemp+pw_gzkbsdtga)-pw_gzkbsdtga, TRAP_ALL,
              &dtgloggrd);


    /***************************************
     * X board
     ***************************************/
    PosTemp = RUP_GRD(pend(&gzrf1dtg, "gzrf1dtg", 0) - dtg_iso_delay + min_dtgte - pw_gxwdtg/2.0);
    DabSetUp = IMax(2,DABSETUP,(XTRSETLNG+XTR_length[bd_index]+DAB_length[bd_index]));
    PosDabPkt = RUP_GRD(PosTemp+psd_grd_wait-DabSetUp);
    PosXtrPkt = RUP_GRD(PosTemp+psd_grd_wait-XTR_length[bd_index]-XTRSETLNG);

           

    setWaveformPurpose(gxwdtga, gxwdtg.purpose);
    setWaveformPurpose(gxwdtgd, gxwdtg.purpose);
    trapezoid((WF_PROCESSOR)wg_gxwdtg, "gxwdtg", &gxwdtg, &gxwdtga,
              &gxwdtgd, pw_gxwdtg, pw_gxwdtga, pw_gxwdtgd,
              ia_gxwdtg, 0, 0, 0, 0, PosTemp-pw_gxwdtga, TRAP_ALL,
              &dtgloggrd);


        
    {
        pulsename(&echo1dtg,"echo1dtg");
        acqq(&echo1dtg, (long)(PosTemp+psd_grd_wait),(long)(PosDabPkt),
             (long)(PosXtrPkt),(long)filter_echo1dtg,
             (TYPDAB_PACKETS)DABNORM);
    }

    PosRead1 = PosTemp;

    if(dynTG_etl >=2)
    {
        char pulse_name[20];

        dtg_echo2toN = (WF_PULSE *)AllocNode(dynTG_etl*sizeof(WF_PULSE));

        for(echoind=0; echoind < (dynTG_etl-1); echoind++)
        {
            PosTemp = RUP_GRD(pendall( &gxwdtg, 0 ) + pw_gx2dtga + echoind*dtg_esp);
                   

    setWaveformPurpose(gx2dtga, gx2dtg.purpose);
    setWaveformPurpose(gx2dtgd, gx2dtg.purpose);
    trapezoid((WF_PROCESSOR)wg_gx2dtg, "gx2dtg", &gx2dtg, &gx2dtga,
              &gx2dtgd, pw_gx2dtg, pw_gx2dtga, pw_gx2dtgd,
              ia_gx2dtg, 0, 0, 0, 0, PosTemp-pw_gx2dtga, TRAP_ALL,
              &dtgloggrd);


            PosTemp = RUP_GRD(pendall( &gxwdtg, 0 ) +  echoind*dtg_esp);
                
    setWaveformPurpose(gy2dtga, gy2dtg.purpose);
    setWaveformPurpose(gy2dtgd, gy2dtg.purpose);
    trapezoid((WF_PROCESSOR)wg_gy2dtg,"gy2dtg",
              &gy2dtg,&gy2dtga,&gy2dtgd,
              pw_gy2dtg,pw_gy2dtga,pw_gy2dtgd,
              ia_gy2dtg,ia_gy2dtgwa,ia_gy2dtgwb,
              0,0,PosTemp,TRAP_ALL_SLOPED,
                          &dtgloggrd);


            PosDabPkt2toN = RUP_GRD(PosDabPkt + (echoind+1)*dtg_esp);
            PosTemp = RUP_GRD(PosRead1 + (echoind+1)*dtg_esp);
            PosXtrPkt2toN = RUP_GRD(PosXtrPkt + (echoind+1)*dtg_esp);
                   

    setWaveformPurpose(gxw2dtga, gxw2dtg.purpose);
    setWaveformPurpose(gxw2dtgd, gxw2dtg.purpose);
    trapezoid((WF_PROCESSOR)wg_gxw2dtg, "gxw2dtg", &gxw2dtg, &gxw2dtga,
              &gxw2dtgd, pw_gxw2dtg, pw_gxw2dtga, pw_gxw2dtgd,
              ia_gxw2dtg, 0, 0, 0, 0, PosTemp-pw_gxw2dtga, TRAP_ALL,
              &dtgloggrd);


            sprintf(pulse_name,"dtg_echo2toN%d",echoind);
            pulsename(&(dtg_echo2toN[echoind]),pulse_name);

            acqq(&(dtg_echo2toN[echoind]), (long) (PosTemp+psd_grd_wait), (long) PosDabPkt2toN,(long)(PosXtrPkt2toN),filter_echo1dtg,(TYPDAB_PACKETS)DABNORM);
        }

    }

    attenflagon(&echo1dtg,0);

    PosTemp = RUP_GRD(pbegall(&gxwdtg, 0)-pw_gx1dtgd-pw_gx1dtg);
           

    setWaveformPurpose(gx1dtga, gx1dtg.purpose);
    setWaveformPurpose(gx1dtgd, gx1dtg.purpose);
    trapezoid((WF_PROCESSOR)wg_gx1dtg, "gx1dtg", &gx1dtg, &gx1dtga,
              &gx1dtgd, pw_gx1dtg, pw_gx1dtga, pw_gx1dtgd,
              ia_gx1dtg, 0, 0, 0, 0, PosTemp-pw_gx1dtga, TRAP_ALL,
              &dtgloggrd);


    /*******************************************
     *  Y phase encoding and possible rewinder *
     *******************************************/
    if(dynTG_etl >=2)
    {
        PosTemp = RUP_GRD(pend(&gxw2dtg,"gxw2dtg", gxw2dtg.ninsts-1));
    }
    else
    {
        PosTemp = RUP_GRD(pend(&gxwdtg,"gxwdtg", 0));
    }
        
    setWaveformPurpose(gy1rdtga, gy1rdtg.purpose);
    setWaveformPurpose(gy1rdtgd, gy1rdtg.purpose);
    trapezoid((WF_PROCESSOR)wg_gy1rdtg,"gy1rdtg",
              &gy1rdtg,&gy1rdtga,&gy1rdtgd,
              pw_gy1rdtg,pw_gy1rdtga,pw_gy1rdtgd,
              ia_gy1rdtg,ia_gy1rdtgwa,ia_gy1rdtgwb,
              0,0,PosTemp,TRAP_ALL_SLOPED,
                          &dtgloggrd);


    PosTemp = RUP_GRD(pbeg( &gxwdtg, "gxwdtg", 0 ) - pw_gy1dtgd - pw_gy1dtg - pw_gy1dtga);
           
    setWaveformPurpose(gy1dtga, gy1dtg.purpose);
    setWaveformPurpose(gy1dtgd, gy1dtg.purpose);
    trapezoid((WF_PROCESSOR)wg_gy1dtg,"gy1dtg",
              &gy1dtg,&gy1dtga,&gy1dtgd,
              pw_gy1dtg,pw_gy1dtga,pw_gy1dtgd,
              ia_gy1dtg,ia_gy1dtgwa,ia_gy1dtgwb,
              0,0,PosTemp,TRAP_ALL_SLOPED,
                          &dtgloggrd);


    /* Z crusher */
    if(dynTG_etl >=2)
    {
        PosTemp = RUP_GRD(pend(&gxw2dtg,"gxw2dtg", gxw2dtg.ninsts-1));
    }
    else
    {
        PosTemp = RUP_GRD(pend(&gxwdtg, "gxwdtg", 0));
    }

           

    setWaveformPurpose(gzkdtga, gzkdtg.purpose);
    setWaveformPurpose(gzkdtgd, gzkdtg.purpose);
    trapezoid((WF_PROCESSOR)wg_gzkdtg, "gzkdtg", &gzkdtg, &gzkdtga,
              &gzkdtgd, pw_gzkdtg, pw_gzkdtga, pw_gzkdtgd,
              ia_gzkdtg, 0, 0, 0, 0, PosTemp+pw_gzkdtga-pw_gzkdtga, TRAP_ALL,
              &dtgloggrd);


    /* X crusher */
           

    setWaveformPurpose(gxkdtga, gxkdtg.purpose);
    setWaveformPurpose(gxkdtgd, gxkdtg.purpose);
    trapezoid((WF_PROCESSOR)wg_gxkdtg, "gxkdtg", &gxkdtg, &gxkdtga,
              &gxkdtgd, pw_gxkdtg, pw_gxkdtga, pw_gxkdtgd,
              ia_gxkdtg, 0, 0, 0, 0, PosTemp+pw_gxwdtgd+pw_gxkdtga-pw_gxkdtga, TRAP_ALL,
              &dtgloggrd);


    /*****************************************
     * Attenuator lock
     *****************************************/
     
    {
        pulsename(&attenuator_keydtg,"attenuator_keydtg");
        createatten(&attenuator_keydtg, (long)(RUP_GRD(PosTemp+psd_grd_wait)));
    }



      
  {
    pulsename(&seqdtg,"seqdtg");
    createseq(&seqdtg,RUP_GRD(tr_dtg), off_seqdtg);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqdtg );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqdtg = %d\n", idx_seqdtg );
#endif
  }

    attenflagon(&seqdtg, 0);

    /***********************************************************
     * Pass Packet sequence
     ***********************************************************/
     
  {
    pulsename(&pass_dtg,"pass_dtg");
    createpass(&pass_dtg,(long)(RUP_GRD(TR_PSCPASS-1000)));
  }

      
  {
    pulsename(&seqpassdtg,"seqpassdtg");
    createseq(&seqpassdtg,RUP_GRD(TR_PSCPASS), off_seqpassdtg);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqpassdtg );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqpassdtg = %d\n", idx_seqpassdtg );
#endif
  }


    return SUCCESS;
}



/*
 *  ExtCalpulsegen
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
ExtCalpulsegen( void )
{
    INT PosStart;
    INT PosTemp;
    INT DabSetUp, PosDabPkt, PosXtrPkt;

    /* set slice encoding to full scale */
    ia_gzcombcalwa = (int)(PSDRAMPEDTRAP*max_pg_wamp);
    ia_gzcombcalwb = max_pg_wamp;

    ia_gzprcalwa = (int)(PSDRAMPEDTRAP*max_pg_wamp);
    ia_gzprcalwb = max_pg_wamp;

    /* selective RF1 */
    PosStart = td0cal + pw_gzrf1cala;

         
               
  {
        INT old_res =  res_rf1cal; /* temp holder for old pulse resolution */

    if ( (wg_rf1cal != TYPRHO1)  && (wg_rf1cal != TYPRHO2) &&
         (wg_rf1cal != TYPTHETA) && (wg_rf1cal != TYPOMEGA) ) {

        fprintf( stderr, "EXTWAVE2 macro must create pulses on RHO1 or RHO2.\n");
        fflush( stderr );

        return FAILURE;
    }

    n_rf1cal += 1;  /* Increment counter */

    /*** Read in waveform if it has not been created yet ***/

    if( rf1cal.ninsts == 0 ) {        

        /* Set pulsename */
        pulsename(&rf1cal,"rf1cal");
        
        /* Scale waveform if needed */
            if( rfpulseInfo[rfslot_rf1cal].change==PSD_ON )
            {
                INT new_res =  rfpulseInfo[rfslot_rf1cal].newres;

            /* ***************************************************************
             *  Create some board waveform space, scale the pulse, and then
             *  move the local memory to the reserved board memory, and set
             *  pulsepointers to new stretched pulse.
             *
             *  Now create the rf pulse & perform required system safety
             *  checks and create a temporary buffer for the stretched RF
             *  pulse. Stretch the pulse and copy stretched data into
             *  permanent waveform memory. It is important to have temp
             *  buffer have new resolution size waveform memory.
             *************************************************************** */

            /* Reserve waveform memory on the RF channel for
               stretched RF pulse */
            createreserve(&rf1cal, (WF_PROCESSOR)wg_rf1cal, new_res);

                movestretchedwave( fileloc_rf1cal, old_res,
                                   &rf1cal, 0, new_res );
            
            /*  Set the resolution of the RF pulse to the resolution of the
             *  stretched RF pulse.  This is done becaused the createinstr()
             *  access the RF pulse structure, which contains a reference to
             *  the resolution of the RF pulse.  When the instruction is
             *  created it must contain the resolution of the stretched RF
             *  pulse.
             */
            res_rf1cal = new_res;
        } else {
            
            /* No rf scaling required. Use createextwave
               to read pulse and move to HW.             */ 
            createextwave(&rf1cal,(WF_PROCESSOR)wg_rf1cal,
                          old_res,fileloc_rf1cal);
        }
    }


    /*** Create Instruction Node ***/
    createinstr( &rf1cal,(LONG)(PosStart) + psd_rf_wait, 
                 pw_rf1cal,ia_rf1cal);
    

    /*** Add RF Bits ***/
    addrfbits(&rf1cal,off_rf1cal,(LONG)(PosStart) + psd_rf_wait,
              pw_rf1cal);
    

    /*** Reset Resolution ***/
    res_rf1cal = old_res;
    /* Reset the resolution of the RF pulse to the original
       (unstretched) resolution. This is necessary to allow this macro
       to be called multiple times. */
  }


    setiamp(ia_rf1cal, &rf1cal, 0);

    /* Z slice selective for rf1 */
       
               

    setWaveformPurpose(gzrf1cala, gzrf1cal.purpose);
    setWaveformPurpose(gzrf1cald, gzrf1cal.purpose);
    trapezoid((WF_PROCESSOR)wg_gzrf1cal, "gzrf1cal", &gzrf1cal, &gzrf1cala,
              &gzrf1cald, pw_gzrf1cal, pw_gzrf1cala, pw_gzrf1cald,
              ia_gzrf1cal, 0, 0, 0, 0, pbeg(&rf1cal,"rf1cal",0)-psd_rf_wait-pw_gzrf1cala, TRAP_ALL,
              &calloggrd);


    PosTemp = RUP_GRD(pend(&gzrf1cal, "gzrf1cal", 0) + pw_gzrf1cald);
      
    {
#if defined(IPG_TGT) || defined(MGD_TGT)
        s16 gzcombcal_mem[res_gzcombcal];
        s16 gzcombcal_indx = 0;       /* indx into user memory */

        getbeta(&pg_beta, (WF_PROCESSOR)wg_gzcombcal, &calloggrd);

        /* leading edge of zeros */
        if ((0 != 0) && (pw_gzcombcalf != 0))
        {
            uramp( (&gzcombcal_mem[gzcombcal_indx]),
                   (pw_gzcombcalf/per_gzcombcal),
                   (short)0, (short)0, pg_beta );
            /* Clear EOW */
            gzcombcal_indx = ( pw_gzcombcalf/ per_gzcombcal );
            gzcombcal_mem[gzcombcal_indx-1] &= ~WEOS_BIT;
        }
        /* Up ramp */
        uramp( (&gzcombcal_mem[gzcombcal_indx]),
               (pw_gzcombcala/per_gzcombcal),
               (short) 0, ia_gzcombcalwa , pg_beta);
        /* Clear EOW */
        gzcombcal_indx = ( (pw_gzcombcala + pw_gzcombcalf)/ per_gzcombcal );
        gzcombcal_mem[gzcombcal_indx-1] &= ~WEOS_BIT;
        /* Top const */
        uramp((&gzcombcal_mem[gzcombcal_indx]),
              (pw_gzcombcal/per_gzcombcal),
              ia_gzcombcalwa, ia_gzcombcalwb, pg_beta);
        /* Clear EOW */
        gzcombcal_indx = ( (pw_gzcombcala + pw_gzcombcal + pw_gzcombcalf )/ per_gzcombcal );
        gzcombcal_mem[gzcombcal_indx-1] &= ~WEOS_BIT;
        /* Decay Ramp */
        uramp( (&gzcombcal_mem[gzcombcal_indx]),
               (pw_gzcombcald/per_gzcombcal),
               ia_gzcombcalwb, (short) 0, pg_beta );

        /* Create pulse and memory */
        pulsename( &gzcombcal, "gzcombcal" );
        createreserve( &gzcombcal, (WF_PROCESSOR)wg_gzcombcal, res_gzcombcal );
        createinstr( &gzcombcal,(LONG)(PosTemp+pw_gzcombcala-pw_gzcombcala - 
                                         pw_gzcombcalf),
                     (pw_gzcombcalf + pw_gzcombcala + 
                      pw_gzcombcal + pw_gzcombcald), 
                     ia_gzcombcal );
        /* Move user pulse into waveform mem */
        gzcombcal_mem[res_gzcombcal-1] |= WEOS_BIT;  
        movewaveimm(gzcombcal_mem, &gzcombcal, 
                    (int)0, res_gzcombcal, TOHARDWARE);
        if ((wg_gzcombcal==TYPRHO1)||(wg_gzcombcal==TYPRHO2))
        {				/* Add rf control bits if rf pulse */
            addrfbits(&gzcombcal,0,(LONG)(PosTemp+pw_gzcombcala),
                      (pw_gzcombcala + pw_gzcombcal + pw_gzcombcald));
        }
#elif defined(HOST_TGT)
        /* When the SINGLE_TRAP macro is expanded on the Host, we want a real
           trapezoid (a TRAPEZOID2) to be created instead. Note that the start
           and end amplitudes are not provided as arguments to this macro and
           are assumed to be zero. Also, the position of the trapezoid does
           not include the attack and leading parts. This is the same thing 
           that is done in the uramp() calls above. - GFN - 12/Aug/1998 */
        trapezoid( (WF_PROCESSOR)wg_gzcombcal, "gzcombcal",
                   &gzcombcal, &gzcombcala, &gzcombcald,
                   pw_gzcombcal, pw_gzcombcala, pw_gzcombcald,
                   ia_gzcombcal, ia_gzcombcalwa, ia_gzcombcalwb,
                   0 /* trp_start */, 0 /* trp_end */,
                   (LONG)(PosTemp+pw_gzcombcala - pw_gzcombcala - pw_gzcombcalf),
                   TRAP_ALL_SLOPED, &calloggrd );
#endif
    }


    /* Z rewinder */
    PosTemp = RUP_GRD(pend(&gzrf1cal, "gzrf1cal", 0) - calt_exb + te_cal + tacq_cal/2 + pw_gzprcala);
       
    {
#if defined(IPG_TGT) || defined(MGD_TGT)
        s16 gzprcal_mem[res_gzprcal];
        s16 gzprcal_indx = 0;       /* indx into user memory */

        getbeta(&pg_beta, (WF_PROCESSOR)wg_gzprcal, &calloggrd);

        /* leading edge of zeros */
        if ((0 != 0) && (pw_gzprcalf != 0))
        {
            uramp( (&gzprcal_mem[gzprcal_indx]),
                   (pw_gzprcalf/per_gzprcal),
                   (short)0, (short)0, pg_beta );
            /* Clear EOW */
            gzprcal_indx = ( pw_gzprcalf/ per_gzprcal );
            gzprcal_mem[gzprcal_indx-1] &= ~WEOS_BIT;
        }
        /* Up ramp */
        uramp( (&gzprcal_mem[gzprcal_indx]),
               (pw_gzprcala/per_gzprcal),
               (short) 0, ia_gzprcalwa , pg_beta);
        /* Clear EOW */
        gzprcal_indx = ( (pw_gzprcala + pw_gzprcalf)/ per_gzprcal );
        gzprcal_mem[gzprcal_indx-1] &= ~WEOS_BIT;
        /* Top const */
        uramp((&gzprcal_mem[gzprcal_indx]),
              (pw_gzprcal/per_gzprcal),
              ia_gzprcalwa, ia_gzprcalwb, pg_beta);
        /* Clear EOW */
        gzprcal_indx = ( (pw_gzprcala + pw_gzprcal + pw_gzprcalf )/ per_gzprcal );
        gzprcal_mem[gzprcal_indx-1] &= ~WEOS_BIT;
        /* Decay Ramp */
        uramp( (&gzprcal_mem[gzprcal_indx]),
               (pw_gzprcald/per_gzprcal),
               ia_gzprcalwb, (short) 0, pg_beta );

        /* Create pulse and memory */
        pulsename( &gzprcal, "gzprcal" );
        createreserve( &gzprcal, (WF_PROCESSOR)wg_gzprcal, res_gzprcal );
        createinstr( &gzprcal,(LONG)(PosTemp-pw_gzprcala - 
                                         pw_gzprcalf),
                     (pw_gzprcalf + pw_gzprcala + 
                      pw_gzprcal + pw_gzprcald), 
                     ia_gzprcal );
        /* Move user pulse into waveform mem */
        gzprcal_mem[res_gzprcal-1] |= WEOS_BIT;  
        movewaveimm(gzprcal_mem, &gzprcal, 
                    (int)0, res_gzprcal, TOHARDWARE);
        if ((wg_gzprcal==TYPRHO1)||(wg_gzprcal==TYPRHO2))
        {				/* Add rf control bits if rf pulse */
            addrfbits(&gzprcal,0,(LONG)(PosTemp),
                      (pw_gzprcala + pw_gzprcal + pw_gzprcald));
        }
#elif defined(HOST_TGT)
        /* When the SINGLE_TRAP macro is expanded on the Host, we want a real
           trapezoid (a TRAPEZOID2) to be created instead. Note that the start
           and end amplitudes are not provided as arguments to this macro and
           are assumed to be zero. Also, the position of the trapezoid does
           not include the attack and leading parts. This is the same thing 
           that is done in the uramp() calls above. - GFN - 12/Aug/1998 */
        trapezoid( (WF_PROCESSOR)wg_gzprcal, "gzprcal",
                   &gzprcal, &gzprcala, &gzprcald,
                   pw_gzprcal, pw_gzprcala, pw_gzprcald,
                   ia_gzprcal, ia_gzprcalwa, ia_gzprcalwb,
                   0 /* trp_start */, 0 /* trp_end */,
                   (LONG)(PosTemp - pw_gzprcala - pw_gzprcalf),
                   TRAP_ALL_SLOPED, &calloggrd );
#endif
    }



    /* *******************************************
     * X Dephaser, Readout, and Data Acquisition
     * ***************************************** */
    PosTemp = RUP_GRD(pend(&gzrf1cal, "gzrf1cal", 0) - calt_exb + te_cal - tacq_cal/2); /* from TE */
         

    setWaveformPurpose(gxwcala, gxwcal.purpose);
    setWaveformPurpose(gxwcald, gxwcal.purpose);
    trapezoid((WF_PROCESSOR)wg_gxwcal, "gxwcal", &gxwcal, &gxwcala,
              &gxwcald, pw_gxwcal, pw_gxwcala, pw_gxwcald,
              ia_gxwcal, 0, 0, 0, 0, PosTemp-pw_gxwcala, TRAP_ALL,
              &calloggrd);


    DabSetUp = IMax(2,DABSETUP,(fast_xtr+XTR_length[bd_index]+DAB_length[bd_index]));
    PosDabPkt = RUP_GRD(PosTemp+psd_grd_wait-DabSetUp);
    PosXtrPkt = RUP_GRD(PosTemp+psd_grd_wait-XTR_length[bd_index]-fast_xtr);

        
    {
        pulsename(&echo1cal,"echo1cal");
        acqq(&echo1cal, (long)(PosTemp+psd_grd_wait),(long)(PosDabPkt),
             (long)(PosXtrPkt),(long)filter_echo1cal,
             (TYPDAB_PACKETS)DABNORM);
    }


    /* ***************************************
        Create the 3d packet
       ***************************************** */
      
  {
    pulsename(&d3dcal,"d3dcal");
    create3dim(&d3dcal,(long)(PosTemp+psd_grd_wait),(long)(PosDabPkt+DAB_length[bd_index]));
  }



    PosTemp = RUP_GRD(pbegall(&gxwcal, 0) - (pw_gx1cal + pw_gx1cald));

              
    {
#if defined(IPG_TGT) || defined(MGD_TGT)
        s16 gx1cal_mem[res_gx1cal];
        s16 gx1cal_indx = 0;       /* indx into user memory */

        getbeta(&pg_beta, (WF_PROCESSOR)wg_gx1cal, &calloggrd);

        /* leading edge of zeros */
        if ((0 != 0) && (pw_gx1calf != 0))
        {
            uramp( (&gx1cal_mem[gx1cal_indx]),
                   (pw_gx1calf/per_gx1cal),
                   (short)0, (short)0, pg_beta );
            /* Clear EOW */
            gx1cal_indx = ( pw_gx1calf/ per_gx1cal );
            gx1cal_mem[gx1cal_indx-1] &= ~WEOS_BIT;
        }
        /* Up ramp */
        uramp( (&gx1cal_mem[gx1cal_indx]),
               (pw_gx1cala/per_gx1cal),
               (short) 0, ia_gx1calwa , pg_beta);
        /* Clear EOW */
        gx1cal_indx = ( (pw_gx1cala + pw_gx1calf)/ per_gx1cal );
        gx1cal_mem[gx1cal_indx-1] &= ~WEOS_BIT;
        /* Top const */
        uramp((&gx1cal_mem[gx1cal_indx]),
              (pw_gx1cal/per_gx1cal),
              ia_gx1calwa, ia_gx1calwb, pg_beta);
        /* Clear EOW */
        gx1cal_indx = ( (pw_gx1cala + pw_gx1cal + pw_gx1calf )/ per_gx1cal );
        gx1cal_mem[gx1cal_indx-1] &= ~WEOS_BIT;
        /* Decay Ramp */
        uramp( (&gx1cal_mem[gx1cal_indx]),
               (pw_gx1cald/per_gx1cal),
               ia_gx1calwb, (short) 0, pg_beta );

        /* Create pulse and memory */
        pulsename( &gx1cal, "gx1cal" );
        createreserve( &gx1cal, (WF_PROCESSOR)wg_gx1cal, res_gx1cal );
        createinstr( &gx1cal,(LONG)(PosTemp-pw_gx1cala - 
                                         pw_gx1calf),
                     (pw_gx1calf + pw_gx1cala + 
                      pw_gx1cal + pw_gx1cald), 
                     ia_gx1cal );
        /* Move user pulse into waveform mem */
        gx1cal_mem[res_gx1cal-1] |= WEOS_BIT;  
        movewaveimm(gx1cal_mem, &gx1cal, 
                    (int)0, res_gx1cal, TOHARDWARE);
        if ((wg_gx1cal==TYPRHO1)||(wg_gx1cal==TYPRHO2))
        {				/* Add rf control bits if rf pulse */
            addrfbits(&gx1cal,0,(LONG)(PosTemp),
                      (pw_gx1cala + pw_gx1cal + pw_gx1cald));
        }
#elif defined(HOST_TGT)
        /* When the SINGLE_TRAP macro is expanded on the Host, we want a real
           trapezoid (a TRAPEZOID2) to be created instead. Note that the start
           and end amplitudes are not provided as arguments to this macro and
           are assumed to be zero. Also, the position of the trapezoid does
           not include the attack and leading parts. This is the same thing 
           that is done in the uramp() calls above. - GFN - 12/Aug/1998 */
        trapezoid( (WF_PROCESSOR)wg_gx1cal, "gx1cal",
                   &gx1cal, &gx1cala, &gx1cald,
                   pw_gx1cal, pw_gx1cala, pw_gx1cald,
                   ia_gx1cal, ia_gx1calwa, ia_gx1calwb,
                   0 /* trp_start */, 0 /* trp_end */,
                   (LONG)(PosTemp - pw_gx1cala - pw_gx1calf),
                   TRAP_ALL, &calloggrd );
#endif
    }


    /* *******************************************
     * Y phase encode and rewind
     * *******************************************/
    PosTemp = RUP_GRD((INT)(pend(&gzrf1cal,"gzrf1cal",0)));
      
    {
#if defined(IPG_TGT) || defined(MGD_TGT)
        s16 gy1cal_mem[res_gy1cal];
        s16 gy1cal_indx = 0;       /* indx into user memory */

        getbeta(&pg_beta, (WF_PROCESSOR)wg_gy1cal, &calloggrd);

        /* leading edge of zeros */
        if ((0 != 0) && (pw_gy1calf != 0))
        {
            uramp( (&gy1cal_mem[gy1cal_indx]),
                   (pw_gy1calf/per_gy1cal),
                   (short)0, (short)0, pg_beta );
            /* Clear EOW */
            gy1cal_indx = ( pw_gy1calf/ per_gy1cal );
            gy1cal_mem[gy1cal_indx-1] &= ~WEOS_BIT;
        }
        /* Up ramp */
        uramp( (&gy1cal_mem[gy1cal_indx]),
               (pw_gy1cala/per_gy1cal),
               (short) 0, ia_gy1calwa , pg_beta);
        /* Clear EOW */
        gy1cal_indx = ( (pw_gy1cala + pw_gy1calf)/ per_gy1cal );
        gy1cal_mem[gy1cal_indx-1] &= ~WEOS_BIT;
        /* Top const */
        uramp((&gy1cal_mem[gy1cal_indx]),
              (pw_gy1cal/per_gy1cal),
              ia_gy1calwa, ia_gy1calwb, pg_beta);
        /* Clear EOW */
        gy1cal_indx = ( (pw_gy1cala + pw_gy1cal + pw_gy1calf )/ per_gy1cal );
        gy1cal_mem[gy1cal_indx-1] &= ~WEOS_BIT;
        /* Decay Ramp */
        uramp( (&gy1cal_mem[gy1cal_indx]),
               (pw_gy1cald/per_gy1cal),
               ia_gy1calwb, (short) 0, pg_beta );

        /* Create pulse and memory */
        pulsename( &gy1cal, "gy1cal" );
        createreserve( &gy1cal, (WF_PROCESSOR)wg_gy1cal, res_gy1cal );
        createinstr( &gy1cal,(LONG)(PosTemp+pw_gy1cala-pw_gy1cala - 
                                         pw_gy1calf),
                     (pw_gy1calf + pw_gy1cala + 
                      pw_gy1cal + pw_gy1cald), 
                     ia_gy1cal );
        /* Move user pulse into waveform mem */
        gy1cal_mem[res_gy1cal-1] |= WEOS_BIT;  
        movewaveimm(gy1cal_mem, &gy1cal, 
                    (int)0, res_gy1cal, TOHARDWARE);
        if ((wg_gy1cal==TYPRHO1)||(wg_gy1cal==TYPRHO2))
        {				/* Add rf control bits if rf pulse */
            addrfbits(&gy1cal,0,(LONG)(PosTemp+pw_gy1cala),
                      (pw_gy1cala + pw_gy1cal + pw_gy1cald));
        }
#elif defined(HOST_TGT)
        /* When the SINGLE_TRAP macro is expanded on the Host, we want a real
           trapezoid (a TRAPEZOID2) to be created instead. Note that the start
           and end amplitudes are not provided as arguments to this macro and
           are assumed to be zero. Also, the position of the trapezoid does
           not include the attack and leading parts. This is the same thing 
           that is done in the uramp() calls above. - GFN - 12/Aug/1998 */
        trapezoid( (WF_PROCESSOR)wg_gy1cal, "gy1cal",
                   &gy1cal, &gy1cala, &gy1cald,
                   pw_gy1cal, pw_gy1cala, pw_gy1cald,
                   ia_gy1cal, ia_gy1calwa, ia_gy1calwb,
                   0 /* trp_start */, 0 /* trp_end */,
                   (LONG)(PosTemp+pw_gy1cala - pw_gy1cala - pw_gy1calf),
                   TRAP_ALL_SLOPED, &calloggrd );
#endif
    }


    PosTemp = RUP_GRD(pbeg(&gxwcal,"gxwcal", 0) + tacq_cal);
      
    {
#if defined(IPG_TGT) || defined(MGD_TGT)
        s16 gy1rcal_mem[res_gy1rcal];
        s16 gy1rcal_indx = 0;       /* indx into user memory */

        getbeta(&pg_beta, (WF_PROCESSOR)wg_gy1rcal, &calloggrd);

        /* leading edge of zeros */
        if ((0 != 0) && (pw_gy1rcalf != 0))
        {
            uramp( (&gy1rcal_mem[gy1rcal_indx]),
                   (pw_gy1rcalf/per_gy1rcal),
                   (short)0, (short)0, pg_beta );
            /* Clear EOW */
            gy1rcal_indx = ( pw_gy1rcalf/ per_gy1rcal );
            gy1rcal_mem[gy1rcal_indx-1] &= ~WEOS_BIT;
        }
        /* Up ramp */
        uramp( (&gy1rcal_mem[gy1rcal_indx]),
               (pw_gy1rcala/per_gy1rcal),
               (short) 0, ia_gy1rcalwa , pg_beta);
        /* Clear EOW */
        gy1rcal_indx = ( (pw_gy1rcala + pw_gy1rcalf)/ per_gy1rcal );
        gy1rcal_mem[gy1rcal_indx-1] &= ~WEOS_BIT;
        /* Top const */
        uramp((&gy1rcal_mem[gy1rcal_indx]),
              (pw_gy1rcal/per_gy1rcal),
              ia_gy1rcalwa, ia_gy1rcalwb, pg_beta);
        /* Clear EOW */
        gy1rcal_indx = ( (pw_gy1rcala + pw_gy1rcal + pw_gy1rcalf )/ per_gy1rcal );
        gy1rcal_mem[gy1rcal_indx-1] &= ~WEOS_BIT;
        /* Decay Ramp */
        uramp( (&gy1rcal_mem[gy1rcal_indx]),
               (pw_gy1rcald/per_gy1rcal),
               ia_gy1rcalwb, (short) 0, pg_beta );

        /* Create pulse and memory */
        pulsename( &gy1rcal, "gy1rcal" );
        createreserve( &gy1rcal, (WF_PROCESSOR)wg_gy1rcal, res_gy1rcal );
        createinstr( &gy1rcal,(LONG)(PosTemp+pw_gy1rcala-pw_gy1rcala - 
                                         pw_gy1rcalf),
                     (pw_gy1rcalf + pw_gy1rcala + 
                      pw_gy1rcal + pw_gy1rcald), 
                     ia_gy1rcal );
        /* Move user pulse into waveform mem */
        gy1rcal_mem[res_gy1rcal-1] |= WEOS_BIT;  
        movewaveimm(gy1rcal_mem, &gy1rcal, 
                    (int)0, res_gy1rcal, TOHARDWARE);
        if ((wg_gy1rcal==TYPRHO1)||(wg_gy1rcal==TYPRHO2))
        {				/* Add rf control bits if rf pulse */
            addrfbits(&gy1rcal,0,(LONG)(PosTemp+pw_gy1rcala),
                      (pw_gy1rcala + pw_gy1rcal + pw_gy1rcald));
        }
#elif defined(HOST_TGT)
        /* When the SINGLE_TRAP macro is expanded on the Host, we want a real
           trapezoid (a TRAPEZOID2) to be created instead. Note that the start
           and end amplitudes are not provided as arguments to this macro and
           are assumed to be zero. Also, the position of the trapezoid does
           not include the attack and leading parts. This is the same thing 
           that is done in the uramp() calls above. - GFN - 12/Aug/1998 */
        trapezoid( (WF_PROCESSOR)wg_gy1rcal, "gy1rcal",
                   &gy1rcal, &gy1rcala, &gy1rcald,
                   pw_gy1rcal, pw_gy1rcala, pw_gy1rcald,
                   ia_gy1rcal, ia_gy1rcalwa, ia_gy1rcalwb,
                   0 /* trp_start */, 0 /* trp_end */,
                   (LONG)(PosTemp+pw_gy1rcala - pw_gy1rcala - pw_gy1rcalf),
                   TRAP_ALL_SLOPED, &calloggrd );
#endif
    }



    /*****************************************
    * Attenuator lock
    * *****************************************/
     
    {
        pulsename(&attenuator_keycal,"attenuator_keycal");
        createatten(&attenuator_keycal, (long)(RUP_GRD(PosTemp+psd_grd_wait)));
    }


      
  {
    pulsename(&seqcal,"seqcal");
    createseq(&seqcal,RUP_GRD(tr_cal), off_seqcal);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqcal );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqcal = %d\n", idx_seqcal );
#endif
  }

    attenflagon(&seqcal, 0);

    PosTemp = 10000;  /* time to make sure last processing is complete */

    
  {
    pulsename(&d3dpasscal,"d3dpasscal");
    create3dim(&d3dpasscal,(long)(0),(long)(PosTemp));
  }

       
  {
    pulsename(&pass_pulsecal,"pass_pulsecal");
    createpass(&pass_pulsecal,(long)(RUP_GRD(PSTR_PASS-1000)));
  }

          
  {
    pulsename(&seqcalpass,"seqcalpass");
    createseq(&seqcalpass,RUP_GRD(PosTemp+PSTR_PASS-time_ssical), off_seqcalpass);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqcalpass );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqcalpass = %d\n", idx_seqcalpass );
#endif
  }


    return SUCCESS;
}   /* End of ExtCalpulsegen */


/*
 *  AutoCoilpulsegen
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
AutoCoilpulsegen( void )
{
    INT PosStart;
    INT PosTemp;
    INT DabSetUp, PosDabPkt, PosXtrPkt;

    /* set slice encoding to full scale */
    ia_gzcombcoilwa = (int)(PSDRAMPEDTRAP*max_pg_wamp);
    ia_gzcombcoilwb = max_pg_wamp;
    
    ia_gzprcoilwa = (int)(PSDRAMPEDTRAP*max_pg_wamp);
    ia_gzprcoilwb = max_pg_wamp;

    /* selective RF1 */
    PosStart = td0coil + pw_gzrf1coila;

         
               
  {
        INT old_res =  res_rf1coil; /* temp holder for old pulse resolution */

    if ( (wg_rf1coil != TYPRHO1)  && (wg_rf1coil != TYPRHO2) &&
         (wg_rf1coil != TYPTHETA) && (wg_rf1coil != TYPOMEGA) ) {

        fprintf( stderr, "EXTWAVE2 macro must create pulses on RHO1 or RHO2.\n");
        fflush( stderr );

        return FAILURE;
    }

    n_rf1coil += 1;  /* Increment counter */

    /*** Read in waveform if it has not been created yet ***/

    if( rf1coil.ninsts == 0 ) {        

        /* Set pulsename */
        pulsename(&rf1coil,"rf1coil");
        
        /* Scale waveform if needed */
            if( rfpulseInfo[rfslot_rf1coil].change==PSD_ON )
            {
                INT new_res =  rfpulseInfo[rfslot_rf1coil].newres;

            /* ***************************************************************
             *  Create some board waveform space, scale the pulse, and then
             *  move the local memory to the reserved board memory, and set
             *  pulsepointers to new stretched pulse.
             *
             *  Now create the rf pulse & perform required system safety
             *  checks and create a temporary buffer for the stretched RF
             *  pulse. Stretch the pulse and copy stretched data into
             *  permanent waveform memory. It is important to have temp
             *  buffer have new resolution size waveform memory.
             *************************************************************** */

            /* Reserve waveform memory on the RF channel for
               stretched RF pulse */
            createreserve(&rf1coil, (WF_PROCESSOR)wg_rf1coil, new_res);

                movestretchedwave( fileloc_rf1coil, old_res,
                                   &rf1coil, 0, new_res );
            
            /*  Set the resolution of the RF pulse to the resolution of the
             *  stretched RF pulse.  This is done becaused the createinstr()
             *  access the RF pulse structure, which contains a reference to
             *  the resolution of the RF pulse.  When the instruction is
             *  created it must contain the resolution of the stretched RF
             *  pulse.
             */
            res_rf1coil = new_res;
        } else {
            
            /* No rf scaling required. Use createextwave
               to read pulse and move to HW.             */ 
            createextwave(&rf1coil,(WF_PROCESSOR)wg_rf1coil,
                          old_res,fileloc_rf1coil);
        }
    }


    /*** Create Instruction Node ***/
    createinstr( &rf1coil,(LONG)(PosStart) + psd_rf_wait, 
                 pw_rf1coil,ia_rf1coil);
    

    /*** Add RF Bits ***/
    addrfbits(&rf1coil,off_rf1coil,(LONG)(PosStart) + psd_rf_wait,
              pw_rf1coil);
    

    /*** Reset Resolution ***/
    res_rf1coil = old_res;
    /* Reset the resolution of the RF pulse to the original
       (unstretched) resolution. This is necessary to allow this macro
       to be called multiple times. */
  }


    setiamp(ia_rf1coil, &rf1coil, 0);

    /* Z slice selective for rf1 */
       
               

    setWaveformPurpose(gzrf1coila, gzrf1coil.purpose);
    setWaveformPurpose(gzrf1coild, gzrf1coil.purpose);
    trapezoid((WF_PROCESSOR)wg_gzrf1coil, "gzrf1coil", &gzrf1coil, &gzrf1coila,
              &gzrf1coild, pw_gzrf1coil, pw_gzrf1coila, pw_gzrf1coild,
              ia_gzrf1coil, 0, 0, 0, 0, pbeg(&rf1coil,"rf1coil",0)-psd_rf_wait-pw_gzrf1coila, TRAP_ALL,
              &coilloggrd);


    PosTemp = RUP_GRD(pend(&gzrf1coil, "gzrf1coil", 0) + pw_gzrf1coild);
      
    {
#if defined(IPG_TGT) || defined(MGD_TGT)
        s16 gzcombcoil_mem[res_gzcombcoil];
        s16 gzcombcoil_indx = 0;       /* indx into user memory */

        getbeta(&pg_beta, (WF_PROCESSOR)wg_gzcombcoil, &coilloggrd);

        /* leading edge of zeros */
        if ((0 != 0) && (pw_gzcombcoilf != 0))
        {
            uramp( (&gzcombcoil_mem[gzcombcoil_indx]),
                   (pw_gzcombcoilf/per_gzcombcoil),
                   (short)0, (short)0, pg_beta );
            /* Clear EOW */
            gzcombcoil_indx = ( pw_gzcombcoilf/ per_gzcombcoil );
            gzcombcoil_mem[gzcombcoil_indx-1] &= ~WEOS_BIT;
        }
        /* Up ramp */
        uramp( (&gzcombcoil_mem[gzcombcoil_indx]),
               (pw_gzcombcoila/per_gzcombcoil),
               (short) 0, ia_gzcombcoilwa , pg_beta);
        /* Clear EOW */
        gzcombcoil_indx = ( (pw_gzcombcoila + pw_gzcombcoilf)/ per_gzcombcoil );
        gzcombcoil_mem[gzcombcoil_indx-1] &= ~WEOS_BIT;
        /* Top const */
        uramp((&gzcombcoil_mem[gzcombcoil_indx]),
              (pw_gzcombcoil/per_gzcombcoil),
              ia_gzcombcoilwa, ia_gzcombcoilwb, pg_beta);
        /* Clear EOW */
        gzcombcoil_indx = ( (pw_gzcombcoila + pw_gzcombcoil + pw_gzcombcoilf )/ per_gzcombcoil );
        gzcombcoil_mem[gzcombcoil_indx-1] &= ~WEOS_BIT;
        /* Decay Ramp */
        uramp( (&gzcombcoil_mem[gzcombcoil_indx]),
               (pw_gzcombcoild/per_gzcombcoil),
               ia_gzcombcoilwb, (short) 0, pg_beta );

        /* Create pulse and memory */
        pulsename( &gzcombcoil, "gzcombcoil" );
        createreserve( &gzcombcoil, (WF_PROCESSOR)wg_gzcombcoil, res_gzcombcoil );
        createinstr( &gzcombcoil,(LONG)(PosTemp+pw_gzcombcoila-pw_gzcombcoila - 
                                         pw_gzcombcoilf),
                     (pw_gzcombcoilf + pw_gzcombcoila + 
                      pw_gzcombcoil + pw_gzcombcoild), 
                     ia_gzcombcoil );
        /* Move user pulse into waveform mem */
        gzcombcoil_mem[res_gzcombcoil-1] |= WEOS_BIT;  
        movewaveimm(gzcombcoil_mem, &gzcombcoil, 
                    (int)0, res_gzcombcoil, TOHARDWARE);
        if ((wg_gzcombcoil==TYPRHO1)||(wg_gzcombcoil==TYPRHO2))
        {				/* Add rf control bits if rf pulse */
            addrfbits(&gzcombcoil,0,(LONG)(PosTemp+pw_gzcombcoila),
                      (pw_gzcombcoila + pw_gzcombcoil + pw_gzcombcoild));
        }
#elif defined(HOST_TGT)
        /* When the SINGLE_TRAP macro is expanded on the Host, we want a real
           trapezoid (a TRAPEZOID2) to be created instead. Note that the start
           and end amplitudes are not provided as arguments to this macro and
           are assumed to be zero. Also, the position of the trapezoid does
           not include the attack and leading parts. This is the same thing 
           that is done in the uramp() calls above. - GFN - 12/Aug/1998 */
        trapezoid( (WF_PROCESSOR)wg_gzcombcoil, "gzcombcoil",
                   &gzcombcoil, &gzcombcoila, &gzcombcoild,
                   pw_gzcombcoil, pw_gzcombcoila, pw_gzcombcoild,
                   ia_gzcombcoil, ia_gzcombcoilwa, ia_gzcombcoilwb,
                   0 /* trp_start */, 0 /* trp_end */,
                   (LONG)(PosTemp+pw_gzcombcoila - pw_gzcombcoila - pw_gzcombcoilf),
                   TRAP_ALL_SLOPED, &coilloggrd );
#endif
    }


    /* Z rewinder */
    PosTemp = RUP_GRD(pend(&gzrf1coil, "gzrf1coil", 0) - coilt_exb + te_coil + tacq_coil/2 + pw_gzprcoila);
       
    {
#if defined(IPG_TGT) || defined(MGD_TGT)
        s16 gzprcoil_mem[res_gzprcoil];
        s16 gzprcoil_indx = 0;       /* indx into user memory */

        getbeta(&pg_beta, (WF_PROCESSOR)wg_gzprcoil, &coilloggrd);

        /* leading edge of zeros */
        if ((0 != 0) && (pw_gzprcoilf != 0))
        {
            uramp( (&gzprcoil_mem[gzprcoil_indx]),
                   (pw_gzprcoilf/per_gzprcoil),
                   (short)0, (short)0, pg_beta );
            /* Clear EOW */
            gzprcoil_indx = ( pw_gzprcoilf/ per_gzprcoil );
            gzprcoil_mem[gzprcoil_indx-1] &= ~WEOS_BIT;
        }
        /* Up ramp */
        uramp( (&gzprcoil_mem[gzprcoil_indx]),
               (pw_gzprcoila/per_gzprcoil),
               (short) 0, ia_gzprcoilwa , pg_beta);
        /* Clear EOW */
        gzprcoil_indx = ( (pw_gzprcoila + pw_gzprcoilf)/ per_gzprcoil );
        gzprcoil_mem[gzprcoil_indx-1] &= ~WEOS_BIT;
        /* Top const */
        uramp((&gzprcoil_mem[gzprcoil_indx]),
              (pw_gzprcoil/per_gzprcoil),
              ia_gzprcoilwa, ia_gzprcoilwb, pg_beta);
        /* Clear EOW */
        gzprcoil_indx = ( (pw_gzprcoila + pw_gzprcoil + pw_gzprcoilf )/ per_gzprcoil );
        gzprcoil_mem[gzprcoil_indx-1] &= ~WEOS_BIT;
        /* Decay Ramp */
        uramp( (&gzprcoil_mem[gzprcoil_indx]),
               (pw_gzprcoild/per_gzprcoil),
               ia_gzprcoilwb, (short) 0, pg_beta );

        /* Create pulse and memory */
        pulsename( &gzprcoil, "gzprcoil" );
        createreserve( &gzprcoil, (WF_PROCESSOR)wg_gzprcoil, res_gzprcoil );
        createinstr( &gzprcoil,(LONG)(PosTemp-pw_gzprcoila - 
                                         pw_gzprcoilf),
                     (pw_gzprcoilf + pw_gzprcoila + 
                      pw_gzprcoil + pw_gzprcoild), 
                     ia_gzprcoil );
        /* Move user pulse into waveform mem */
        gzprcoil_mem[res_gzprcoil-1] |= WEOS_BIT;  
        movewaveimm(gzprcoil_mem, &gzprcoil, 
                    (int)0, res_gzprcoil, TOHARDWARE);
        if ((wg_gzprcoil==TYPRHO1)||(wg_gzprcoil==TYPRHO2))
        {				/* Add rf control bits if rf pulse */
            addrfbits(&gzprcoil,0,(LONG)(PosTemp),
                      (pw_gzprcoila + pw_gzprcoil + pw_gzprcoild));
        }
#elif defined(HOST_TGT)
        /* When the SINGLE_TRAP macro is expanded on the Host, we want a real
           trapezoid (a TRAPEZOID2) to be created instead. Note that the start
           and end amplitudes are not provided as arguments to this macro and
           are assumed to be zero. Also, the position of the trapezoid does
           not include the attack and leading parts. This is the same thing 
           that is done in the uramp() calls above. - GFN - 12/Aug/1998 */
        trapezoid( (WF_PROCESSOR)wg_gzprcoil, "gzprcoil",
                   &gzprcoil, &gzprcoila, &gzprcoild,
                   pw_gzprcoil, pw_gzprcoila, pw_gzprcoild,
                   ia_gzprcoil, ia_gzprcoilwa, ia_gzprcoilwb,
                   0 /* trp_start */, 0 /* trp_end */,
                   (LONG)(PosTemp - pw_gzprcoila - pw_gzprcoilf),
                   TRAP_ALL_SLOPED, &coilloggrd );
#endif
    }



    /* *******************************************
     * X Dephaser, Readout, and Data Acquisition
     * ***************************************** */
    PosTemp = RUP_GRD(pend(&gzrf1coil, "gzrf1coil", 0) - coilt_exb + te_coil - tacq_coil/2);
         

    setWaveformPurpose(gxwcoila, gxwcoil.purpose);
    setWaveformPurpose(gxwcoild, gxwcoil.purpose);
    trapezoid((WF_PROCESSOR)wg_gxwcoil, "gxwcoil", &gxwcoil, &gxwcoila,
              &gxwcoild, pw_gxwcoil, pw_gxwcoila, pw_gxwcoild,
              ia_gxwcoil, 0, 0, 0, 0, PosTemp-pw_gxwcoila, TRAP_ALL,
              &coilloggrd);


    DabSetUp = IMax(2,DABSETUP,(fast_xtr+XTR_length[bd_index]+DAB_length[bd_index]));
    PosDabPkt = RUP_GRD(PosTemp+psd_grd_wait-DabSetUp);
    PosXtrPkt = RUP_GRD(PosTemp+psd_grd_wait-XTR_length[bd_index]-fast_xtr);

        
    {
        pulsename(&echo1coil,"echo1coil");
        acqq(&echo1coil, (long)(PosTemp+psd_grd_wait),(long)(PosDabPkt),
             (long)(PosXtrPkt),(long)filter_echo1coil,
             (TYPDAB_PACKETS)DABNORM);
    }


    /* ***************************************
        Create the 3d packet
       ***************************************** */
      
  {
    pulsename(&d3dcoil,"d3dcoil");
    create3dim(&d3dcoil,(long)(PosTemp+psd_grd_wait),(long)(PosDabPkt+DAB_length[bd_index]));
  }



    PosTemp = RUP_GRD(pbegall(&gxwcoil, 0) - (pw_gx1coil + pw_gx1coild));

              
    {
#if defined(IPG_TGT) || defined(MGD_TGT)
        s16 gx1coil_mem[res_gx1coil];
        s16 gx1coil_indx = 0;       /* indx into user memory */

        getbeta(&pg_beta, (WF_PROCESSOR)wg_gx1coil, &coilloggrd);

        /* leading edge of zeros */
        if ((0 != 0) && (pw_gx1coilf != 0))
        {
            uramp( (&gx1coil_mem[gx1coil_indx]),
                   (pw_gx1coilf/per_gx1coil),
                   (short)0, (short)0, pg_beta );
            /* Clear EOW */
            gx1coil_indx = ( pw_gx1coilf/ per_gx1coil );
            gx1coil_mem[gx1coil_indx-1] &= ~WEOS_BIT;
        }
        /* Up ramp */
        uramp( (&gx1coil_mem[gx1coil_indx]),
               (pw_gx1coila/per_gx1coil),
               (short) 0, ia_gx1coilwa , pg_beta);
        /* Clear EOW */
        gx1coil_indx = ( (pw_gx1coila + pw_gx1coilf)/ per_gx1coil );
        gx1coil_mem[gx1coil_indx-1] &= ~WEOS_BIT;
        /* Top const */
        uramp((&gx1coil_mem[gx1coil_indx]),
              (pw_gx1coil/per_gx1coil),
              ia_gx1coilwa, ia_gx1coilwb, pg_beta);
        /* Clear EOW */
        gx1coil_indx = ( (pw_gx1coila + pw_gx1coil + pw_gx1coilf )/ per_gx1coil );
        gx1coil_mem[gx1coil_indx-1] &= ~WEOS_BIT;
        /* Decay Ramp */
        uramp( (&gx1coil_mem[gx1coil_indx]),
               (pw_gx1coild/per_gx1coil),
               ia_gx1coilwb, (short) 0, pg_beta );

        /* Create pulse and memory */
        pulsename( &gx1coil, "gx1coil" );
        createreserve( &gx1coil, (WF_PROCESSOR)wg_gx1coil, res_gx1coil );
        createinstr( &gx1coil,(LONG)(PosTemp-pw_gx1coila - 
                                         pw_gx1coilf),
                     (pw_gx1coilf + pw_gx1coila + 
                      pw_gx1coil + pw_gx1coild), 
                     ia_gx1coil );
        /* Move user pulse into waveform mem */
        gx1coil_mem[res_gx1coil-1] |= WEOS_BIT;  
        movewaveimm(gx1coil_mem, &gx1coil, 
                    (int)0, res_gx1coil, TOHARDWARE);
        if ((wg_gx1coil==TYPRHO1)||(wg_gx1coil==TYPRHO2))
        {				/* Add rf control bits if rf pulse */
            addrfbits(&gx1coil,0,(LONG)(PosTemp),
                      (pw_gx1coila + pw_gx1coil + pw_gx1coild));
        }
#elif defined(HOST_TGT)
        /* When the SINGLE_TRAP macro is expanded on the Host, we want a real
           trapezoid (a TRAPEZOID2) to be created instead. Note that the start
           and end amplitudes are not provided as arguments to this macro and
           are assumed to be zero. Also, the position of the trapezoid does
           not include the attack and leading parts. This is the same thing 
           that is done in the uramp() calls above. - GFN - 12/Aug/1998 */
        trapezoid( (WF_PROCESSOR)wg_gx1coil, "gx1coil",
                   &gx1coil, &gx1coila, &gx1coild,
                   pw_gx1coil, pw_gx1coila, pw_gx1coild,
                   ia_gx1coil, ia_gx1coilwa, ia_gx1coilwb,
                   0 /* trp_start */, 0 /* trp_end */,
                   (LONG)(PosTemp - pw_gx1coila - pw_gx1coilf),
                   TRAP_ALL, &coilloggrd );
#endif
    }


    /* *******************************************
     * Y phase encode and rewind
     * *******************************************/
    PosTemp = RUP_GRD((INT)(pend(&gzrf1coil,"gzrf1coil",0)));
      
    {
#if defined(IPG_TGT) || defined(MGD_TGT)
        s16 gy1coil_mem[res_gy1coil];
        s16 gy1coil_indx = 0;       /* indx into user memory */

        getbeta(&pg_beta, (WF_PROCESSOR)wg_gy1coil, &coilloggrd);

        /* leading edge of zeros */
        if ((0 != 0) && (pw_gy1coilf != 0))
        {
            uramp( (&gy1coil_mem[gy1coil_indx]),
                   (pw_gy1coilf/per_gy1coil),
                   (short)0, (short)0, pg_beta );
            /* Clear EOW */
            gy1coil_indx = ( pw_gy1coilf/ per_gy1coil );
            gy1coil_mem[gy1coil_indx-1] &= ~WEOS_BIT;
        }
        /* Up ramp */
        uramp( (&gy1coil_mem[gy1coil_indx]),
               (pw_gy1coila/per_gy1coil),
               (short) 0, ia_gy1coilwa , pg_beta);
        /* Clear EOW */
        gy1coil_indx = ( (pw_gy1coila + pw_gy1coilf)/ per_gy1coil );
        gy1coil_mem[gy1coil_indx-1] &= ~WEOS_BIT;
        /* Top const */
        uramp((&gy1coil_mem[gy1coil_indx]),
              (pw_gy1coil/per_gy1coil),
              ia_gy1coilwa, ia_gy1coilwb, pg_beta);
        /* Clear EOW */
        gy1coil_indx = ( (pw_gy1coila + pw_gy1coil + pw_gy1coilf )/ per_gy1coil );
        gy1coil_mem[gy1coil_indx-1] &= ~WEOS_BIT;
        /* Decay Ramp */
        uramp( (&gy1coil_mem[gy1coil_indx]),
               (pw_gy1coild/per_gy1coil),
               ia_gy1coilwb, (short) 0, pg_beta );

        /* Create pulse and memory */
        pulsename( &gy1coil, "gy1coil" );
        createreserve( &gy1coil, (WF_PROCESSOR)wg_gy1coil, res_gy1coil );
        createinstr( &gy1coil,(LONG)(PosTemp+pw_gy1coila-pw_gy1coila - 
                                         pw_gy1coilf),
                     (pw_gy1coilf + pw_gy1coila + 
                      pw_gy1coil + pw_gy1coild), 
                     ia_gy1coil );
        /* Move user pulse into waveform mem */
        gy1coil_mem[res_gy1coil-1] |= WEOS_BIT;  
        movewaveimm(gy1coil_mem, &gy1coil, 
                    (int)0, res_gy1coil, TOHARDWARE);
        if ((wg_gy1coil==TYPRHO1)||(wg_gy1coil==TYPRHO2))
        {				/* Add rf control bits if rf pulse */
            addrfbits(&gy1coil,0,(LONG)(PosTemp+pw_gy1coila),
                      (pw_gy1coila + pw_gy1coil + pw_gy1coild));
        }
#elif defined(HOST_TGT)
        /* When the SINGLE_TRAP macro is expanded on the Host, we want a real
           trapezoid (a TRAPEZOID2) to be created instead. Note that the start
           and end amplitudes are not provided as arguments to this macro and
           are assumed to be zero. Also, the position of the trapezoid does
           not include the attack and leading parts. This is the same thing 
           that is done in the uramp() calls above. - GFN - 12/Aug/1998 */
        trapezoid( (WF_PROCESSOR)wg_gy1coil, "gy1coil",
                   &gy1coil, &gy1coila, &gy1coild,
                   pw_gy1coil, pw_gy1coila, pw_gy1coild,
                   ia_gy1coil, ia_gy1coilwa, ia_gy1coilwb,
                   0 /* trp_start */, 0 /* trp_end */,
                   (LONG)(PosTemp+pw_gy1coila - pw_gy1coila - pw_gy1coilf),
                   TRAP_ALL_SLOPED, &coilloggrd );
#endif
    }


    PosTemp = RUP_GRD(pbeg(&gxwcoil,"gxwcoil", 0) + tacq_coil);
      
    {
#if defined(IPG_TGT) || defined(MGD_TGT)
        s16 gy1rcoil_mem[res_gy1rcoil];
        s16 gy1rcoil_indx = 0;       /* indx into user memory */

        getbeta(&pg_beta, (WF_PROCESSOR)wg_gy1rcoil, &coilloggrd);

        /* leading edge of zeros */
        if ((0 != 0) && (pw_gy1rcoilf != 0))
        {
            uramp( (&gy1rcoil_mem[gy1rcoil_indx]),
                   (pw_gy1rcoilf/per_gy1rcoil),
                   (short)0, (short)0, pg_beta );
            /* Clear EOW */
            gy1rcoil_indx = ( pw_gy1rcoilf/ per_gy1rcoil );
            gy1rcoil_mem[gy1rcoil_indx-1] &= ~WEOS_BIT;
        }
        /* Up ramp */
        uramp( (&gy1rcoil_mem[gy1rcoil_indx]),
               (pw_gy1rcoila/per_gy1rcoil),
               (short) 0, ia_gy1rcoilwa , pg_beta);
        /* Clear EOW */
        gy1rcoil_indx = ( (pw_gy1rcoila + pw_gy1rcoilf)/ per_gy1rcoil );
        gy1rcoil_mem[gy1rcoil_indx-1] &= ~WEOS_BIT;
        /* Top const */
        uramp((&gy1rcoil_mem[gy1rcoil_indx]),
              (pw_gy1rcoil/per_gy1rcoil),
              ia_gy1rcoilwa, ia_gy1rcoilwb, pg_beta);
        /* Clear EOW */
        gy1rcoil_indx = ( (pw_gy1rcoila + pw_gy1rcoil + pw_gy1rcoilf )/ per_gy1rcoil );
        gy1rcoil_mem[gy1rcoil_indx-1] &= ~WEOS_BIT;
        /* Decay Ramp */
        uramp( (&gy1rcoil_mem[gy1rcoil_indx]),
               (pw_gy1rcoild/per_gy1rcoil),
               ia_gy1rcoilwb, (short) 0, pg_beta );

        /* Create pulse and memory */
        pulsename( &gy1rcoil, "gy1rcoil" );
        createreserve( &gy1rcoil, (WF_PROCESSOR)wg_gy1rcoil, res_gy1rcoil );
        createinstr( &gy1rcoil,(LONG)(PosTemp+pw_gy1rcoila-pw_gy1rcoila - 
                                         pw_gy1rcoilf),
                     (pw_gy1rcoilf + pw_gy1rcoila + 
                      pw_gy1rcoil + pw_gy1rcoild), 
                     ia_gy1rcoil );
        /* Move user pulse into waveform mem */
        gy1rcoil_mem[res_gy1rcoil-1] |= WEOS_BIT;  
        movewaveimm(gy1rcoil_mem, &gy1rcoil, 
                    (int)0, res_gy1rcoil, TOHARDWARE);
        if ((wg_gy1rcoil==TYPRHO1)||(wg_gy1rcoil==TYPRHO2))
        {				/* Add rf control bits if rf pulse */
            addrfbits(&gy1rcoil,0,(LONG)(PosTemp+pw_gy1rcoila),
                      (pw_gy1rcoila + pw_gy1rcoil + pw_gy1rcoild));
        }
#elif defined(HOST_TGT)
        /* When the SINGLE_TRAP macro is expanded on the Host, we want a real
           trapezoid (a TRAPEZOID2) to be created instead. Note that the start
           and end amplitudes are not provided as arguments to this macro and
           are assumed to be zero. Also, the position of the trapezoid does
           not include the attack and leading parts. This is the same thing 
           that is done in the uramp() calls above. - GFN - 12/Aug/1998 */
        trapezoid( (WF_PROCESSOR)wg_gy1rcoil, "gy1rcoil",
                   &gy1rcoil, &gy1rcoila, &gy1rcoild,
                   pw_gy1rcoil, pw_gy1rcoila, pw_gy1rcoild,
                   ia_gy1rcoil, ia_gy1rcoilwa, ia_gy1rcoilwb,
                   0 /* trp_start */, 0 /* trp_end */,
                   (LONG)(PosTemp+pw_gy1rcoila - pw_gy1rcoila - pw_gy1rcoilf),
                   TRAP_ALL_SLOPED, &coilloggrd );
#endif
    }



    /*****************************************
    * Attenuator lock
    * *****************************************/
     
    {
        pulsename(&attenuator_keycoil,"attenuator_keycoil");
        createatten(&attenuator_keycoil, (long)(RUP_GRD(PosTemp+psd_grd_wait)));
    }


      
  {
    pulsename(&seqcoil,"seqcoil");
    createseq(&seqcoil,RUP_GRD(tr_coil), off_seqcoil);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqcoil );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqcoil = %d\n", idx_seqcoil );
#endif
  }

    attenflagon(&seqcoil, 0);

    PosTemp = 10000;  /* time to make sure last processing is complete */

    
  {
    pulsename(&d3dpasscoil,"d3dpasscoil");
    create3dim(&d3dpasscoil,(long)(0),(long)(PosTemp));
  }

       
  {
    pulsename(&pass_pulsecoil,"pass_pulsecoil");
    createpass(&pass_pulsecoil,(long)(RUP_GRD(PSTR_PASS-1000)));
  }

          
  {
    pulsename(&seqcoilpass,"seqcoilpass");
    createseq(&seqcoilpass,RUP_GRD(PosTemp+PSTR_PASS-time_ssicoil), off_seqcoilpass);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqcoilpass );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqcoilpass = %d\n", idx_seqcoilpass );
#endif
  }


    return SUCCESS;
}   /* End of AutoCoilpulsegen */




/*********************************************************************
 *                     GRASS.E RSP SECTION                           *
 *                                                                   *
 * Write here the functional code for the real time processing (IPG  *
 * side). You may declare standard C variables, but of limited types *
 * short, int, long, float, double, and 1D arrays of those types.    *
 *********************************************************************/
#include <math.h>

/* For IPG Simulator: will generate the entry point list in the IPG tool */
const CHAR *entry_name_list[ENTRY_POINT_MAX] = {
	"scan", 
	"aps2",
	"mps2",
/*********************************************************************
 *                    PRESCAN.E RSP SECTION                          *
 *                           PSeplist                                *
 *                                                                   *
 * Additional list of entry points for Prescan.                      *
 *********************************************************************/
         "cfl",
         "cfh",
         "mps1",
         "aps1", 
         "autoshim",
         "fasttg",
         "rcvn",
         "expresstg",
         "RFshim",
         "DynTG",
         "extcal",
         "Autocoil",
         0	/* 0 is needed for the parser */


};

/* Do not move the line above and do not insert any code or blank
   lines before the line above.  The code inline'd from Prescan.e
   adds more entry points and closes the list. */

int *rf1_freq;
int *receive_freq1;


STATUS psdinit( void )
{
	/* Initialize everything to a known state */
	view = slice = excitation = 0;
	setrfconfig( (short)5 );	/* Only activate rho1 */
	setssitime( 100 );		/* Set ssi counter to 400 us. */
	rspqueueinit( 200 );	/* Initialize to 200 entries */
	scopeon( &seqcore );	/* Activate scope for core */
	syncon( &seqcore );		/* Activate sync for core */
	syncoff( &pass );		/* Deactivate sync during pass */
	seqCount = 0;		/* Set SPGR sequence counter */
	settriggerarray( (short)slquant1, rsptrigger );
	setrotatearray( (short)slquant1, rsprot[0] );
	setrfltrs( (int)filter_echo1, &echo1 );

	return SUCCESS;
}   /* end psdinit() */


/*********************************************************************
 *                    PRESCAN.E RSP SECTION                          *
 *                            PScore                                 *
 *                                                                   *
 * Write here the functional code for the real time processing (Tgt  *
 * side). You may declare standard C variables, but of limited types *
 * short, int, long, float, double, and 1D arrays of those types.    *
 *********************************************************************/

long PSrsptrigger[MAX_PSC_VQUANT]={0};   /* prescan trigger */ /* vmx 10/13/94 YI */

void
dump_rsp_psc_info( void )
{
    INT i ;
    printf("\nPSD-> Dump of Prescan Shim Vol. Info\n");

    for (i=0; i<oppscvquant; i++)
    {
        printf("PSD->\nPSD->PscVol %d\t\t\t\ttloc = %+6f, rloc = %+6f, phaseoff = %+6f\n",
               i, rsp_psc_info[i].rsppsctloc, rsp_psc_info[i].rsppscrloc, rsp_psc_info[i].rsppscphasoff);
        printf("PSD->\nPSD->Index %d\t\t\t\tlenx = %+6d, leny = %+6d, lenz = %+6d\n",
               i, rsp_psc_info[i].rsppsclenx, rsp_psc_info[i].rsppscleny, rsp_psc_info[i].rsppsclenz);

        printf("\n Shim volume rotation matrix\n");
        printf("PSD->\nPSD->Index %d\t\t\t\t%+6ld, %+6ld, %+6ld\n",
               i, rsp_psc_info[i].rsppscrot[0], rsp_psc_info[i].rsppscrot[1], rsp_psc_info[i].rsppscrot[2]);
        printf("PSD->\nPSD->Index %d\t\t\t\t%+6ld, %+6ld, %+6ld\n",
               i, rsp_psc_info[i].rsppscrot[3], rsp_psc_info[i].rsppscrot[4], rsp_psc_info[i].rsppscrot[5]);
        printf("PSD->\nPSD->Index %d\t\t\t\t%+6ld, %+6ld, %+6ld\n",
               i, rsp_psc_info[i].rsppscrot[6], rsp_psc_info[i].rsppscrot[7], rsp_psc_info[i].rsppscrot[8]);
    }
}

INT
get_psc_vol_index( void )
{
    int vol_index = 0;

    vol_index = (noswitch_slab_psc == PSD_ON) ? (PStest_slab-1) : (psc_vol_index-1);
    vol_index = (vol_index > 0) ? vol_index : 0;

    return vol_index;
}

/*
 *  mps1
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
mps1( void )
{
    rspent = L_MPS1;
    strcpy(psdexitarg.text_arg, "MPS1");

/* begin aps1_mod changes (GE) */
    PSinit(PSrot_mod);

    PSmps1(2);
    rspexit();

    return SUCCESS;
}   /* end mps1() */


/*
 *  aps1
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
aps1( void )
{
    rspent=L_APS1;
    strcpy(psdexitarg.text_arg, "APS1");

/* begin aps1_mod changes (GE) */
    PSinit(PSrot_mod);
    PSmps1(1);
    rspexit();

    return SUCCESS;
}   /* end aps1() */


/*
 *  cfl
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
cfl( void )
{
    rspent=L_CFL;
    strcpy(psdexitarg.text_arg, "CFL");

    PSinit(PSrot);
    PScfl();
    rspexit();

    return SUCCESS;
}   /* end cfl() */


/*
 *  rcvn
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
rcvn( void )
{
    rspent=L_RCVN;
    strcpy(psdexitarg.text_arg, "RCVN");

    PSinit(rsp_rcvnrot);

    /* Check if need to run RCVN for Full Rec coil mode */
    rcvn_usefullcoil = rspusefullcoil & RCVN_FULLCOIL;
        
    if (RCVN_FULLCOIL == rcvn_usefullcoil)
    {
        if (FAILURE == CoilSwitchSetCoil(fullRecCoilInfo_tgt[0], 0))
        {
            return FAILURE;
        }

        if(PSdebugstate)
        {
            printf("switch to full coil for RCVN \n");
        }
        rspusefullcoil &= ~RCVN_FULLCOIL;
    }

    PSrcvn();
    rspexit();

    return SUCCESS;
}   /* end rcvn() */


/* THIS IS USED AS AN ISI SUBROUTINE VECTOR */

/* This sets the rotation matrix with the one from the scan plane before the 3rd refocus pulse,
   and sets the rotation matrix back to the default one after the 3rd refocus pulse.
 */
void
cfh_set_rot_matrix_slice( void )
{
    static int rot_matrix_index = 0;
    int cfh_slab_index = get_psc_vol_index();

    if (rot_matrix_index == 0)
    {
        setrotateimm(PSrot[0], WARP_UPDATE_ON_SSP_INT);
        rot_matrix_index = 1;
    }
    else
    {
        setrotateimm(rsp_PSrot[cfh_slab_index], WARP_UPDATE_ON_SSP_INT);
        rot_matrix_index = 0;
    }
    return;
}

void
cfh_set_rot_matrix_default( void )
{
    int cfh_slab_index = get_psc_vol_index();

    setrotateimm(rsp_PSrot[cfh_slab_index], WARP_UPDATE_ON_SSP_INT);
    return;
}


/*
 *  cfh
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
cfh( void )
{
    /* Insert wait sequence before CFH for T1 recovery if the previous entry is XTG */
    if (rspent == L_XTG)
    {
        setperiod(wait_time_before_cfh, &seqcfhwait, 0);
        boffset(off_seqcfhwait);
        startseq((SHORT)0, (SHORT)MAY_PAUSE);
    }

    rspent=L_CFH;
    strcpy(psdexitarg.text_arg, "CFH");


    if ( (presscfh_ctrl == PRESSCFH_SHIMVOL) || (presscfh_ctrl == PRESSCFH_SHIMVOL_SLICE) )
    {
        int cfh_slab_index = get_psc_vol_index();
        PSinit(&rsp_PSrot[cfh_slab_index]);
    }
    else
    {
        PSinit(rsp_PSrot);
    }

    if( presscfh_ctrl == PRESSCFH_SHIMVOL_SLICE )
    {
        isivector(3, cfh_set_rot_matrix_slice, (short) FALSE);
    }
    else
    {
        isivector(3, cfh_set_rot_matrix_default, (short) FALSE);
    }

    cfh_usefullcoil = rspusefullcoil & CFH_FULLCOIL;
    if (CFH_FULLCOIL == cfh_usefullcoil)
    {
        if (FAILURE == CoilSwitchSetCoil(fullRecCoilInfo_tgt[0], 0))
        {
            return FAILURE;
        }

        if(PSdebugstate)
        {
            printf("switch to full coil for CFH \n");
        }
        rspusefullcoil &= ~CFH_FULLCOIL;
    }

    PScfh();
    rspexit();

    return SUCCESS;
}   /* end cfh() */

/*
 *  fasttg
 *
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
fasttg( void )
{
    rspent=L_FTG;
    PSinit(PSrot_mod);
    PSfasttg(pre_slice, PSdebugstate);
    rspexit();

    return SUCCESS;
}   /* end fasttg() */

/*
 *  expresstg
 *
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
expresstg( void )
{
    rspent=L_XTG;
    PSinit(PSrot_mod);

    xtg_usefullcoil = rspusefullcoil & XTG_FULLCOIL;
    if ((XTG_FULLCOIL == xtg_usefullcoil) && (PSD_OFF == xtg_volRecCoil))
    {
        if (FAILURE == CoilSwitchSetCoil(fullRecCoilInfo_tgt[0], 0))
        {
            return FAILURE;
        }

        if(PSdebugstate)
        {
            printf("switch to full coil for XTG \n");
        }
        rspusefullcoil &= ~XTG_FULLCOIL;
    }

    PSexpresstg(pre_slice, PSdebugstate);
    rspexit();

    return SUCCESS;    
}   /* end expresstg() */

/*
 * B1 Map acquisition for RF Shim 
 *
 * Type: Public Function
 *
 */
STATUS
RFshim( void )
{
    rspent=L_RFSHIM;
    strcpy(psdexitarg.text_arg, "RFshim");

    PSrfshim();    /* flag on for RFShim mode */
    printdbg("Normal End of RFshim", PSdebugstate);

    rspexit();
    return SUCCESS;    
}

int rspdtg = PSD_OFF;              /* rsp update for DynTG setting, set by prescan server */
int deltatg_temp[MAX_DYNTG_NOSLICES];
int *deltatg = (int *) deltatg_temp;    /* rsp update for DynTG setting, set by prescan server. */

STATUS DtgInitPsc()
{
    INT i;

    rspdtg = PSD_OFF;
    for (i=0; i<opslquant; i++)
    {
        deltatg[i] = 0;
    }
    return SUCCESS;
}

/* 
 * B1 Map for Dynamic TG
 *
 * Type: Public Function
 *
 */
STATUS
DynTG( void )
{
    rspent=L_DYNTG;
    strcpy(psdexitarg.text_arg, "DynTG");

    DtgInitPsc();
    PSdyntg();
    printdbg("Normal End of DynTG", PSdebugstate);

    rspexit();
    return SUCCESS;    
}

STATUS
mapTg( void )
{
    rspent=L_MAPTG;
    strcpy(psdexitarg.text_arg, "mapTg");

    PSdyntg();
    printdbg("Normal End of mapTg", PSdebugstate);

    rspexit();
    return SUCCESS;
}


/* 
 * ExtCal Entry point 
 *
 * Type: Public Function
 *
 */
STATUS
extcal( void )
{
    if((L_AUTOSHIM == rspent) || (L_RCVN == rspent) || (L_AUTOCOIL == rspent))
    {
        rspdda = cal_dda;
    }
    else
    {
        rspdda = cal_dda + cal_delay_dda;
    }

    rspent=L_EXTCAL;
    strcpy(psdexitarg.text_arg, "ExtCal");

    printdbg("Start of extcal", PSdebugstate);

    /* reset for coil switching */
    loaddab_hub_r1(&echo1cal, 0, 0, 0, 1, 0, 0, (TYPDAB_PACKETS)DABOFF, PSD_LOAD_DAB_HUB_R1_RESET);

    PSextcal();
    printdbg("Normal End of extcal", PSdebugstate);

    rspexit();
    return SUCCESS;    
}

/* 
 * AutoCoil Entry point 
 *
 * Type: Public Function
 *
 */
STATUS
Autocoil( void )
{
    rspdda = coil_dda;

    rspent=L_AUTOCOIL;

    strcpy(psdexitarg.text_arg, "Autocoil");
    printdbg("Start of Autocoil", PSdebugstate);

    PSautocoil();
    printdbg("Normal End of Autocoil", PSdebugstate);

    rspexit();
    return SUCCESS;    
}

/*
 *  autoshim
 *
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
autoshim( void )
{
    rspent=L_AUTOSHIM;
    strcpy(psdexitarg.text_arg, "Autoshim");

    ASautoshim(rspsct);
    rspexit();

    return SUCCESS;
}   /* end autoshim() */


/*
 *  PSmps1
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
PSmps1( INT mps1nex )
{
    INT acq_type;
    SHORT temp_short;
    INT slice_freq;
    FLOAT receive_freq;
    FLOAT rsp_PStloc=0.0;
    FLOAT rsp_PSrloc=0.0;
    FLOAT rsp_PSphasloc=0.0;
    INT old_psc_vol_index = -1; /* Last prescan volume for SWIFT switching */

    printdbg("Starting PSmps1",PSdebugstate);
    boffset(off_seqmps1);

    scopeon(&seqmps1);	/* Activate scope for core */
    syncon(&seqmps1);	/* Activate sync for core */

    rsp_PStloc = PStloc_mod;
    rsp_PSrloc = PSrloc_mod;
    rsp_PSphasloc = PSphasoff_mod;
    /* begin aps1_mod changes (GE) */

    if(PSD_ON == local_tg)
    {
        slice_freq = (int)( GAM * a_gyrf1mps1 * rsp_PSphasloc/
                            (10* TARDIS_FREQ_RES) );
    }
    else
    {
        slice_freq = (int)( GAM * a_gzrf1mps1 * rsp_PStloc/
                            (10* TARDIS_FREQ_RES) );
    }
    /* factor 10 is because rsptloc is in mm */
    setfrequency(slice_freq, &rf1mps1,0);

    slice_freq = (int)( GAM * a_gzrf2mps1 * rsp_PStloc
/ (10* TARDIS_FREQ_RES) );
    /* factor 10 is because rsptloc is in mm */
    setfrequency(slice_freq, &rf2mps1,0);

    receive_freq = 2 * 16000 * rsp_PSrloc/ mpsfov;

    /* end aps1_mod changes (GE) */ 

    setfrequency((int)((PSfreq_offset[rspent] + receive_freq)/TARDIS_FREQ_RES),
		 &echo1mps1, 0);

    if(PSdebugstate)
    {
        printf("\nAPS1/MPS1 Slthick = %f FOV = %f Xmit location = %f, Rcv location  = %f\n", 
                thickPS_mod,mpsfov, PStloc_mod, PSrloc_mod);
        printf("\nAPS1/MPS1 Xmit Freq = %i, Rcv Freq  = %f\n", slice_freq, receive_freq);
        printf("%s\n","APS1/MPS1 Rotation Matrix:");
        printf("\t %6ld %6ld %6ld \n", PSrot_mod[0][0], PSrot_mod[0][1], PSrot_mod[0][2]);
        printf("\t %6ld %6ld %6ld \n", PSrot_mod[0][3], PSrot_mod[0][4], PSrot_mod[0][5]);
        printf("\t %6ld %6ld %6ld \n", PSrot_mod[0][6], PSrot_mod[0][7], PSrot_mod[0][8]);
        fflush(stdout);
    }

    if( PSdebugstate )
    {
        printf("PSmps1: psc_vol_index = %d\n",psc_vol_index );
    }


    
    for (view = -1; view <= 30000; view++)
    {
        for (excitation = 1; excitation <= mps1nex; excitation++)
    	{
            if (view > 0)

      	    {
                if (excitation == mps1nex)
      	      	{
                    attenlockoff(&attenuator_keymps1);
      	      	}
                else
      	      	{
                    attenlockon(&attenuator_keymps1);
      	      	}
      	    }

            if ((view > 0) && (excitation >= 1))
      	    {
                acq_type = (int)DABON;
      	    }
            else
      	    {
                acq_type = (int)DABOFF;
      	    }

            loaddab(&echo1mps1, (int)1,(int)1,(int)1,(int)1,
                    (TYPDAB_PACKETS)acq_type, PSD_LOAD_DAB_ALL); 

            /* For SWIFT(PSmps1): We are trying not to use the CV opswift.
               Instead use psc_vol_index.  */
            if( (psc_vol_index > 0) && (opvquant > 1))
            {
                if( old_psc_vol_index != psc_vol_index )
                {
                    if( noswitch_slab_psc == PSD_OFF )
                    {
                        rsp_PStloc = rsp_info[psc_vol_index-1].rsptloc;
                        rsp_PSrloc = rsp_info[psc_vol_index-1].rsprloc;
                    }
                    else
                    {
                        rsp_PStloc = rsp_info[PStest_slab-1].rsptloc;
                        rsp_PSrloc = rsp_info[PStest_slab-1].rsprloc;
                    }

                    if( noswitch_coil_psc == PSD_OFF )
                    {
                        if (FAILURE == CoilSwitchSetCoil(coilInfo_tgt[psc_vol_index-1], 0))
                        {
                            return FAILURE;
                        }
                        boffset(off_seqmps1);
                    }
                        
                    {
                        char tempstr[200]={0};
                        sprintf(tempstr,"PSmps1: psc_vol_index=%d,rsp_PStloc=%f\n",psc_vol_index,rsp_PStloc);
                        printdbg(tempstr,PSdebugstate);
                    }
                    old_psc_vol_index = psc_vol_index;
                }
            }

            if(PSD_ON == local_tg)
            {
                slice_freq = (int)( GAM * a_gyrf1mps1 * rsp_PSphasloc/
                                    (10* TARDIS_FREQ_RES) );
            }
            else
            {
                slice_freq = (int)( GAM * a_gzrf1mps1 * rsp_PStloc/
                                    (10* TARDIS_FREQ_RES) );
            }
            /* factor 10 is because rsptloc is in mm */
            setfrequency(slice_freq, &rf1mps1,0);

            slice_freq = (int)( GAM * a_gzrf2mps1 * rsp_PStloc
/ (10* TARDIS_FREQ_RES) );
            /* factor 10 is because rsptloc is in mm */
            setfrequency(slice_freq, &rf2mps1,0);

            receive_freq = 2 * 16000 * rsp_PSrloc/ mpsfov;

            /* end aps1_mod changes (GE) */

            setfrequency((int)((PSfreq_offset[rspent] + receive_freq)/TARDIS_FREQ_RES),
                    &echo1mps1, 0);

            /* Makesure psc_vol_index is in range */
            if( (psc_vol_index > 0 && psc_vol_index <= opvquant) && (opvquant > 1)) 
            {
                if(noswitch_slab_psc == PSD_OFF)
                    startseq((short)(psc_vol_index-1), (SHORT)MAY_PAUSE);
                else
                    startseq((short)(PStest_slab-1),(SHORT)MAY_PAUSE);
            }
            else
                startseq((short)0, (SHORT)MAY_PAUSE);

            syncoff(&seqmps1);

            /* Chopper logic */
            getiamp(&temp_short, &rf1mps1,0);
            setiamp((-temp_short),&rf1mps1,0);
	}
    }

    printdbg("Returning from PSmps1",PSdebugstate);

    return SUCCESS;
}   /* end PSmps1() */


/*
 *  PScfl
 *  
 *  Type: 
 *  
 *  Description:
 *  
 */
STATUS
PScfl( void )
{
    INT acq_type; /* enable or disable data acquisiton */
    INT slice_freq; /* transmit frequency for the prescan slice */
    SHORT temp_short; /* temp variable */
    float rsp_PStloc;
    int old_psc_vol_index = -1; /* Last prescan volume for SWIFT switching */

    printdbg("Entering PScfl", PSdebugstate);
    boffset(off_seqcfl); 
    scopeon(&seqcfl);
    syncon(&seqcfl); 
    attenlockoff(&cfl_attenkey);
  
    rsp_PStloc = PStloc;
    slice_freq = (int)(GAM * a_gzrf1cfl * PStloc/
                       (10* TARDIS_FREQ_RES)); /* factor 10 is because rsptloc is in mm */
  
    setfrequency(slice_freq, &rf1cfl,0);
    setfrequency((int)(PSfreq_offset[rspent]/TARDIS_FREQ_RES),
                 &cfl_fid, 0);

    if( PSdebugstate )
    {
        printf("PScfl: psc_vol_index = %d\n",psc_vol_index );
    }

    for (view = -cfl_dda+1 ; view <= 30000; view ++)
    {
        for (excitation = 1; excitation <= cfl_nex; excitation ++)
        {
            if (view > 0) 
            {
                acq_type = (int)DABON;

                if(excitation == cfl_nex)
                    attenlockoff(&cfl_attenkey);
                else
                    attenlockon(&cfl_attenkey);
            } 
            else
            {
                acq_type = (int)DABOFF;
            }

            /* DAB packet is not used in prescan.  loaddab
               is used just to turn on or off the receiver */

            loaddab(&cfl_fid, (int)1,(int)1,(int)1,(int)1,
                    (TYPDAB_PACKETS)acq_type, PSD_LOAD_DAB_ALL);

            /* For SWIFT(PScfl): We are trying not to use the CV opswift.
               Instead use psc_vol_index.
             */
            if( (psc_vol_index > 0) && (opvquant > 1) )
            {
                if( old_psc_vol_index != psc_vol_index )
                {
                    if( noswitch_slab_psc == PSD_OFF )
                    {
                        rsp_PStloc = rsp_info[psc_vol_index-1].rsptloc;
                    }
                    else
                    {
                        rsp_PStloc = rsp_info[PStest_slab-1].rsptloc;
                    }

                    if( noswitch_coil_psc == PSD_OFF )
                    {
                        if (FAILURE == CoilSwitchSetCoil(coilInfo_tgt[psc_vol_index-1], 0))
                        {
                            return FAILURE;
                        }
                        boffset(off_seqcfl); 
                    }

                    {
                        char tempstr[200]={0};
                        sprintf(tempstr,"PScfl: psc_vol_index=%d,rsp_PStloc=%f\n",psc_vol_index,rsp_PStloc);
                        printdbg(tempstr,PSdebugstate);
                    }
                    old_psc_vol_index = psc_vol_index;
                }
            }

            slice_freq = (int)(GAM * a_gzrf1cfl * rsp_PStloc/
                               (10* TARDIS_FREQ_RES)); /* factor 10 is because rsptloc is in mm */

            setfrequency(slice_freq, &rf1cfl,0);

            /* Makesure psc_vol_index is in range */
            if( (psc_vol_index > 0 && psc_vol_index <= opvquant) && (opvquant > 1)) 
            {
                if(noswitch_slab_psc == PSD_OFF)
                    startseq((short)(psc_vol_index-1), (SHORT)MAY_PAUSE);
                else
                    startseq((short)(PStest_slab-1),(SHORT)MAY_PAUSE);
            }
            else
                startseq((short)0, (SHORT)MAY_PAUSE);

            /*printdbg("S", PSdebugstate);*/
            syncoff(&seqcfl);

            if(PSdebugstate && view == 0)
            {
                printf("\n CFL:  Xmit Location = %f Receive Location = %f\n ", PStloc, 0.0 );
                printf ("%s\n","CFL : Rotation Matrix");
                printf("\t %6ld %6ld %6ld \n", PSrot[0][0], PSrot[0][1], PSrot[0][2]);
                printf("\t %6ld %6ld %6ld \n", PSrot[0][3], PSrot[0][4], PSrot[0][5]);
                printf("\t %6ld %6ld %6ld \n", PSrot[0][6], PSrot[0][7], PSrot[0][8]);
                fflush(stdout);
            }

            getiamp(&temp_short, &rf1cfl, 0);
            setiamp(-temp_short, &rf1cfl, 0);

            if (view < 1)
            {
                break; /* Skip excitation loop for disdaqs */
            }

        }  /* end excitation */
    }  /* end view */

    return SUCCESS;
}   /* end PScfl() */


/*
 *  PSrcvn
 *  
 *  Type: 
 *  
 *  Description:
 *  
 */
STATUS
PSrcvn( void )
{
    INT acq_type; /* enable or disable data acquisiton */
    int old_psc_vol_index = -1; /* Last prescan volume for SWIFT switching */

    printdbg("Entering PSrcvn", PSdebugstate);

    /* GEHmr03545 */
    if ( rcvn_flag != PSD_OFF )
    {
        boffset( off_pre_rcvn );
        startseq((SHORT)0, (SHORT)MAY_PAUSE);
    }

    boffset(off_seqrcvn); 
    scopeon(&seqrcvn);
    syncon(&seqrcvn); 
    attenlockoff(&rcvn_attenkey);
  
    setfrequency((int)(PSfreq_offset[rspent]/TARDIS_FREQ_RES),
                 &rcvn_fid, 0);

    if( PSdebugstate )
    {
        printf("PSrcvn: psc_vol_index = %d\n",psc_vol_index );
    }

    for (view = -rcvn_dda+1 ; view <= rcvn_loops ; view ++)
    {
        for (excitation = 1; excitation <= rcvn_nex; excitation ++)
        {
            if (view > 0) 
            {
                acq_type = (int)DABON;

                if(excitation == rcvn_nex)
                    attenlockoff(&rcvn_attenkey);
                else
                    attenlockon(&rcvn_attenkey);
            } 
            else
            {
                acq_type = (int)DABOFF;
            }

            /* DAB packet is not used in prescan.  loaddab
               is used just to turn on or off the receiver */

            loaddab(&rcvn_fid, (int)1,(int)1,(int)1,(int)1,
                    (TYPDAB_PACKETS)acq_type, PSD_LOAD_DAB_ALL);

            /* For SWIFT(PSrcvn): We are trying not to use the CV opswift.
               Instead use psc_vol_index.
             */
            if( (psc_vol_index > 0) && (opvquant > 1) )
            {
                if( old_psc_vol_index != psc_vol_index )
                {
                    /* No need to switch slab*/
                    if( noswitch_coil_psc == PSD_OFF )
                    {
                        if (FAILURE == CoilSwitchSetCoil(coilInfo_tgt[psc_vol_index-1], 0))
                        {
                            return FAILURE;
                        }
                        boffset(off_seqrcvn); 
                    }

                    {
                        char tempstr[200]={0};
                        sprintf(tempstr,"PSrcvn: psc_vol_index=%d\n",psc_vol_index);
                        printdbg(tempstr,PSdebugstate);
                    }
                    old_psc_vol_index = psc_vol_index;
                }
            }
            startseq((short)0,(short)MAY_PAUSE);

            syncoff(&seqrcvn);

            if (view < 1)
            {
                break; /* Skip excitation loop for disdaqs */
            }

        }  /* end excitation */
    }  /* end view */

    return SUCCESS;
}   /* end PSrcvn() */

/*
 *  NoiseCalrcvn
 *  
 *  Type: Public Function
 *  
 *  Description: NoiseCal in scan. Override opcode to DNOISE (16) for rcvn_fid
 *  
 */
STATUS
NoiseCalrcvn( void )
{
    short dabbits;

    if(noisecal_in_scan_flag && (fopen(".DisableNoiseCalinScan", "r")==NULL))
    {
        printdbg("Entering NoiseCalrcvn", PSdebugstate);

        if ( rcvn_flag != PSD_OFF )
        {
            if(scalerotmats(rsp_rcvnrot, &loggrd, &phygrd, 1, ps1obl_debug) == FAILURE)
            {
                return FAILURE;
            }   
            setrotatearray((short)1, rsp_rcvnrot[0]);
            PSrsptrigger[0] = PStrigger;
            settriggerarray((short)1, PSrsptrigger);
            boffset( off_pre_rcvn );
            startseq((SHORT)0, (SHORT)MAY_PAUSE);
        }

        boffset(off_seqrcvn); 
        scopeon(&seqrcvn);
        syncon(&seqrcvn); 
        attenlockoff(&rcvn_attenkey);

        setfrequency((int)(PSfreq_offset[rspent]/TARDIS_FREQ_RES),
                     &rcvn_fid, 0);

        dabbits = DNOISECAL;
        sspload(&dabbits,
                &rcvn_fid,
                1, /*opcode*/
                1,
                (HW_DIRECTION)TOHARDWARE,
                (SSP_S_ATTRIB)SSPS1);

        dabbits = 1; 
        sspload(&dabbits,
                &rcvn_fid,
                2, /*frame*/
                1,
                (HW_DIRECTION)TOHARDWARE,
                (SSP_S_ATTRIB)SSPS1);

        s32 resolution = rcvn_xres; 
        sspextload(&resolution,
                   &rcvn_fid,
                   3, /*resolution*/
                   1,
                   (HW_DIRECTION)TOHARDWARE,
                   (SSP_S_ATTRIB)SSPS2);

        startseq((short)0,(short)MAY_PAUSE);

        /* reset opcode back to normal */
        dabbits = DXCT;
        sspload(&dabbits,
                &rcvn_fid,
                1, /*opcode*/
                1,
                (HW_DIRECTION)TOHARDWARE,
                (SSP_S_ATTRIB)SSPS1);

        syncoff(&seqrcvn);

        /* return to imaging sequence */
        boffset(off_seqcore);
    }
    return SUCCESS;
}   /* end NoiseCalrcvn() */



/*
 *  PScfh
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
PScfh( void )
{
    static INT rsp_PSshift = 0;  /* RSP shimvol shift for debug purpose */
    INT acq_type;      /* enable or disable data acquisiton */
    INT slice_freq  = 0;   /* transmit frequency for the prescan slice */
    INT slice2_freq = 0;   /* transmit frequency for the prescan slice */
    INT slice3_freq = 0;   /* presscfh: transmit frequency for the prescan slice */
    INT slice4_freq = 0;   /* presscfh-slice: transmit frequency for the prescan slice */
    INT ir_slice_freq = 0; /* IR sequence transmit freq. for the prescan slice */
    SHORT temp_short;  /* temp variable */
    long init_cfh_deadtime; /* initial deadtime of the seqcfh sequence */
    long new_cfh_deadtime;  /* updated cfh deadtime */

    float rsp_PStloc = 0;    /* RSP transmit location */
    float rsp_PSrloc = 0;    /* RSP receive location */
    float rsp_PSphasoff = 0; /* RSP phase off location */
    float rsp_PSslicetloc = 0;    /* RSP slice refocus location */
    int old_psc_vol_index = -1; /* Last prescan volume for SWIFT switching */
    
    showfp = 0;

    printdbg("Entering PScfh", PSdebugstate);
    boffset(off_seqcfh); 
    scopeon(&seqcfh);
    syncon(&seqcfh); 
    attenlockoff(&cfh_attenkey);

    if (psc_vol_index == 0) {

        slice_freq = (int)cfh_rf1freq;
        setfrequency(slice_freq, &rf1cfh,0);

        slice2_freq = (int)cfh_rf2freq;
        setfrequency(slice2_freq, &rf2cfh,0);
        setfrequency((int)(PSfreq_offset[rspent]/TARDIS_FREQ_RES), &cfh_fid, 0);
    }

#ifdef PSD_CFH_CHEMSAT

    if ((cs_sat == PSD_ON) && PScs_sat)
    {
        if (PSir != PSD_ON)
        {
            setiamp(ia_rfcssatcfh, &rfcssat, cscfh_satindex);
        }
        else
        {
            setiamp(0, &rfcssat, cscfh_satindex);
        }
    }
    cstun = 0;

#endif


    if (PSD_ON == PSir)
    {
        /* Inversion */
        /* factor 10 is because rsptloc is in mm */
        ir_slice_freq = (int)(GAM * a_gzrf0cfh * PStloc/(10 * TARDIS_FREQ_RES));
        setfrequency(ir_slice_freq, &rf0cfh,0);
    }

    /* Setting tislice to PSslice_num+1 so user sees slices start at 1*/
    tislice=PSslice_num+1;
    tislice_start=PSslice_num+1;

    /* Setting psctitime to opti; results in every entry into CFH having
       psctitime=opti*/
    psctitime = cfh_ti/1000;
    noir = 0;

    /* Finding initial deadtime (psctitime = opti) of seqcfh */
    getperiod( &init_cfh_deadtime, &seqcfh, 0 );

    if( PSdebugstate )
    {
        printf("PScfh: psc_vol_index = %d\n",psc_vol_index );
    }


    for (view = -cfh_dda+1 ; view <= 30000; view ++)
    {
        /* Modified for MULTI VOLUME Prescan - AP */
        if( presscfh_ctrl != PRESSCFH_NONE )
        {
            int cfh_slab_index = get_psc_vol_index();

            if( ( presscfh_ctrl != PRESSCFH_SHIMVOL ) && ( presscfh_ctrl != PRESSCFH_SHIMVOL_SLICE ) )
            {
                rsp_PStloc = presscfh_info[cfh_slab_index].oppsctloc;
                rsp_PSrloc = presscfh_info[cfh_slab_index].oppscrloc;
                rsp_PSphasoff = presscfh_info[cfh_slab_index].oppscphasoff;
            }
            else
            {
                rsp_PStloc = rsp_psc_info[cfh_slab_index].rsppsctloc;
                rsp_PSrloc = rsp_psc_info[cfh_slab_index].rsppscrloc;
                rsp_PSphasoff = rsp_psc_info[cfh_slab_index].rsppscphasoff;
            }

            if (PScfh_shimvol_debug != PSCFH_SHIMVOL_DEBUG_NONE)
            {
                rsp_PSshift = rsp_PSshift + 10;
                if ( rsp_PSshift > 100 )
                {
                    rsp_PSshift = -100;
                }
            }
            else
            {
                rsp_PSshift = 0;
            }

            if (PScfh_shimvol_debug & PSCFH_SHIMVOL_DEBUG_Z)
            {
                rsp_PStloc = rsp_PStloc + rsp_PSshift;
            }
            if (PScfh_shimvol_debug & PSCFH_SHIMVOL_DEBUG_X)
            {
                rsp_PSrloc = rsp_PSrloc + rsp_PSshift;
            }
            if (PScfh_shimvol_debug & PSCFH_SHIMVOL_DEBUG_Y)
            {
                rsp_PSphasoff = rsp_PSphasoff + rsp_PSshift;
            }

            slice_freq = (int)(GAM * a_gzrf1cfh * rsp_PStloc/ (10 * TARDIS_FREQ_RES));
            slice2_freq = (int)(GAM * a_gxrf2cfh * rsp_PSrloc/ (10 * TARDIS_FREQ_RES));
            slice3_freq = (int)(GAM * a_gyrf3cfh * rsp_PSphasoff/ (10 * TARDIS_FREQ_RES));

            if(PSdebugstate)
            {
                printf("\n");
                printf(" slice1_freq -> rsp_PStloc %0f \n", rsp_PStloc);
                printf(" slice2_freq -> rsp_PSrloc %0f \n", rsp_PSrloc);
                printf(" slice3_freq -> rsp_PSphasoff %0f \n", rsp_PSphasoff);
            }

            if( presscfh_ctrl == PRESSCFH_SHIMVOL_SLICE )
            {
                rsp_PSslicetloc = PStloc;
                slice4_freq = (int)(GAM * a_gzrf4cfh * rsp_PSslicetloc/ (10 * TARDIS_FREQ_RES));

                if(PSdebugstate)
                {
                    printf(" slice4_freq -> rsp_PSslicetloc %0f \n", rsp_PSslicetloc);
                }
            }

            if( PSD_ON == PSir ) {
                ir_slice_freq = (int)( GAM * a_gzrf0cfh * rsp_PStloc
/ (10 * TARDIS_FREQ_RES) );
                setfrequency(ir_slice_freq, &rf0cfh,0);
            }
        }
        else if ( psc_vol_index > 0 )
        {
            /* PRESSCFH_NONE */

            int cfh_switch_coil=0;

            rsp_PStloc = PStloc;
            rsp_PSrloc = PSrloc;
            rsp_PSphasoff = PSphasoff;

            if ( opswift == PSD_ON )
            {
                    cfh_switch_coil = 1;
            }

            if( cfh_switch_coil )
            {
                if( old_psc_vol_index != psc_vol_index )
                {
                    if( noswitch_coil_psc == PSD_OFF )
                    {
                        if (FAILURE == CoilSwitchSetCoil(coilInfo_tgt[psc_vol_index-1], 0))
                        {
                            return FAILURE;
                        }
                        boffset(off_seqcfh); 
                    }

                    {
                        char tempstr[200]={0};
                        sprintf(tempstr,"PScfh: psc_vol_index=%d \n",psc_vol_index);
                        printdbg(tempstr,PSdebugstate);
                    }
                    old_psc_vol_index = psc_vol_index;
                }
            }
            slice_freq = (int)(GAM * a_gzrf1cfh * rsp_PStloc/(10 * TARDIS_FREQ_RES));
            if((opcoax != 0) && cfh_newmode)
            {
                slice2_freq = (int)(GAM * (opspf ? rsp_PSphasoff * a_gyrf2cfh : rsp_PSrloc * a_gxrf2cfh )/(10 * TARDIS_FREQ_RES));
            }
            else
            {
                slice2_freq = 0;
            }

            if( PSD_ON == PSir )
            {
                ir_slice_freq = (int)(GAM * a_gzrf0cfh * rsp_PStloc/(10 * TARDIS_FREQ_RES));
                setfrequency(ir_slice_freq, &rf0cfh,0);
            }
        }
        else
        {
            /* This is for the 3D scan volume - psc_vol_index = 0 */
            rsp_PStloc = PStloc;
            rsp_PSrloc = PSrloc;
            rsp_PSphasoff = PSphasoff;

            slice_freq = (int)cfh_rf1freq;
            slice2_freq = (int)cfh_rf2freq;
            if( PSD_ON == PSir )
            {
                ir_slice_freq = (int)(GAM * a_gzrf0cfh * PStloc/(10 * TARDIS_FREQ_RES));
                setfrequency(ir_slice_freq, &rf0cfh,0);
            }
        }  /* end of psc_vol_index */

        setfrequency(slice_freq, &rf1cfh,0);
        setfrequency(slice2_freq, &rf2cfh,0);
        if( presscfh_ctrl != PRESSCFH_NONE )
        {
            setfrequency(slice3_freq, &rf3cfh,0); /* for presscfh_ctrl */
            if( presscfh_ctrl == PRESSCFH_SHIMVOL_SLICE )
            {
                setfrequency(slice4_freq, &rf4cfh,0); /* for presscfh_ctrl */
            }
        }

        setfrequency((int)(PSfreq_offset[rspent]/TARDIS_FREQ_RES), &cfh_fid, 0);

        if(PSdebugstate)
        {
            INT pscrot_idx;

            pscrot_idx = psc_vol_index;
            if (psc_vol_index > 0)
            {
                pscrot_idx = psc_vol_index-1;
            }
            printf("\n %d rsp_PStloc (tx, rec, phase) -> %0f %0f %0f\n",
                   psc_vol_index, rsp_PStloc, rsp_PSrloc, rsp_PSphasoff);
            printf ("CFH : Rotation Matrix for Prescan Volume Index %d\n", psc_vol_index);
            printf("\t %6ld %6ld %6ld \n", rsp_PSrot[pscrot_idx][0], rsp_PSrot[pscrot_idx][1], rsp_PSrot[pscrot_idx][2]);
            printf("\t %6ld %6ld %6ld \n", rsp_PSrot[pscrot_idx][3], rsp_PSrot[pscrot_idx][4], rsp_PSrot[pscrot_idx][5]);
            printf("\t %6ld %6ld %6ld \n", rsp_PSrot[pscrot_idx][6], rsp_PSrot[pscrot_idx][7], rsp_PSrot[pscrot_idx][8]);

            fflush(stdout);
        }


        /* INVERSION RECOVERY CODE */
        if (PSD_ON == PSir)
        {
            /* Check for IR pulse being turned off */
            if (noir==1)
            {
                setiamp(0,&rf0cfh,0);
            }
            else
            {
                setiamp(ia_rf0cfh,&rf0cfh,0);
            }
            /* End check for IR pulse being on/off */

            if (tislice != (PSslice_num+1))
            {
                /* user has changed slice, so change frequencies */
                /* Check for proper range */
                if ((tislice < 1) || (tislice > opslquant)) 
                {
                    tislice=tislice_start;
                    PSslice_num=tislice-1;
                } 
                else
                {
                    PSslice_num=tislice-1;
                    /* changing the slice */

                    /* Calculation of new slice loc */
                    new_slice_loc = PStloc - ((opslspace + opslthick) *
                                              (tislice_start - tislice));
                    /* Inversion */
                    /* factor 10 is because rsptloc is in mm */
                    ir_slice_freq = (int)(GAM * a_gzrf0cfh * new_slice_loc/(10 * TARDIS_FREQ_RES));

                    setfrequency(ir_slice_freq, &rf0cfh,0);

                    /* Spin Echo */
                    /* factor 10 is because rsptloc is in mm */
                    slice_freq = (int)(GAM * a_gzrf1cfh * new_slice_loc/(10 * TARDIS_FREQ_RES));

                    setfrequency(slice_freq, &rf1cfh,0);
                    /* end of changing the slice */
                }
            }

            /* Changing the inversion time realtime */
            if (psctitime<50)
            {
                psctitime=50;
            }

            /* Need this check to reset psctitime to opti. Download error were
               happening because of invalid titimes */
            if(psctitime > 300)
            {
                psctitime = cfh_ti/1000;
            }

            titime_us = (psctitime*1000);
            new_dur=dur_invse + (titime_us - cfh_ti);
            new_dur = RUP_GRD(new_dur);
            setperiod(new_dur,&zticfh,0);
            setperiod(new_dur,&xticfh,0);
            setperiod(new_dur,&yticfh,0);
            setperiod(new_dur,&rticfh,0);
            setperiod(new_dur,&sticfh,0);

            /* Change the deadtime of seqcfh to preserve the cfh_tr value */
            /* If the seqcfh deadtime < 5 then set to the minimum of 4us */
            new_cfh_deadtime = init_cfh_deadtime + (cfh_ti - titime_us);
            if (new_cfh_deadtime < 5)
            {
                new_cfh_deadtime = 4;
            }

            setperiod( new_cfh_deadtime, &seqcfh, 0 );
            /* End deadtime change */

            /* End inversion time change */

            /* END INVERSION CORE CODE */
        } 
#ifdef PSD_CFH_CHEMSAT
        if( (cs_sat == PSD_ON) && PScs_sat )
        {
            CsSatMod((int)(cscfh_satindex+1));
        }
#endif
        /* Check should play cs/mt or stir for manual cfh */
        if( PSir )
        {
            StIRMod();
        }

        for( excitation = 1; excitation <= cfh_nex; excitation ++ )
        {
            if( view > 0 ) 
            {
                acq_type = (int)DABON;

                if( excitation == cfh_nex )
                {
                    attenlockoff(&cfh_attenkey);
                }
                else
                {
                    attenlockon(&cfh_attenkey);
                }
            } 
            else
            {
                acq_type = (int)DABOFF;
            }

            /* DAB packet is not used in prescan.  loaddab
               is used just to turn on or off the receiver */
            loaddab(&cfh_fid, (int)1,(int)1,(int)1,(int)1,
                    (TYPDAB_PACKETS)acq_type, PSD_LOAD_DAB_ALL);

            /* Makesure psc_vol_index is in range */
            if( (psc_vol_index > 0 && psc_vol_index <= opvquant) && (opvquant > 1)) 
            {
                if(noswitch_slab_psc == PSD_OFF)
                    startseq((short)(psc_vol_index-1), (SHORT)MAY_PAUSE);
                else
                    startseq((short)(PStest_slab-1),(SHORT)MAY_PAUSE);
            }
            else
                startseq((short)0, (SHORT)MAY_PAUSE);

            /*printdbg("S", PSdebugstate);*/
            syncoff(&seqcfh); 

            getiamp(&temp_short, &rf1cfh, 0);
            setiamp(-temp_short, &rf1cfh, 0);

            if (view < 1)
            {
                break; /* Skip excitation loop for disdaqs */
            }
        }  /* end excitation */
    }  /* end view */

    return SUCCESS;
}   /* end PScfh() */


/* disable STIR cfh if cs/mttun is on */
void
StIRMod(void)
{
    int do_mttun = 0;
    int do_cstun = 0;


#ifdef PSD_CFH_CHEMSAT
    if(PSD_ON == PScs_sat)
    {
        do_cstun = cstun;
    }
    else
    {
        do_cstun = PSD_OFF;
    }
#endif /* PSD_CFH_CHEMSAT */

    if( do_cstun || do_mttun || showfp ) 
    {
        /* disable stir cfh pulse */
        rfoff(&rf0cfh, 0);
        setiampt(0, &gyrf0kcfh, 0);
    }
    else {
        rfon(&rf0cfh, 0);
        setiampt(amp_gyrf0kcfh, &gyrf0kcfh, 0);
    }
    return;
}


/*  begin aps1_mod changes (GE) */
/*
 *  PSinit
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
PSinit( long (*PSrotmat)[9] )
{   
    INT i;

    /* Range check for psc_vol_index */
    if ( psc_vol_index < 0 )
    {
        if(PSdebugstate)
            printf("WRONG psc_vol_index =%d\n",psc_vol_index);
        psc_vol_index = 0;
    }

    setrfconfig((short) 5);	/* only activate rho1 */
    setssitime(100);	/* set ssi counter to 400 us. */
    rspqueueinit(200);	/* initialize to 200 entries */

    if( presscfh_cgate && rspent == L_CFH ){
        PSrsptrigger[0] = TRIG_ECG;
    } else{
        PSrsptrigger[0] = PStrigger;
    }
    setrotatearray((short)1, *PSrotmat);
    settriggerarray((short)1, PSrsptrigger);
    
    /* Always use scan rot matrix for SWIFT*/
    if(opswift == PSD_ON)
    {
        setrotatearray((short)opvquant,rsprot[0]);
        for(i=0;i<opvquant;i++)
            PSrsptrigger[i] = PStrigger;

        settriggerarray((short)opvquant,PSrsptrigger);
    }


    return SUCCESS;
}   /* end PSinit() */

/* end aps1_mod changes (GE) */

/*
 *  PSfasttg
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
PSfasttg( INT preslice,
          INT debugstate)
{
    printdbg("Greetings from FastTG", PSdebugstate);
    rspent = L_FTG;
    rspdda = ftg_dda;
    rspbas = 0;
    rspvus = 30000;
    rspgy1 = 0;
    rspnex = 1;
    rspesl = preslice;
    rspasl = 0;
    rspslq = 1;
    rspsct = -1;

    strcpy(psdexitarg.text_arg, "FastTG");
    
    FastTGCore( PStloc_mod,
                (int)rspdda,
                (int)rspvus,
                (int)rspnex,
                (int)PSdebugstate);
 
    printdbg("Normal End of FastTG", debugstate);
    rspexit();

    return SUCCESS;
}   /* end PSfasttg() */


/*
 *  PSexpresstg
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
PSexpresstg( INT preslice,
             INT debugstate)
{
    printdbg("Greetings from eXpress TG", PSdebugstate);
    rspdda = xtg_dda;
    rspbas = 0;
    rspvus = 30000;
    rspgy1 = 0;
    rspnex = 1;
    rspesl = preslice;
    rspasl = 0;
    rspslq = 1;
    rspsct = -1;

    strcpy(psdexitarg.text_arg, "eXpressTG");
    
    eXpressTGCore( PStloc_mod,
                   (int)rspdda,
                   (int)rspvus,
                   (int)rspnex,
                   (int)PSdebugstate);
 
    printdbg("Normal End of eXpressTG", debugstate);
    rspexit();

    return SUCCESS;
}   /* end PSexpresstg() */


/*
 *  FastTGCore
 *  
 *  Type: Public Function
 *  
 *  Description:
 *    slice_loc: location of prescan slice  in mm
 *    slice_num: slice number to be excited
 *    ftg_disdaqs: number of disdaq pairs
 *    ftg_views: # of max views to be executed in ftg
 *    ftg_nex: # of excitations in ftg
 *    ftg_chop: No chop if = 2
 *    ftg_debug: debug state
 */
STATUS
FastTGCore( DOUBLE slice_loc,
            INT ftg_disdaqs,
            INT ftg_views,
            INT ftg_nex,
            INT ftg_debug )
{
    INT slice_freq1;    /* transmit frequency for the prescan slices */
    INT slice_freq2;
    INT slice_freq3;
    INT rcv_freq;
    float rsp_PStloc=0.0;
    float rsp_PSrloc=0.0;
    int old_psc_vol_index = -1; /* Last prescan volume for SWIFT switching */

    if (FTGacq1 == 1)
    {
        ftg_acq1 = (int)DABON;
    }
    else
    {
        ftg_acq1 = (int)DABOFF;
    }
      
    if (FTGacq2 == 1)
    {
        ftg_acq2 = (int)DABON;
    }
    else
    {
        ftg_acq2 = (int)DABOFF;
    }
      
    printdbg("Entering FastTGCORE", (SHORT)ftg_debug);
    boffset(off_seqftg);
    scopeon(&seqftg);
    syncon(&seqftg);
 
    /* Initialize */
    rsp_PStloc = slice_loc;
    rsp_PSrloc = PSrloc_mod;

    attenlockoff(&ftg_attenkey);
    slice_freq1 = (int)(GAM * a_gzrf1ftg * rsp_PStloc/
                        (10* TARDIS_FREQ_RES)); /* factor 10 is because rsptloc is in mm */
    slice_freq2 = (int)(GAM * a_gzrf2ftg * rsp_PStloc/
                        (10* TARDIS_FREQ_RES)); /* factor 10 is because rsptloc is in mm */
    slice_freq3 = (int)(GAM * a_gzrf3ftg * rsp_PStloc/
                        (10* TARDIS_FREQ_RES)); /* factor 10 is because rsptloc is in mm */
    rcv_freq = (int)(2*1000*FTGecho1bw*rsp_PSrloc/ FTGfov);

    setfrequency(slice_freq1, &rf1ftg,0);
    setfrequency(slice_freq2, &rf2ftg,0);
    setfrequency((INT)((rcv_freq + PSfreq_offset[rspent])/TARDIS_FREQ_RES),
                 &echo1ftg, 0);
    setfrequency(slice_freq3, &rf3ftg,0);
    setfrequency((INT)((rcv_freq + PSfreq_offset[rspent])/TARDIS_FREQ_RES),
                 &echo2ftg, 0);
 
    if(PSdebugstate)
    {
        printf("\nFTG Slthick = %f FOV = %f Xmit location = %f, Rcv location  = %f\n", 
                FTGslthk,FTGfov, slice_loc, PSrloc_mod);
        printf("\nFTG Xmit Freq = %f, Rcv Freq  = %f\n", (float)slice_freq1, (float)rcv_freq);
        printf("%s\n","FTG Rotation Matrix:");
        printf("\t %6ld %6ld %6ld \n", PSrot_mod[0][0], PSrot_mod[0][1], PSrot_mod[0][2]);
        printf("\t %6ld %6ld %6ld \n", PSrot_mod[0][3], PSrot_mod[0][4], PSrot_mod[0][5]);
        printf("\t %6ld %6ld %6ld \n", PSrot_mod[0][6], PSrot_mod[0][7], PSrot_mod[0][8]);
        fflush(stdout);
    }

    if( PSdebugstate )
    {
        printf("FTG: psc_vol_index = %d\n",psc_vol_index );
    }

    for (view = (-ftg_disdaqs + 1) ; view <= ftg_views; view ++)
    {
        for (excitation = 1; excitation <= ftg_nex; excitation ++)
        {
            if (view > 0)
            {
                if (excitation == 1)
                    attenlockon(&ftg_attenkey);
                if (excitation == ftg_nex)
                    attenlockoff(&ftg_attenkey);
                ftg_acq2 = (int)DABON;
            }
            else
            {
                ftg_acq2 = (int)DABOFF;
            }
 
            /* DAB packet is not used in prescan.  loaddab
               is used just to turn on or off the receiver */
            loaddab(&echo1ftg, (INT)1,(INT)1,(INT)1,(INT)1,
                    (TYPDAB_PACKETS)ftg_acq1, PSD_LOAD_DAB_ALL);
            loaddab(&echo2ftg, (INT)1,(INT)1,(INT)1,(INT)1,
                    (TYPDAB_PACKETS)ftg_acq2, PSD_LOAD_DAB_ALL);

            /* For SWIFT(fasttg): We are trying not to use the CV opswift.
               Instead use psc_vol_index.
               */
            if( (psc_vol_index > 0) && (opvquant > 1) )
            {
                if( old_psc_vol_index != psc_vol_index )
                {
                    /* No need to switch coil*/
                    if( noswitch_slab_psc == PSD_OFF )
                    {
                        rsp_PStloc = rsp_info[psc_vol_index-1].rsptloc;
                        rsp_PSrloc = rsp_info[psc_vol_index-1].rsprloc;
                    }
                    else
                    {
                        rsp_PStloc = rsp_info[PStest_slab-1].rsptloc;
                        rsp_PSrloc = rsp_info[PStest_slab-1].rsprloc;
                    }

                    {
                        char tempstr[200] = "";
                        sprintf(tempstr,"fasttgcore: psc_vol_index=%d,rsp_PStloc=%f\n",psc_vol_index,rsp_PStloc);
                        printdbg(tempstr,PSdebugstate);
                    }
                    old_psc_vol_index = psc_vol_index;
                }
            }

            slice_freq1 = (int)(GAM * a_gzrf1ftg * rsp_PStloc/
                                (10* TARDIS_FREQ_RES)); /* factor 10 is because rsptloc is in mm */
            slice_freq2 = (int)(GAM * a_gzrf2ftg * rsp_PStloc/
                                (10* TARDIS_FREQ_RES)); /* factor 10 is because rsptloc is in mm */
            slice_freq3 = (int)(GAM * a_gzrf3ftg * rsp_PStloc/
                                (10* TARDIS_FREQ_RES)); /* factor 10 is because rsptloc is in mm */
            rcv_freq = (int)(2*1000*FTGecho1bw*rsp_PSrloc/ FTGfov);

            setfrequency(slice_freq1, &rf1ftg,0);
            setfrequency(slice_freq2, &rf2ftg,0);
            setfrequency((INT)((rcv_freq + PSfreq_offset[rspent])/TARDIS_FREQ_RES),
                    &echo1ftg, 0);
            setfrequency(slice_freq3, &rf3ftg,0);
            setfrequency((INT)((rcv_freq + PSfreq_offset[rspent])/TARDIS_FREQ_RES),
                    &echo2ftg, 0);


            /* Makesure psc_vol_index is in range */
            if( (psc_vol_index > 0 && psc_vol_index <= opvquant) && (opvquant > 1)) 
            {
                if(noswitch_slab_psc == PSD_OFF)
                    startseq((short)(psc_vol_index-1), (SHORT)MAY_PAUSE);
                else
                    startseq((short)(PStest_slab-1),(SHORT)MAY_PAUSE);
            }
            else
                startseq((short)0, (SHORT)MAY_PAUSE);

            printdbg("S", (SHORT)ftg_debug);
            syncoff(&seqftg);
 
 
            if (view < 1)
            {
                break; /* Skip excitation loop for disdaqs */
            }
 
        }  /* end excitation */
 
    }  /* end view */

    return SUCCESS;
}   /* end FastTGCore() */


/*
 *  eXpressTGCore
 *  
 *  Type: Public Function
 *  
 *  Description:
 *    slice_loc: location of prescan slice  in mm
 *    slice_num: slice number to be excited
 *    xtg_disdaqs: number of disdaq pairs
 *    xtg_views: # of max views to be executed in xtg
 *    xtg_nex: # of excitations in xtg
 *    xtg_chop: No chop if = 2
 *    xtg_debug: debug state
 */
STATUS
eXpressTGCore( DOUBLE slice_loc,
            INT xtg_disdaqs,
            INT xtg_views,
            INT xtg_nex,
            INT xtg_debug )
{
    INT slice_freq1;    /* transmit frequency for the prescan slices */
    INT slice_freq2;
    INT rcv_freq;
    SHORT temp_short;
    INT rf3xtg_freq, rf4xtg_freq;
    float rsp_PStloc=0.0;
    float rsp_PSrloc=0.0;
    float rsp_PSphasoff=0.0;
    int old_psc_vol_index = -1; /* Last prescan volume for SWIFT switching */
    long tmp_period;

    if (XTGacq1 == PSD_ON)
    {
        xtg_acq1 = (int)DABON;
    }
    else
    {
        xtg_acq1 = (int)DABOFF;
    }
            
    printdbg("Entering eXpressTGCORE", (SHORT)xtg_debug);

    tmp_period = (long)init_xtg_deadtime;
    tmp_period = RUP_GRD(tmp_period);
                                                  
    boffset(off_seqxtg);
    setperiod(tmp_period, &seqxtg, 0);

    scopeon(&seqxtg);
    syncon(&seqxtg);
 
    /* Initialize */
    rsp_PStloc = slice_loc;
    rsp_PSrloc = PSrloc_mod;
    rsp_PSphasoff = PSphasoff_mod;

    attenlockoff(&xtg_attenkey);
    if(PSD_ON == local_tg)
    {
        slice_freq1 = (int)(GAM * a_gyrf1xtg * rsp_PSphasoff/
                            (10* TARDIS_FREQ_RES)); /* factor 10 is because rsptloc is in mm */
    }
    else
    {
        slice_freq1 = (int)(GAM * a_gzrf1xtg * rsp_PStloc/
                            (10* TARDIS_FREQ_RES)); /* factor 10 is because rsptloc is in mm */
    }

    slice_freq2 = (int)(GAM * a_gzrf2xtg * rsp_PStloc/
                        (10* TARDIS_FREQ_RES)); /* factor 10 is because rsptloc is in mm */
    rcv_freq = (int)(2*1000*XTGecho1bw*rsp_PSrloc/ XTGfov);

    setfrequency(slice_freq1, &rf1xtg,0);
    setfrequency(slice_freq2, &rf2xtg,0);
    setfrequency((INT)((rcv_freq + PSfreq_offset[rspent])/TARDIS_FREQ_RES),
                 &echo1xtg, 0);
 
    if(PSdebugstate)
    {
        printf("\nXTG Slthick = %f xFOV = %f yFOV = %f Xmit location = %f, Rcv location  = %f, Phase off = %f\n", 
               TGopslthick, TGopslthickx, TGopslthicky, PStloc_mod, PSrloc_mod, PSphasoff_mod);

        printf("\nXTG Xmit Freq = %f, Rcv Freq  = %f\n", (float)slice_freq1, (float)rcv_freq);
        printf("%s\n","XTG Rotation Matrix:");
        printf("\t %6ld %6ld %6ld \n", PSrot_mod[0][0], PSrot_mod[0][1], PSrot_mod[0][2]);
        printf("\t %6ld %6ld %6ld \n", PSrot_mod[0][3], PSrot_mod[0][4], PSrot_mod[0][5]);
        printf("\t %6ld %6ld %6ld \n", PSrot_mod[0][6], PSrot_mod[0][7], PSrot_mod[0][8]);
        fflush(stdout);
        printf("XTG: psc_vol_index = %d\n",psc_vol_index );
    }

    rf4xtg_freq = (int)(xtg_offres_freq/TARDIS_FREQ_RES);
    rf3xtg_freq = rf4xtg_freq;

    if(L_MPS1 == rspent)  /* set it off for MPS1 */
    {
        setiamp(0, &rf3xtg, 0);
        setiamp(0, &rf4xtg, 0);
    }
    else
    {
        setiamp(-ia_rf4xtg, &rf3xtg, 0);
        setiamp(ia_rf4xtg, &rf4xtg, 0);
    }

    for (view = (-xtg_disdaqs + 1) ; view <= xtg_views; view ++)
    {
        if( PSdebugstate )
        {
            printf("XTG: view = %d\n",view);
        }

        if(view == (-xtg_disdaqs + 1))
        {
            getiamp(&temp_short, &rf4xtg, 0);
            if(temp_short < 0.0)
            {
                setiamp(-temp_short, &rf4xtg, 0);
                getiamp(&temp_short, &rf3xtg, 0);
                setiamp(-temp_short, &rf3xtg, 0);
            }
            getiamp(&temp_short, &rf1xtg, 0);
            if(temp_short < 0.0)
            {
                setiamp(-temp_short, &rf1xtg, 0);
            }
        }

        for (excitation = 1; excitation <= xtg_nex; excitation ++)
        {
            if (view > 0)
            {
                if (excitation == 1)
                    attenlockon(&xtg_attenkey);
                if (excitation == xtg_nex)
                    attenlockoff(&xtg_attenkey);
                if(XTGacq1 == PSD_ON)
                {
                    xtg_acq1 = (int)DABON;
                }
            }
            else
            {
                xtg_acq1 = (int)DABOFF;
            }
 
            /* DAB packet is not used in prescan.  loaddab
               is used just to turn on or off the receiver */
            loaddab(&echo1xtg, (INT)1,(INT)1,(INT)1,(INT)1,
                    (TYPDAB_PACKETS)xtg_acq1, PSD_LOAD_DAB_ALL);

            /* For SWIFT(expresstg): We are trying not to use the CV opswift.
               Instead use psc_vol_index.
               */
            if( (psc_vol_index > 0) && (opvquant > 1) )
            {
                if( old_psc_vol_index != psc_vol_index )
                {
                    /* No need to switch coil*/
                    if( noswitch_slab_psc == PSD_OFF )
                    {
                        rsp_PStloc = rsp_info[psc_vol_index-1].rsptloc;
                        rsp_PSrloc = rsp_info[psc_vol_index-1].rsprloc;
                        rsp_PSphasoff = rsp_info[psc_vol_index-1].rspphasoff;
                    }
                    else
                    {
                        rsp_PStloc = rsp_info[PStest_slab-1].rsptloc;
                        rsp_PSrloc = rsp_info[PStest_slab-1].rsprloc;
                        rsp_PSphasoff = rsp_info[PStest_slab-1].rspphasoff;
                    }

                    {
                        char tempstr[200]={0};
                        sprintf(tempstr,"eXpresstgcore: psc_vol_index=%d,rsp_PStloc=%f\n",psc_vol_index,rsp_PStloc);
                        printdbg(tempstr,PSdebugstate);
                    }
                    old_psc_vol_index = psc_vol_index;
                }
            }

            if(PSD_ON == local_tg)
            {
                slice_freq1 = (int)(GAM * a_gyrf1xtg * rsp_PSphasoff/
                                    (10* TARDIS_FREQ_RES)); /* factor 10 is because rsptloc is in mm */
            }
            else
            {
                slice_freq1 = (int)(GAM * a_gzrf1xtg * rsp_PStloc/
                                    (10* TARDIS_FREQ_RES)); /* factor 10 is because rsptloc is in mm */
            }

            slice_freq2 = (int)(GAM * a_gzrf2xtg * rsp_PStloc/
                                (10* TARDIS_FREQ_RES)); /* factor 10 is because rsptloc is in mm */
            rcv_freq = (int)(2*1000*XTGecho1bw*rsp_PSrloc/ XTGfov);
            
            setfrequency(slice_freq1, &rf1xtg,0);
            setfrequency(slice_freq2, &rf2xtg,0);
            setfrequency((INT)((rcv_freq + PSfreq_offset[rspent])/TARDIS_FREQ_RES),
                         &echo1xtg, 0);

            /* phase and freq cycling  */
            if(view%2 == 1) /* freq and phase cycling */
            {
                setfrequency(rf4xtg_freq, &rf4xtg, 0);
                setfrequency((-rf3xtg_freq), &rf3xtg, 0);

                /* phase cycling */
                getiamp(&temp_short, &rf4xtg, 0);
                setiamp(-temp_short, &rf4xtg, 0);
                getiamp(&temp_short, &rf3xtg, 0);
                setiamp(-temp_short, &rf3xtg, 0);
            }
            else
            {
                setfrequency((-rf4xtg_freq), &rf4xtg, 0);
                setfrequency(rf3xtg_freq, &rf3xtg, 0);
            }
            
            /* Makesure psc_vol_index is in range */
            if( (psc_vol_index > 0 && psc_vol_index <= opvquant) && (opvquant > 1)) 
            {
                if(noswitch_slab_psc == PSD_OFF)
                    startseq((short)(psc_vol_index-1), (SHORT)MAY_PAUSE);
                else
                    startseq((short)(PStest_slab-1),(SHORT)MAY_PAUSE);
            }
            else
                startseq((short)0, (SHORT)MAY_PAUSE);

            printdbg("S", (SHORT)xtg_debug);
            syncoff(&seqxtg);
 
            /* Chopper logic */
            getiamp(&temp_short, &rf1xtg,0);
            setiamp((-temp_short),&rf1xtg,0);

            if (view < 1)
            {
                break; /* Skip excitation loop for disdaqs */
            }
 
        }  /* end excitation */
 
    }  /* end view */

    return SUCCESS;
}   /* end eXpressTGCore() */


/*
 *  ASautoshim
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
ASautoshim( INT rspsct_ )
{
    SHORT temp_short;
    INT dix_shift;

    INT phase_step[3];
    INT phase_sign[3];
    INT yres_phase;

    long asrottemp[3][9]; /* vmx 3/6/95 YI */
    INT *rf1_freq;
    INT *receive_freq1;
    SHORT viewtable[513];
    long trigger_temp[3]; /* vmx 10/13/94 YI */
    INT acquire_echo1;
    INT dab_view,dab_op;
    SHORT disdaqs;
    FLOAT tempGAM;

    printdbg("Greetings from autoshim", PSdebugstate);
    boffset(off_seqaushim);

    disdaqs = as_dda;
    tempGAM = GAM;
    GAM = GAMMA_PROTON; /*only shim on proton*/

    /**************************************************************
      so here's how we loop through this entry point:

        pass = rspslq;               each slice is a pass
        for all slices
           for all views              
             (first echo)           note: these aren't really 2echos,
             reset dixon shift to 0       we just pretend they are.
             do the disdaqs               there's really a separate
             do the baselines             excitation for each 'echo'.
             collect the data 'echo'
             (second echo)
             do dixon shift
             do the disdaqs
             do the baselines
             collect the data 'echo'
           next view
           decrement pass
           send pass packet
        next slice
        send end of scan packet
     ******************************************************************/

    setrfconfig((short) 5);

    /* Allocate memory for various arrays.
     * An extra 2 locations are saved in case the user wants to do
     * some tricks. */
    rf1_freq = (int *)AllocNode((as_slquant + 2)*sizeof(int));
    receive_freq1 = (int *)AllocNode((as_slquant + 2)*sizeof(int));

    rf1_freq[0] = (int)(astloc1*GAM * a_gzrf1as/(10 * TARDIS_FREQ_RES));
    rf1_freq[1] = (int)(astloc2*GAM * a_gzrf1as/(10 * TARDIS_FREQ_RES));
    rf1_freq[2] = (int)(astloc3*GAM * a_gzrf1as/(10 * TARDIS_FREQ_RES));

    asrottemp[0][0] = hostToRspRotMat( asrot0 );  asrottemp[0][1] = hostToRspRotMat( asrot1 ); asrottemp[0][2] = hostToRspRotMat( asrot2 );  
    asrottemp[0][3] = hostToRspRotMat( asrot3 );  asrottemp[0][4] = hostToRspRotMat( asrot4 ); asrottemp[0][5] = hostToRspRotMat( asrot5 );
    asrottemp[0][6] = hostToRspRotMat( asrot6 );  asrottemp[0][7] = hostToRspRotMat( asrot7 ); asrottemp[0][8] = hostToRspRotMat( asrot8 );

    asrottemp[1][0] = hostToRspRotMat( asrot9 );  asrottemp[1][1] = hostToRspRotMat( asrot10 ); asrottemp[1][2] = hostToRspRotMat( asrot11 ); 
    asrottemp[1][3] = hostToRspRotMat( asrot12 ); asrottemp[1][4] = hostToRspRotMat( asrot13 ); asrottemp[1][5] = hostToRspRotMat( asrot14 );
    asrottemp[1][6] = hostToRspRotMat( asrot15 ); asrottemp[1][7] = hostToRspRotMat( asrot16 ); asrottemp[1][8] = hostToRspRotMat( asrot17 );

    asrottemp[2][0] = hostToRspRotMat( asrot18 ); asrottemp[2][1] = hostToRspRotMat( asrot19 ); asrottemp[2][2] = hostToRspRotMat( asrot20 ); 
    asrottemp[2][3] = hostToRspRotMat( asrot21 ); asrottemp[2][4] = hostToRspRotMat( asrot22 ); asrottemp[2][5] = hostToRspRotMat( asrot23 );
    asrottemp[2][6] = hostToRspRotMat( asrot24 ); asrottemp[2][7] = hostToRspRotMat( asrot25 ); asrottemp[2][8] = hostToRspRotMat( asrot26 );

    scalerotmats(asrottemp, &asloggrd, &phygrd, 3, asobl_debug);

    if(PSdebugstate)
    {
        printf("\n%d astlocs (1,2,3) -> %0f %0f %0f\n",
               as_slquant, astloc1, astloc2, astloc3);
        printf("\nrf1_freq (1,2,3) -> %d %d %d\n",
               rf1_freq[0], rf1_freq[1], rf1_freq[2]);
    }

    /* AutoShim Changes to Center Image always - HH- Sept 21, 2004 */
    /* Use asrot0 , asrot11 and asrot20 to decide on read and phase directions on the 3 planes */
    /* Slice 1 = Axial    - Z slice (astloc1) - X/Y read (astloc2/astloc3) - Y/X Phase (astloc3/astloc2) */
    /* Slice 2 = Sagittal - X slice (astloc2) - Z/Y read (astloc1/astloc3) - Y/Z Phase (astloc3/astloc1) */
    /* Slice 3 = Coronal  - Y slice (astloc3) - Z/X read (astloc1/astloc2) - X/Z Phase (astloc2/astloc1) */

/* Old Code */
    receive_freq1[0] = (int)((PSfreq_offset[rspent] +
                              ((2 * echo1bwas*1000/ (asfov))
                               * asrloc1))/ TARDIS_FREQ_RES);
    receive_freq1[1] = (int)((PSfreq_offset[rspent] +
                              ((2 * echo1bwas*1000/ (asfov))
                               * asrloc2))/ TARDIS_FREQ_RES);
    receive_freq1[2] = (int)((PSfreq_offset[rspent] +
                              ((2 * echo1bwas*1000/ (asfov))
                               * asrloc3))/ TARDIS_FREQ_RES);

    phase_sign[0] = (asploc1 >= 0) ? 1 : -1;
    phase_step[0] = (int)(.5 + fabs(FS_2PI*asploc1/asfov));
    phase_step[0] = (phase_step[0] + FS_2PI + FS_PI)%FS_2PI-FS_PI;

    phase_sign[1] = (asploc2 >= 0) ? 1 : -1;
    phase_step[1] = (int)(.5 + fabs(FS_2PI*asploc2/asfov));
    phase_step[1] = (phase_step[1] + FS_2PI + FS_PI)%FS_2PI-FS_PI;

    phase_sign[2] = (asploc3 >= 0) ? 1 : -1;
    phase_step[2] = (int)(.5 + fabs(FS_2PI*asploc3/asfov));
    phase_step[2] = (phase_step[2] + FS_2PI + FS_PI)%FS_2PI-FS_PI;

    trigger_temp[0] = TRIG_INTERN;
    trigger_temp[1] = TRIG_INTERN;
    trigger_temp[2] = TRIG_INTERN;

    setupphasetable(viewtable, TYPNORM,(int)asyres);


    /* Set ssi time.  This is time from eos to start of sequence   */
    /* interrupt in internal triggering.  The minimum time is 50us */
    /* plus 2us*(number of waveform and instruction words modified */
    /* in the update queue).                                       */
    setssitime((LONG)time_ssias/HW_GRAD_UPDATE_TIME);

    settriggerarray(as_slquant, trigger_temp);

    if(PSdebugstate)
    {
        printf("\n AUTOSHIM VOLUME INDEX:  %d\n", as_index); 
        printf("\n AUTOSHIM:  FOV = %f astloc1 = %f, astloc2 = %f  astloc3  = %f\n", asfov, astloc1,astloc2,astloc3); 
        printf("\n AUTOSHIM:  asrloc1 = %f, asrloc2 = %f  asrloc3  = %f\n", asrloc1,asrloc2,asrloc3); 
        printf("\n AUTOSHIM:  asploc1 = %f, asploc2 = %f  asploc3  = %f\n", asploc1,asploc2,asploc3); 
        printf("\n AUTOSHIM:  asdim1 = %f, asdim2 = %f  asdim3  = %f\n", asdim1,asdim2,asdim3); 
        printf("%s\n", "AUTOSHIM:  Slice 1 Rotation Matrix");
        printf("\t %6ld  %6ld  %6ld\n", asrottemp[0][0],asrottemp[0][1],asrottemp[0][2]);
        printf("\t %6ld  %6ld  %6ld\n", asrottemp[0][3],asrottemp[0][4],asrottemp[0][5]);
        printf("\t %6ld  %6ld  %6ld\n", asrottemp[0][6],asrottemp[0][7],asrottemp[0][8]);
        printf("%s\n", "AUTOSHIM:  Slice 2 Rotation Matrix");
        printf("\t %6ld  %6ld  %6ld\n", asrottemp[1][0],asrottemp[1][1],asrottemp[1][2]);
        printf("\t %6ld  %6ld  %6ld\n", asrottemp[1][3],asrottemp[1][4],asrottemp[1][5]);
        printf("\t %6ld  %6ld  %6ld\n", asrottemp[1][6],asrottemp[1][7],asrottemp[1][8]);
        printf("%s\n", "AUTOSHIM:  Slice 3 Rotation Matrix");
        printf("\t %6ld  %6ld  %6ld\n", asrottemp[2][0],asrottemp[2][1],asrottemp[2][2]);
        printf("\t %6ld  %6ld  %6ld\n", asrottemp[2][3],asrottemp[2][4],asrottemp[2][5]);
        printf("\t %6ld  %6ld  %6ld\n", asrottemp[2][6],asrottemp[2][7],asrottemp[2][8]);

        printf("\n AUTOSHIM SLICE1:   slice loc= %f read loc= %f phase loc= %f \n", astloc1, asrloc1, asploc1); 
        printf("\n AUTOSHIM SLICE2:   slice loc= %f read loc= %f phase loc= %f \n", astloc2, asrloc2, asploc2); 
        printf("\n AUTOSHIM SLICE3:   slice loc= %f read loc= %f phase loc= %f \n", astloc3, asrloc3, asploc3); 

        fflush(stdout);
    }

    setrotatearray(as_slquant,asrottemp[0]);

    /* Reset scope and attenuator lock*/
    attenlockon(&attenuator_keyas);
    scopeon(&seqaushim);

    /* Reset all the synchronizations  - no need to use one in pass */
    syncon(&seqaushim);
    syncoff(&seqpassas);


    for (as_slice = 0; as_slice < as_slquant; as_slice++)
    {
        dab_op = DABSTORE;

        setiamp((short)(ia_rf1as*flip_pctas), &rf1as, 0);

        for (as_view=(-(disdaqs+asbaseline)+1); as_view<= asyres; as_view++)
        {
            /* Collect baseline first and set RF to 0 for baseline collection */
            if (as_view <= -disdaqs)
            {
                setiamp((short)0, &rf1as, 0);
            }
            else if (as_view == -disdaqs+1) /* Disdaq collection after baseline and set RF amp for disdaqs/data acq */
            {
                setiamp((short)(ia_rf1as*flip_pctas), &rf1as, 0);
            }

            if (as_view<=0)
            {
                /* for the baselines in each slice, set the phase encode
                   amplitude to the first view */
                /* HSI change to setiampt from setiamp */
                setiampt(-viewtable[1], &gy1as, 0);
                setiampt(viewtable[1], &gy1ras, 0);

                setiphase(0,&echo1as,0);
            }
            else
            {
                /* HSI change to setiampt from setiamp */
                setiampt(-viewtable[as_view], &gy1as, 0);
                setiampt(viewtable[as_view], &gy1ras, 0);

                setiphase(0,&echo1as,0);
                yres_phase = -phase_sign[as_slice]*(((as_view-1)* phase_step[as_slice] + 3L*FS_PI)%FS_2PI-FS_PI);
                setiphase(yres_phase, &echo1as, 0);
            }
            for (as_excitation=1; as_excitation <= 1; as_excitation++)
            {
                /* Scope Trigger */
                if ((rspsct_ == as_slice) || (rspsct_ == -1))
                {
                    scopeon(&seqaushim);
                }
                else
                {
                    scopeoff(&seqaushim);
                }
                /*MRIge33520 - VB*/
                acquire_echo1 = DABON; /* ON for baseline */
                if ((as_view > -disdaqs) && (as_view <= 0))  /* DABOFF for disdaq */
                {
                    acquire_echo1 = (int)DABOFF;
                }

                /* Load Transmit and Receive frequencies */
                setfrequency(rf1_freq[as_slice], &rf1as, 0);
                setfrequency(receive_freq1[as_slice], &echo1as, 0);

                if (as_view > 0)
                {
                    dab_view = as_view;
                    if (as_excitation == 1)
                    {
                        dab_op = 0;
                    }
                    else
                    {
                        dab_op = 3 - 2*(as_excitation % 2);
                    }
                }
                else
                {
                    dab_op = 0;
                    dab_view = 0;
                }

                /* set up the dixon shift for every other seq */
                for(dixon=0;dixon<=1;++dixon)
                {
                    dix_shift = (dixon % 2)*RUP_GRD((dix_timeas))+GRAD_UPDATE_TIME;
                    setperiod(dix_shift,&xdixon,0);
                    setperiod(dix_shift,&ydixon,0);
                    setperiod(dix_shift,&zdixon,0);
                    setperiod(dix_shift,&sdixon,0);
                    setperiod((int)(dix_shift - dixon*dix_timeas),&sdixon2,0);
                    /* All DAB Info is Set. Pretend even views are 2nd echo. */
                    /* Load up dab packet!                                   */
                    loaddab(&echo1as,(short)0,dixon,dab_op,dab_view,(TYPDAB_PACKETS)acquire_echo1, PSD_LOAD_DAB_ALL);

                    startseq((short)as_slice, (short)MAY_PAUSE);

                    syncoff(&seqaushim);
                }

                getiamp(&temp_short, &rf1as, 0);
                setiamp(-temp_short, &rf1as, 0);

            } /* as_excitation */

        }  /* as_view */


        boffset(off_seqpassas);
        if (as_slice == (as_slquant-1)  ) /* Last pass */
        {
            /* Set DAB pass packet to end of scan */
            setwamp(SSPD + DABPASS + DABSCAN, &pass_aushim, 2);
            printdbg("End of Scan and Pass", PSdebugstate);
        }
        else
        {
            /* Set DAB pass packet to end of pass */
            setwamp(SSPD + DABPASS, &pass_aushim, 2);
            printdbg("End of Pass", PSdebugstate);
        }


        startseq((short)0, (short)MAY_PAUSE);
        boffset(off_seqaushim);

    }

    /* Reset the rotation matrix */
    setrotatearray((short)opslquant,rsprot[0]);

    GAM = tempGAM;

    printdbg("Normal End of autoshim", PSdebugstate);

    return SUCCESS;
} /* End of ASautoshim */

/*
 *  PSrfshim
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
PSrfshim( void )
{
    INT *rf1rs_freq;
    INT *rec_freq1rs;
    INT rs_slice, rs_view, DD_loop, tmp_DD_nCh;
    long rs_trigger[128];
    SHORT viewtable[128];
    SHORT viewtab[128];
    INT phase_off[128]; 
    INT phase_sign[128]; 
    INT rs_yres_phase, rs_trains; 
    INT rs_yres_phase2toN[16];
    INT dab_view,dab_op, dabechors;
    INT acq_echors;
    INT i, tempi, rs_seq_count, rs_exphase, rs_rcphase;
    INT train_idx, bls_idx, yoffs1;
    char psddbgstr[256] = "";

    printdbg("Greetings from RFShim B1 Map", PSdebugstate);
    rspdda = rs_dda;
    rspsct = 0;

    rs_trains = rfshim_yres/rfshim_etl;

    boffset(off_seqrs);

    dabechors = 0;
    rs_seq_count = 1;
    rs_exphase = 0;

    /* set up phase offset arrays */
    for (i = 0; i < rfshim_slquant; i++)
    {
        if (rsrsp_info[i].rspphasoff >= 0.0)
            phase_sign[i] = -1;
        else
            phase_sign[i] = 1;
        /* phase offset increment */
        yoffs1 = (int)(.5 + fabs(FS_2PI*rsrsp_info[i].rspphasoff/rfshim_fov));
        /* offset in range */
        phase_off[i] = (yoffs1 + FS_2PI + FS_PI)%FS_2PI-FS_PI;
    }

    rf1rs_freq = (int *)AllocNode((rfshim_slquant + 2)*sizeof(int));
    rec_freq1rs = (int *)AllocNode((rfshim_slquant + 2)*sizeof(int));

    setupslices(rf1rs_freq, rsrsp_info, rfshim_slquant, a_gzrf1rs,
                               (float)1, rfshim_fov, TYPTRANSMIT);

    setupslices(rec_freq1rs, rsrsp_info, rfshim_slquant, (float)0,
                echo1bwrs, rfshim_fov, TYPREC);

    setupphasetable(viewtable, TYPNORM,(int)rfshim_yres);
    phase_ordering(viewtab, rsphorder, rfshim_yres, rfshim_etl);  /* CENTRIC view ordering */

    setiampt(0, &gy1rs, 0);
    setiampt(0, &gy1rrs, 0);
    if(rfshim_etl >=2)
    {
        for(i=0;i<rfshim_etl-1;i++)
        {
            setiampt(0, &gy2rs, i);
        }
    }

    setiamp((short)ia_rf1rs, &rf1rs, 0);
    setiphase(0, &rf1rs, 0);

    setssitime((LONG)time_ssirs/HW_GRAD_UPDATE_TIME);

    for ( rs_slice = 0 ; rs_slice < rfshim_slquant; rs_slice++ )
    {
        rs_trigger[rs_slice] = (long)TRIG_INTERN;
    }
    settriggerarray((SHORT)rfshim_slquant, rs_trigger);

    setrotatearray((short)rfshim_slquant,rsrsprot[0]);

    /* Reset scope and attenuator lock*/
    attenlockon(&attenuator_keyrs);

    /* Reset all the synchronizations  - no need to use one in pass */
    syncon(&seqrs);
    syncoff(&seqpassrs);

    for (rs_slice = 0; rs_slice < rfshim_slquant; rs_slice++)
    {
        tmp_DD_nCh = DD_nCh;

        if(PSdebugstate && (rs_slice >= 0))
        {
            printf("\n RFShim Sls = %i FOV = %f  slthick = %f\n", rfshim_slquant, rfshim_fov, rfshim_slthick);
            printf("\n RFShim Offsets: Tx = %f Rx = %f Phase = %f\n", rsrsp_info[rs_slice].rsptloc, 
                   rsrsp_info[rs_slice].rsprloc, rsrsp_info[rs_slice].rspphasoff);
            printf("%s\n"," RFShim Rotation Matrix:");
            printf("\t %6ld %6ld %6ld \n", rsrsprot[0][0], rsrsprot[0][1], rsrsprot[0][2]);
            printf("\t %6ld %6ld %6ld \n", rsrsprot[0][3], rsrsprot[0][4], rsrsprot[0][5]);
            printf("\t %6ld %6ld %6ld \n", rsrsprot[0][6], rsrsprot[0][7], rsrsprot[0][8]);
            fflush(stdout);
        }

        dab_op = DABSTORE;

        setiamp((short)ia_rf1rs, &rf1rs, 0);

        for (DD_loop=0;DD_loop<tmp_DD_nCh;DD_loop++)
        {
            if ((B1Cal_mode) || (0!=DD_debug))
            {
                boffset(off_seqIQControl);

                if(B1Cal_mode)
                {
                    if (0==(DD_loop%2))
                    {   /* Turn off Q channel */
                        setwamp(SSPD|DDQOFF, &dDDIQ, 2);
                    }
                    else
                    {   /* Turn off I channel */
                        setwamp(SSPD|DDIOFF, &dDDIQ, 2);
                    }
                }
                else
                {
                    if (1==DD_debug)
                    {   /* Turn off Q channel */
                        setwamp(SSPD|DDQOFF, &dDDIQ, 2);
                    }
                    else
                    {   /* Turn off I channel */
                        setwamp(SSPD|DDIOFF, &dDDIQ, 2);
                    }
                }

                settrigger((short)TRIG_INTERN, (short)0);

                startseq((SHORT)0,(SHORT)MAY_PAUSE);
            }

            boffset(off_seqrs);

            for (train_idx=(-(rs_dda+rfshim_baseline)+1); train_idx<= rs_trains; train_idx++)
            {
                if (train_idx > 0)
                {
                    rs_view = (train_idx-1)*rfshim_etl;
                    dab_view = viewtab[rs_view];

                    setiampt(-viewtable[dab_view], &gy1rs, 0);

                    if(rfshim_etl>=2)
                    {
                        for(tempi=0;tempi<rfshim_etl-1;tempi++)
                        {
                            setiampt(viewtable[viewtab[rs_view+tempi]]-viewtable[viewtab[rs_view+1+tempi]], &gy2rs, tempi);
                        }
                        setiampt(viewtable[viewtab[rs_view+rfshim_etl-1]], &gy1rrs, 0);
                    }
                    else
                    {
                        setiampt(viewtable[dab_view], &gy1rrs, 0);
                    }
                }
                else
                {
                    rs_view = 0;
                    dab_view = 0;
                }

                for (bls_idx = 0; bls_idx < 2; bls_idx++)
                {
                    dabechors = bls_idx;

                    if (0==bls_idx)
                    {
                        setiamp(ia_thetarfbrs, &thetarfbrs, 0);
                    }
                    else
                    {
                        setiamp(-ia_thetarfbrs, &thetarfbrs, 0);
                    }

                    dab_op = DABSTORE;


                    for (excitation=1; excitation <= 1; excitation++)
                    {
                        /* Scope Trigger */
                        if ((rspsct == rs_slice) || (rspsct == -1))
                        {
                            scopeon(&seqrs);
                        }
                        else
                        {
                            scopeoff(&seqrs);
                        }

                        if (train_idx > 0)
                        {
                            acq_echors = (int)DABON;
                        }
                        else
                        {
                            acq_echors = (int)DABOFF;
                        }

                        /* Load Transmit and Receive frequencies */
                        setfrequency(rf1rs_freq[rs_slice], &rf1rs, 0);
                        setfrequency(rec_freq1rs[rs_slice], &echo1rs, 0);

                        if (rfshim_etl>=2)
                        {
                            for(tempi=0;tempi<(rfshim_etl-1);tempi++)
                            {
                                setfrequency(rec_freq1rs[rs_slice], &(rs_echo2toN[tempi]), 0);
                            }
                        }

                        if (train_idx > 0)
                        {
                            if (excitation == 1)
                            {
                                dab_op = 0;
                            }
                            else
                            {
                                dab_op = 3 - 2*(excitation % 2);
                            }

                            rs_yres_phase = phase_sign[rs_slice]*(((dab_view-1)*
                                                                   phase_off[rs_slice] + 3L*FS_PI)%FS_2PI-FS_PI);
                        }
                        else
                        {
                            rs_yres_phase = 0;
                        }

                        if(rsspgr_flag)
                        {
                            rs_exphase = ((int)((float)rs_exphase + (float)rs_seq_count*ps_seed + 3L*FS_PI) % FS_2PI)-FS_PI;
                            rs_seq_count++;
                        }
                        else
                        {
                            rs_exphase = 0;
                        }
                        setiphase(rs_exphase, &rf1rs, 0);

                        rs_rcphase = (rs_exphase + rs_yres_phase + 4L*FS_PI)%FS_2PI - FS_PI;
                        setiphase(rs_rcphase, &echo1rs, 0);

                        if(rfshim_etl>=2)
                        {
                            for(tempi=0;tempi<rfshim_etl-1; tempi++)
                            {
                                rs_yres_phase2toN[tempi] = phase_sign[rs_slice]*
                                    (((viewtab[rs_view+tempi+1]-1)*phase_off[rs_slice] + 3L*FS_PI)%FS_2PI-FS_PI);

                                rs_yres_phase2toN[tempi] = (rs_exphase + rs_yres_phase2toN[tempi]+ 4L*FS_PI)%FS_2PI - FS_PI;
                                if (PSdebugstate)
                                {
                                    sprintf(psddbgstr,"yres_phase2toN[%d]=%d\n",tempi,rs_yres_phase2toN[tempi]);
                                    printdbg(psddbgstr, PSdebugstate);
                                    sprintf(psddbgstr,"view=%d;  slice=%d\n",rs_view, rs_slice);
                                    printdbg(psddbgstr, PSdebugstate);
                                }

                                setiphase(rs_yres_phase2toN[tempi], &(rs_echo2toN[tempi]), 0);  /* yres phase */
                            }
                        }

                        /* Load up dab packet */
                        loaddab(&echo1rs,(short)0,dabechors+DD_loop*2,dab_op,dab_view,(TYPDAB_PACKETS)acq_echors, PSD_LOAD_DAB_ALL);
                        if(rfshim_etl>=2)
                        {
                            INT temp_dabview;

                            for(tempi=0;tempi<rfshim_etl-1; tempi++)
                            {
                                temp_dabview = viewtab[rs_view+tempi+1];
                                loaddab(&rs_echo2toN[tempi],(short)0,dabechors+DD_loop*2,dab_op,temp_dabview,(TYPDAB_PACKETS)acq_echors, PSD_LOAD_DAB_ALL);
                            }
                        }

                        startseq((short)rs_slice, (short)MAY_PAUSE);

                        syncoff(&seqrs);

                    } /* excitation */
                } /* End of BLS cycling loop */

            }  /* End of Echo Train train_idx loop */

        }/* DD loop */

        boffset(off_seqpassrs);
        if (rs_slice == (rfshim_slquant-1)) /* Last pass */
        {
            /* Set DAB pass packet to end of scan */
            setwamp(SSPD + DABPASS + DABSCAN, &pass_rs, 2);
            printdbg("End of Scan and Pass", PSdebugstate);
        }
        else if (rs_slice >=0)
        {
            /* Set DAB pass packet to end of pass */
            setwamp(SSPD + DABPASS, &pass_rs, 2);
            printdbg("End of Pass", PSdebugstate);
        }
        else 
        {
            /* Set DAB pass packet to end of pass */
            setwamp(SSPD, &pass_rs, 2);
            printdbg("dummy slice", PSdebugstate);
        }

        startseq((short)0, (short)MAY_PAUSE);

        boffset(off_seqrs);

        if (B1Cal_mode && (rs_slice == (rfshim_slquant-1)))
        {
            boffset(off_seqIQControl);

            /* Enable I & Q channels again */
            setwamp(SSPD, &dDDIQ, 2);

            settrigger((short)TRIG_INTERN, (short)0);

            startseq((SHORT)0,(SHORT)MAY_PAUSE);
        }

    } /* End of slice loop */

    printdbg("Normal End of RFShim Map", PSdebugstate);

    return SUCCESS;
}   /* end PSrfshim() */


/*
 *  PSdyntg
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
PSdyntg( void )
{
    INT *rf1dtg_freq;
    INT *rec_freq1dtg;
    INT dtg_slice, dtg_trains;
    INT train_idx, bls_idx;
    INT tempi;
    long dtg_trigger[128];
    SHORT viewtable[128];
    SHORT viewtab[128];
    INT phase_off[128]; 
    INT phase_sign[128]; 
    INT dtg_yres_phase; 
    INT dtg_yres_phase2toN[16];
    INT dtg_view, dab_view, dab_op, dabechodtg;
    INT acq_echodtg;
    INT i, dtg_seq_count, dtg_exphase, dtg_rcphase, yoffs1;
    char psddbgstr[256] = "";

    if(L_MAPTG == rspent)
    {
        printdbg("Greetings from mapTg B1Map", PSdebugstate);
    }
    else
    {
        printdbg("Greetings from dynTG B1Map", PSdebugstate);
    }
    rspdda = dtg_dda;
    rspsct = 0;

    dtg_trains = dynTG_yres/dynTG_etl;

    boffset(off_seqdtg);

    dabechodtg = 0;
    dtg_seq_count = 1;
    dtg_exphase = 0;

    /* set up phase offset arrays */
    for (i = 0; i < dynTG_slquant; i++)
    {
        if (dtgrsp_info[i].rspphasoff >= 0.0)
            phase_sign[i] = -1;
        else
            phase_sign[i] = 1;
        /* phase offset increment */
        yoffs1 = (int)(.5 + fabs(FS_2PI*dtgrsp_info[i].rspphasoff/dynTG_fov));
        /* offset in range */
        phase_off[i] = (yoffs1 + FS_2PI + FS_PI)%FS_2PI-FS_PI;
    }

    rf1dtg_freq = (int *)AllocNode((dynTG_slquant + 2)*sizeof(int));
    rec_freq1dtg = (int *)AllocNode((dynTG_slquant + 2)*sizeof(int));

    setupslices(rf1dtg_freq, dtgrsp_info, dynTG_slquant, a_gzrf1dtg,
                               (float)1, dynTG_fov, TYPTRANSMIT);

    setupslices(rec_freq1dtg, dtgrsp_info, dynTG_slquant, (float)0,
                echo1bwdtg, dynTG_fov, TYPREC);

    setupphasetable(viewtable, TYPNORM,(int)dynTG_yres);
    phase_ordering(viewtab, dtgphorder, dynTG_yres, dynTG_etl);  /* CENTRIC view ordering */

    setiampt(0, &gy1dtg, 0);
    setiampt(0, &gy1rdtg, 0);
    if(dynTG_etl>=2)
    {
        for(tempi=0;tempi<dynTG_etl-1;tempi++)
        {
            setiampt(0, &gy2dtg, tempi);
        }
    }

    setiamp((short)ia_rf1dtg, &rf1dtg, 0);
    setiphase(0, &rf1dtg, 0);

    setssitime((LONG)time_ssidtg/HW_GRAD_UPDATE_TIME);

    for ( dtg_slice = 0 ; dtg_slice < dynTG_slquant; dtg_slice++ )
    {
        dtg_trigger[dtg_slice] = (long)TRIG_INTERN;
    }
    settriggerarray((SHORT)dynTG_slquant, dtg_trigger);

    setrotatearray((short)dynTG_slquant,dtgrsprot[0]);

    /* Reset scope and attenuator lock*/
    attenlockon(&attenuator_keydtg);
    scopeon(&seqdtg);

    /* Reset all the synchronizations  - no need to use one in pass */
    syncon(&seqdtg);
    syncoff(&seqpassdtg);

    boffset(off_seqdtg);

    for (dtg_slice = 0; dtg_slice < dynTG_slquant; dtg_slice++)
    {
        if(PSdebugstate && (dtg_slice >= 0))
        {
            printf("\n DynTG Sls = %i FOV = %f  slthick = %f\n", dynTG_slquant, dynTG_fov, dynTG_slthick);
            printf("\n DynTG Offsets: Tx = %f Rx = %f Phase = %f\n", dtgrsp_info[dtg_slice].rsptloc, 
                   dtgrsp_info[dtg_slice].rsprloc, dtgrsp_info[dtg_slice].rspphasoff);
            printf("%s\n"," DynTG Rotation Matrix:");
            printf("\t %6ld %6ld %6ld \n", dtgrsprot[0][0], dtgrsprot[0][1], dtgrsprot[0][2]);
            printf("\t %6ld %6ld %6ld \n", dtgrsprot[0][3], dtgrsprot[0][4], dtgrsprot[0][5]);
            printf("\t %6ld %6ld %6ld \n", dtgrsprot[0][6], dtgrsprot[0][7], dtgrsprot[0][8]);
            fflush(stdout);
        }
        for (train_idx=-rspdda-dynTG_baseline; train_idx<= dtg_trains; train_idx++)
        {

            if (train_idx > 0)
            {
                dtg_view = (train_idx-1)*dynTG_etl;
                dab_view = viewtab[dtg_view];

                /* If after disdaqs, set phase encoding gradients. */
                setiampt(-viewtable[dab_view], &gy1dtg, 0);

                if(dynTG_etl>=2)
                {
                    for(tempi=0;tempi<dynTG_etl-1;tempi++)
                    {
                        setiampt(viewtable[viewtab[dtg_view+tempi]]-viewtable[viewtab[dtg_view+1+tempi]], &gy2dtg, tempi);
                    }
                    setiampt(viewtable[viewtab[dtg_view+dynTG_etl-1]], &gy1rdtg, 0);
                }
                else
                {
                    setiampt(viewtable[dab_view], &gy1rdtg, 0);
                }
            }
            else
            {
                dtg_view = 0;
                dab_view = 0;
            }

            /* BLS cycling loop */
            for (bls_idx = 0; bls_idx < 2; bls_idx++)
            {
                dabechodtg = bls_idx;

                if (0==bls_idx)
                {
                    setiamp(ia_thetarfbdtg, &thetarfbdtg, 0);
                }
                else
                {
                    setiamp(-ia_thetarfbdtg, &thetarfbdtg, 0);
                }

                dab_op = DABSTORE;


                for (excitation=1; excitation <= 1; excitation++)
                {
                    /* Scope Trigger */
                    if ((rspsct == dtg_slice) || (rspsct == -1))
                    {
                        scopeon(&seqdtg);
                    }
                    else
                    {
                        scopeoff(&seqdtg);
                    }

                    if (train_idx > 0)
                    {
                        acq_echodtg = (int)DABON;
                    }
                    else
                    {
                        acq_echodtg = (int)DABOFF;
                    }

                    /* Load Transmit and Receive frequencies */
                    setfrequency(rf1dtg_freq[dtg_slice], &rf1dtg, 0);
                    setfrequency(rec_freq1dtg[dtg_slice], &echo1dtg, 0);
                    if (dynTG_etl>=2)
                    {
                        for(tempi=0;tempi<(dynTG_etl-1);tempi++)
                        {
                            setfrequency(rec_freq1dtg[dtg_slice], &(dtg_echo2toN[tempi]), 0);
                        } 
                    }

                    if (train_idx > 0)
                    {
                        if (excitation == 1)
                        {
                            dab_op = 0;
                        }
                        else
                        {
                            dab_op = 3 - 2*(excitation % 2);
                        }

                        dtg_yres_phase = phase_sign[dtg_slice]*(((dab_view-1)*
                                                                 phase_off[dtg_slice] + 3L*FS_PI)%FS_2PI-FS_PI);
                    }
                    else
                    {
                        dtg_yres_phase = 0;
                    }

                    if(dtgspgr_flag)
                    {
                        dtg_exphase = ((int)((float)dtg_exphase + (float)dtg_seq_count*ps_seed + 3L*FS_PI) % FS_2PI)-FS_PI;
                        dtg_seq_count++;
                    }
                    else
                    {
                        dtg_exphase = 0;
                    }
                    setiphase(dtg_exphase, &rf1dtg, 0);

                    dtg_rcphase = (dtg_exphase + dtg_yres_phase + 4L*FS_PI)%FS_2PI - FS_PI;
                    setiphase(dtg_rcphase, &echo1dtg, 0);
                    if(dynTG_etl>=2)
                    {
                        for(tempi=0;tempi<dynTG_etl-1; tempi++)
                        {
                            dtg_yres_phase2toN[tempi] = phase_sign[dtg_slice]*
                                (((viewtab[dtg_view+tempi+1]-1)*phase_off[dtg_slice] + 3L*FS_PI)%FS_2PI-FS_PI);

                            dtg_yres_phase2toN[tempi] = (dtg_exphase + dtg_yres_phase2toN[tempi]+ 4L*FS_PI)%FS_2PI - FS_PI;
                            setiphase(dtg_yres_phase2toN[tempi], &(dtg_echo2toN[tempi]), 0);  /* yres phase */
                            if (PSdebugstate)
                            {
                                sprintf(psddbgstr,"yres_phase2toN[%d]=%d\n",tempi,dtg_yres_phase2toN[tempi]);
                                printdbg(psddbgstr, PSdebugstate);
                            }

                        }
                    }

                    /* Load up dab packet */
                    loaddab(&echo1dtg,(short)0,dabechodtg,dab_op,dab_view,(TYPDAB_PACKETS)acq_echodtg, PSD_LOAD_DAB_ALL);

                    if(dynTG_etl>=2)
                    {
                        INT temp_dabview;
                        for(tempi=0;tempi<dynTG_etl-1; tempi++)
                        {
                            temp_dabview = viewtab[dtg_view+tempi+1];
                            loaddab(&dtg_echo2toN[tempi],(short)0,dabechodtg,dab_op,temp_dabview,(TYPDAB_PACKETS)acq_echodtg, PSD_LOAD_DAB_ALL);
                        }
                    }

                    startseq((short)dtg_slice, (short)MAY_PAUSE);

                    syncoff(&seqdtg);

                } /* excitation */
            }  /* End of BLS cycling loop */
        } /* End of Echo Train train_idx loop */

        /* now it is one pass for all dtg slices */
        boffset(off_seqpassdtg);
        if (dtg_slice == (dynTG_slquant-1))
        {
            setwamp(SSPD + DABPASS + DABSCAN, &pass_dtg, 2);
            printdbg("End of Scan and Pass", PSdebugstate);
        }
        else if (dtg_slice >=0)
        {
            setwamp(SSPD + DABPASS, &pass_dtg, 2);
            printdbg("End of Pass", PSdebugstate);
        }
        else 
        {
            setwamp(SSPD, &pass_dtg, 2);
            printdbg("dummy slice", PSdebugstate);
        }

        startseq((short)0, (short)MAY_PAUSE);

        boffset(off_seqdtg);

    } /* End of Slice dtg_slice loop */

    if(L_MAPTG == rspent)
    {
        printdbg("Normal End of mapTg B1Map", PSdebugstate);
    }
    else
    {
        printdbg("Normal End of dynTG B1Map", PSdebugstate);
    }

    return SUCCESS;
}   /* end PSdyntg() */


/*
 *  PSextcal
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
PSextcal( void )
{
    INT cal_sltab[CAL_SLTAB_MAX + 1];
    INT cal_slrtab[CAL_SLTAB_MAX + 1];
    SHORT cal_viewtab[CAL_SLTAB_MAX + 1];
    INT phase_off; 
    INT phase_sign; 
    INT zsign;
    INT zoffs1, zoffs;
    SHORT temp_short;
    long cal_trigger[CAL_SLTAB_MAX];
    INT caldabop;
    INT cal_acq;
    INT calsl_idx, calview_idx, calpass_idx, calcoil_idx, calnex_idx, longnex_idx;
    INT *calrf1_freq;
    INT *calrec_freq;
    INT cal_yphase;
    INT cal_zphase;
    INT cal_exphase;
    INT cal_rcphase;
    INT cal_seq_count;
    INT acq_passes;
    INT acq_nexs;
    INT acq_longnexs = 1;
    INT cal_superidx = 0;

    if(PSdebugstate)
    {

        {
            printf("\n AutoCal Sls = %i FOV = %f  slthick = %f\n", cal_slq, cal_fov, cal_slthick);
            printf("\n AutoCal: Tx = %f Rx = %f Phase = %f\n", calrsp_info[cal_slq/2].rsptloc,
                   calrsp_info[cal_slq/2].rsprloc, calrsp_info[cal_slq/2].rspphasoff);
            printf("%s\n"," AutoCal Rotation Matrix:");
            printf("\t %6ld %6ld %6ld \n", calrsprot[0][0], calrsprot[0][1], calrsprot[0][2]);
            printf("\t %6ld %6ld %6ld \n", calrsprot[0][3], calrsprot[0][4], calrsprot[0][5]);
            printf("\t %6ld %6ld %6ld \n", calrsprot[0][6], calrsprot[0][7], calrsprot[0][8]);
            fflush(stdout);
        }

    }

    cal_yphase = 0;
    cal_zphase = 0;
    cal_rcphase = 0;

    cal_exphase = 0;
    cal_seq_count = 1;

    acq_passes = cal_pass;
    acq_nexs = cal_nex;
    acq_longnexs = 1;
    
    /* Initialize cal_sltab  */
    memset(cal_sltab, 0, sizeof(cal_sltab));
    memset(cal_slrtab, 0, sizeof(cal_slrtab));

    if(CAL_NEX_INTERLEAVED == cal_interleave)
    {
        acq_longnexs = cal_pass*cal_nex;
        acq_nexs = 1;
    }

    if(cal_interleave > CAL_NONE_INTERLEAVED)
    {
        acq_passes = 1;
    }
    else
    {
        acq_passes = cal_pass;
    }

    /* calculate Slab Offset */
    zoffs1 = (int)(.5 + fabs(FS_2PI*calrsp_info[0].rsptloc/cal_vthick));
    if (calrsp_info[0].rsptloc >= 0.0)
        zsign = 1;
    else
        zsign = -1;

    /* offset in range 0 - 2pi */
    zoffs = (zoffs1 + FS_2PI +  (int)((float)FS_PI*(1.0 + ((float)zsign)/((float)cal_slq)))) %FS_2PI;


    /* calculate Y Phase offset */
    if (calrsp_info[0].rspphasoff >= 0.0)
    {
        phase_sign = -1;
    }
    else
    {
        phase_sign = 1;
    }
    /* phase offset increment */
    yoffs1 = (int)(.5 + fabs(FS_2PI*calrsp_info[0].rspphasoff/cal_yfov));
    /* offset in range */
    phase_off = (yoffs1 + FS_2PI + FS_PI)%FS_2PI-FS_PI;

    /* set up T/R frequency */
    calrf1_freq = (int *)AllocNode((1 + 2)*sizeof(int));
    calrec_freq = (int *)AllocNode((1 + 2)*sizeof(int));

    setupslices(calrf1_freq, calrsp_info, 1, a_gzrf1cal,
                (float)1, cal_fov, TYPTRANSMIT);

    /* setup rec freq for each slice, calc here so fov is not scaled by
     * fov_freq_scale */
    if(cal_xfov > 0.0)
    {
        FLOAT mmtoHz = 2 * echo1bwcal * 1000/ cal_xfov;
        calrec_freq[0] = (INT)((cfreceiveroffsetfreq + mmtoHz * calrsp_info[0].rsprloc)/ TARDIS_FREQ_RES);
    }
    else
    {
        psdexit(EM_PSD_SUPPORT_FAILURE, (INT)0, "", "setup rec freq for autocal", PSD_ARG_STRING, "PSextcal", 0);
    }


    if(PSdebugstate)
    {
        printf("\n AutoCal tx freq = %i calrec_freq = %i \n", calrf1_freq[0], calrec_freq[0]);
    }

    for(calsl_idx=0;calsl_idx<cal_slq;calsl_idx++)
    {
        cal_sltab[calsl_idx+1] = (short)((((float)calsl_idx*(a_combcal - a_endcal)/
                                           (float)(cal_slq-1) - a_combcal)/calloggrd.tz)*max_pg_iamp);

        cal_slrtab[calsl_idx+1] = (int)((((float)calsl_idx*(a_combcal2 - a_endcal2)/
                                    (float)(cal_slq-1) - a_combcal2)/calloggrd.tz)*max_pg_iamp);

        cal_trigger[calsl_idx] = (long)TRIG_INTERN;
    }

    setupphasetable(cal_viewtab, (INT)TYPNORM, cal_yres);

    setssitime((LONG)time_ssical/HW_GRAD_UPDATE_TIME);

    setiamp(-cal_viewtab[cal_zyindex[0].view+1],&gy1cal,0);
    setiamp(cal_viewtab[cal_zyindex[0].view+1],&gy1rcal,0);

    temp_short = cal_sltab[cal_zyindex[0].slice];
    setiamp(temp_short,&gzcombcal,0);
    temp_short = cal_slrtab[cal_zyindex[0].slice];
    setiamp(-temp_short,&gzprcal,0);

    setiamp((short)ia_rf1cal, &rf1cal, 0);
    setiphase(0, &rf1cal, 0);

    setfrequency(calrf1_freq[0],&rf1cal,0);
    setfrequency(calrec_freq[0],&echo1cal,0);

    /* Inform the Tgt of the trigger array to be used */
    settriggerarray((SHORT)cal_slq,cal_trigger);

    setrotatearray((SHORT)cal_slq,*calrsprot);

    /* Reset scope and attenuator lock*/
    attenlockon(&attenuator_keycal);
    scopeon(&seqcal);

    /* Reset all the synchronizations  - no need to use one in pass */
    syncon(&seqcal);
    syncoff(&seqcalpass);

    boffset(off_seqcal);

    /* Turn off 3dpacket */
    load3d(&d3dcal,0,(TYPDAB_PACKETS)DABOFF);

    cal_acq = (INT)DABOFF;
    loaddab(&echo1cal, 0,0,0,0, (TYPDAB_PACKETS)cal_acq,PSD_LOAD_DAB_ALL);


    for (calview_idx = -rspdda; calview_idx <= -1; calview_idx++)
    {
        if(calview_idx < -cal_dda)  /* delay time, set rf1cal to 0 amplitude */
        {
            setiamp(0, &rf1cal, 0);
        }
        else
        {
            setiamp((short)ia_rf1cal, &rf1cal, 0);
        }

        if(calspgr_flag)
        {
            cal_exphase = ((int)((float)cal_exphase + (float)cal_seq_count*ps_seed + 3L*FS_PI) % FS_2PI)-FS_PI;
            cal_seq_count++;
        }
        else
        {
            cal_exphase = 0;
        }

        setiphase(cal_exphase, &rf1cal, 0);

        startseq((SHORT)0,(SHORT)MAY_PAUSE);
        syncoff(&seqcal);
    }

    for (calpass_idx = 0; calpass_idx < acq_passes; calpass_idx++)
    {
        cal_acq = (INT)DABON;

        /* switch to body coil in 2nd pass for PURE Cal */
        if(calpass_idx > 0)
        {
            if (coilInfo_tgt[0].hubIndex != volRecCoilInfo_tgt[0].hubIndex)
            {
                if (FAILURE == CoilSwitchSetCoil(volRecCoilInfo_tgt[0], 1))
                {
                    return FAILURE;
                }
                boffset(off_seqcal);
                printf("switch to body coil\n");
            }

        }

        for (longnex_idx = 1; longnex_idx <= acq_longnexs; longnex_idx++)
        {
            if(CAL_NEX_INTERLEAVED == cal_interleave)
            {
                /* switch coil in NEX loop PURE Cal */
                if(0 == longnex_idx %2)
                {
                    if (coilInfo_tgt[0].hubIndex != volRecCoilInfo_tgt[0].hubIndex)
                    {
                        if (FAILURE == CoilSwitchSetCoil(volRecCoilInfo_tgt[0], 1))
                        {
                            return FAILURE;
                        }
                        boffset(off_seqcal);
                        printf("switch to body coil\n");
                    }
                }
                else
                {
                    if (FAILURE == CoilSwitchSetCoil(coilInfo_tgt[0], 1))
                    {
                        return FAILURE;
                    }

                    boffset(off_seqcal);
                    printf("switch to surface coil\n");
                }
            }


            for (cal_superidx = 0; cal_superidx < cal_sampledPts; cal_superidx++)
            { 
                calview_idx = cal_zyindex[cal_superidx].view + 1;
                setiamp(-cal_viewtab[calview_idx],&gy1cal,0);
                setiamp(cal_viewtab[calview_idx],&gy1rcal,0);

                calsl_idx = cal_zyindex[cal_superidx].slice;
                cal_zphase =zsign*((calsl_idx*zoffs + 3L*FS_PI)%FS_2PI - FS_PI);
                cal_yphase = phase_sign*(((calview_idx-1)*phase_off + 3L*FS_PI)%FS_2PI - FS_PI);

                setiamp(cal_sltab[calsl_idx+1],&gzcombcal,0);
                setiamp(-cal_slrtab[calsl_idx+1],&gzprcal,0);

                /* Need this loaddab for coil switching in interleaved mode.
                 * The loaddab_hub_r1 is only set related ssp control bits related to rfhub for coil switching.
                 * Need to set other dab bits (slice, view, filter etc) for data acquisition by using loaddab().
                 */
                loaddab(&echo1cal,calsl_idx,0,0,calview_idx, (TYPDAB_PACKETS)cal_acq,PSD_LOAD_DAB_ALL);

                for (calcoil_idx = 0; calcoil_idx <= cal_tr_interleave; calcoil_idx++)
                {

                    for (calnex_idx = 1; calnex_idx <= acq_nexs; calnex_idx++)  /* EXCITATION LOOP */
                    {
                        if(calspgr_flag)
                        {
                            cal_exphase = ((int)((float)cal_exphase + (float)cal_seq_count*ps_seed + 3L*FS_PI) % FS_2PI)-FS_PI;
                            cal_seq_count++;
                        }
                        else
                        {
                            cal_exphase = 0;
                        }
                        setiphase(cal_exphase, &rf1cal, 0);

                        cal_rcphase = (cal_exphase + cal_zphase + cal_yphase + 3L*FS_PI)%FS_2PI-FS_PI;
                        setiphase(cal_rcphase, &echo1cal, 0); /* slab and offset phase */


                        if (cal_nex_interleave && (cal_zyindex[cal_superidx].flags & ZY_XZ_PLANE_DONE) && (acq_longnexs == longnex_idx))
                        {
                            load3d(&d3dcal,calview_idx-1,(TYPDAB_PACKETS)DABON);
                        }
                        else if (!cal_nex_interleave && (cal_zyindex[cal_superidx].flags & ZY_XZ_PLANE_DONE) && (acq_nexs == calnex_idx))
                        {
                            load3d(&d3dcal,calview_idx-1,(TYPDAB_PACKETS)DABON);
                        }
                        else
                        {
                            load3d(&d3dcal,calview_idx-1,(TYPDAB_PACKETS)DABOFF);
                        }


                        if(cal_nex > 1)
                        {
                            caldabop = DABADD;
                        }
                        else
                        {
                            caldabop = DABSTORE;
                        }

                        if(cal_tr_interleave)
                        {
                            if(calcoil_idx == 0)
                            {
                                loaddab_hub_r1(&echo1cal, calsl_idx, 0, caldabop, calview_idx, coilInfo_tgt[0].hubIndex, 0, (TYPDAB_PACKETS)cal_acq, PSD_LOAD_DAB_HUB);
                            }
                            else   /* idx == 1, body coil rec */
                            {
                                loaddab_hub_r1(&echo1cal, calsl_idx, 0, caldabop, calview_idx, volRecCoilInfo_tgt[0].hubIndex, 0, (TYPDAB_PACKETS)cal_acq, PSD_LOAD_DAB_HUB);
                            }
                        }
                        else
                        {
                            loaddab(&echo1cal,calsl_idx,0,caldabop,calview_idx, (TYPDAB_PACKETS)cal_acq, PSD_LOAD_DAB_ALL);
                        }

                        /* startseq should be after loaddab */
                        startseq((SHORT)calsl_idx,(SHORT)MAY_PAUSE);

                    }  /* End of Excitation */
                }  /* Coil switching for PURE cal */

            }  /* End of SuperIndex */
        }  /* End of Long Term Nex loop */

        /* pass packet logic */
        boffset(off_seqcalpass);

        if(calpass_idx == (acq_passes-1))
        {
            /* Set DAB pass packet to end of scan */
            setwamp(SSPD + DABPASS + DABSCAN, &pass_pulsecal, 2);
            printdbg("End of Scan and Pass", PSdebugstate);
        }
        else
        {
            setwamp(SSPD + DABPASS , &pass_pulsecal,2);
        }

        /* load last 3d packet */
        load3d(&d3dpasscal,cal_yres,(TYPDAB_PACKETS)DABON);

        startseq(0,(SHORT)AUTO_PAUSE);
        syncoff(&seqcal);

        boffset(off_seqcal);

        printdbg("Returning from Ext Cal core",PSdebugstate);

    } /* End of calpass */


    return SUCCESS;
}

/*
 *  PSautocoil
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
    STATUS
PSautocoil( void )
{
    SHORT coil_sltab[CAL_SLTAB_MAX + 1];
    SHORT coil_slrtab[CAL_SLTAB_MAX + 1];
    SHORT coil_viewtab[CAL_SLTAB_MAX + 1];
    INT phase_off; 
    INT phase_sign; 
    INT zsign;
    INT zoffs1, zoffs;
    SHORT temp_short;
    long coil_trigger[CAL_SLTAB_MAX];
    INT coildabop;
    INT coil_acq;
    INT coilsl_idx, coilview_idx, coilnex_idx, longnex_idx;
    INT *coilrf1_freq;
    INT *coilrec_freq;
    INT coil_yphase;
    INT coil_zphase;
    INT coil_exphase;
    INT coil_rcphase;
    INT coil_seq_count;
    INT acq_nexs;
    INT acq_longnexs = 1;
    INT coil_superidx = 0;

    if(PSdebugstate)
    {
        printf("\n AutoCoil Sls = %i FOV = %f  slthick = %f\n", coil_slq, coil_fov, coil_slthick);
        printf("\n AutoCoil: Tx = %f Rx = %f Phase = %f\n", coilrsp_info[coil_slq/2].rsptloc,
               coilrsp_info[coil_slq/2].rsprloc, coilrsp_info[coil_slq/2].rspphasoff);
        printf("%s\n"," AutoCoil Rotation Matrix:");
        printf("\t %6ld %6ld %6ld \n", coilrsprot[0][0], coilrsprot[0][1], coilrsprot[0][2]);
        printf("\t %6ld %6ld %6ld \n", coilrsprot[0][3], coilrsprot[0][4], coilrsprot[0][5]);
        printf("\t %6ld %6ld %6ld \n", coilrsprot[0][6], coilrsprot[0][7], coilrsprot[0][8]);
        fflush(stdout);
    }

    /* Initialize coil_sltab  */    
    memset(coil_sltab, 0, sizeof(coil_sltab));
    memset(coil_slrtab, 0, sizeof(coil_slrtab));

    coil_yphase = 0;
    coil_zphase = 0;
    coil_rcphase = 0;

    coil_exphase = 0;
    coil_seq_count = 1;

    acq_nexs = coil_nex;
    acq_longnexs = 1;

    if(CAL_NEX_INTERLEAVED == coil_interleave)
    {
        acq_longnexs = coil_nex;
        acq_nexs = 1;
    }

    /* calculate Slab Offset */
    zoffs1 = (INT)(.5 + fabs(FS_2PI*coilrsp_info[0].rsptloc/coil_vthick));
    if (coilrsp_info[0].rsptloc >= 0.0)
        zsign = 1;
    else
        zsign = -1;

    /* offset in range 0 - 2pi */
    zoffs = (zoffs1 + FS_2PI +  (int)((float)FS_PI*(1.0 + ((float)zsign)/((float)coil_slq)))) %FS_2PI;


    /* calculate Y Phase offset */
    if (coilrsp_info[0].rspphasoff >= 0.0)
    {
        phase_sign = -1;
    }
    else
    {
        phase_sign = 1;
    }
    /* phase offset increment */
    yoffs1 = (INT)(.5 + fabs(FS_2PI*coilrsp_info[0].rspphasoff/coil_yfov));
    /* offset in range */
    phase_off = (yoffs1 + FS_2PI + FS_PI)%FS_2PI-FS_PI;

    /* set up T/R frequency */
    coilrf1_freq = (int *)AllocNode((1 + 2)*sizeof(int));
    coilrec_freq = (int *)AllocNode((1 + 2)*sizeof(int));

    setupslices(coilrf1_freq, coilrsp_info, 1, a_gzrf1coil,
                (float)1, coil_fov, TYPTRANSMIT);

    /* setup rec freq for each slice here so fov is not scaled
     * by fov_freq_scale */
    if(coil_xfov > 0.0)
    {
        FLOAT mmtoHz = 2 * echo1bwcoil * 1000/ coil_xfov;
        coilrec_freq[0] = (INT)((cfreceiveroffsetfreq + mmtoHz * coilrsp_info[0].rsprloc)/ TARDIS_FREQ_RES);
    }
    else
    {
        psdexit(EM_PSD_SUPPORT_FAILURE, (INT)0, "", "setup rec freq for autocoil", PSD_ARG_STRING, "PSautocoil", 0);
    }

    for(coilsl_idx=0;coilsl_idx<coil_slq;coilsl_idx++)
    {
        coil_sltab[coilsl_idx+1] = (SHORT)((((float)coilsl_idx*(a_combcoil - a_endcoil)/
                                     (float)(coil_slq-1) - a_combcoil)/coilloggrd.tz)*max_pg_iamp);

        coil_slrtab[coilsl_idx+1] =(SHORT)((((float)coilsl_idx*(a_combcoil2 - a_endcoil2)/
                                     (float)(coil_slq-1) - a_combcoil2)/coilloggrd.tz)*max_pg_iamp);

        coil_trigger[coilsl_idx] = (long)TRIG_INTERN;
    }

    if(PSdebugstate)
    {
        printf("\n Sls encode = %d, = %d,  = %d \n", coil_sltab[0], coil_sltab[3], coil_sltab[5]);
        fflush(stdout);
    }

    setupphasetable(coil_viewtab, (INT)TYPNORM, coil_yres);

    setssitime((LONG)time_ssicoil/HW_GRAD_UPDATE_TIME);


    temp_short = coil_sltab[1];
    setiamp(temp_short,&gzcombcoil,0);
    temp_short = coil_slrtab[1];
    setiamp(-temp_short,&gzprcoil,0);

    setiamp((short)ia_rf1coil, &rf1coil, 0);
    setiphase(0, &rf1coil, 0);

    setfrequency(coilrf1_freq[0],&rf1coil,0);
    setfrequency(coilrec_freq[0],&echo1coil,0);

    /* Inform the Tgt of the trigger array to be used */
    settriggerarray((SHORT)coil_slq,coil_trigger);

    setrotatearray((SHORT)coil_slq,*coilrsprot);

    /* Reset scope and attenuator lock*/
    attenlockon(&attenuator_keycoil);
    scopeon(&seqcoil);

    /* Reset all the synchronizations  - no need to use one in pass */
    syncon(&seqcoil);
    syncoff(&seqcoilpass);

    boffset(off_seqcoil);

    /* Turn off 3dpacket */
    load3d(&d3dcoil,0,(TYPDAB_PACKETS)DABOFF);

    coil_acq = (INT)DABOFF;
    loaddab(&echo1coil, 0,0,0,0, (TYPDAB_PACKETS)coil_acq,PSD_LOAD_DAB_ALL);

    for (coilview_idx = -rspdda; coilview_idx <= -1; coilview_idx++)
    {
        if(coilspgr_flag)
        {
            coil_exphase = ((int)((float)coil_exphase + (float)coil_seq_count*ps_seed + 3L*FS_PI) % FS_2PI)-FS_PI;
            coil_seq_count++;
        }
        else
        {
            coil_exphase = 0;
        }

        setiphase(coil_exphase, &rf1coil, 0);

        startseq((SHORT)0,(SHORT)MAY_PAUSE);
        syncoff(&seqcoil);
    }

    for (longnex_idx = 1; longnex_idx <= acq_longnexs; longnex_idx++)
    {
        coil_acq = (INT)DABON;
        for (coil_superidx = 0; coil_superidx < coil_sampledPts; coil_superidx++)
        { 
            coilview_idx = coil_zyindex[coil_superidx].view + 1;
            setiamp(-coil_viewtab[coilview_idx],&gy1coil,0);
            setiamp(coil_viewtab[coilview_idx],&gy1rcoil,0);

            coilsl_idx = coil_zyindex[coil_superidx].slice;
            coil_zphase =zsign*((coilsl_idx*zoffs + 3L*FS_PI)%FS_2PI - FS_PI);
            coil_yphase = phase_sign*(((coilview_idx-1)*phase_off + 3L*FS_PI)%FS_2PI-FS_PI);


            setiamp(coil_sltab[coilsl_idx+1],&gzcombcoil,0);
            setiamp(-coil_slrtab[coilsl_idx+1],&gzprcoil,0);

            for (coilnex_idx = 1; coilnex_idx <= acq_nexs; coilnex_idx++)  /* EXCITATION LOOP */
            {
                if(coilspgr_flag)
                {
                    coil_exphase = ((int)((float)coil_exphase + (float)coil_seq_count*ps_seed + 3L*FS_PI) % FS_2PI)-FS_PI;
                    coil_seq_count++;
                }
                else
                {
                    coil_exphase = 0;
                }
                setiphase(coil_exphase, &rf1coil, 0);

                coil_rcphase = (coil_exphase + coil_zphase + coil_yphase + 3L*FS_PI)%FS_2PI-FS_PI;
                setiphase(coil_rcphase, &echo1coil, 0); /* slab and offset phase */

                if (coil_nex_interleave && (coil_zyindex[coil_superidx].flags & ZY_XZ_PLANE_DONE) && (acq_longnexs == longnex_idx))
                {
                    load3d(&d3dcoil,coilview_idx-1,(TYPDAB_PACKETS)DABON);
                }
                else if (!coil_nex_interleave && (coil_zyindex[coil_superidx].flags & ZY_XZ_PLANE_DONE) && (acq_nexs == coilnex_idx))
                {
                    load3d(&d3dcoil,coilview_idx-1,(TYPDAB_PACKETS)DABON);
                }
                else
                {
                    load3d(&d3dcoil,coilview_idx-1,(TYPDAB_PACKETS)DABOFF);
                }


                if(coil_nex > 1)
                {
                    coildabop = DABADD;
                }
                else
                {
                    coildabop = DABSTORE;
                }

                loaddab(&echo1coil,coilsl_idx,0,coildabop,coilview_idx, (TYPDAB_PACKETS)coil_acq, PSD_LOAD_DAB_ALL);

                /* startseq should be after loaddab */
                startseq((SHORT)coilsl_idx,(SHORT)MAY_PAUSE);

            }  /* End of Excitation */
        }  /* End of SuperIdx */
    }  /* End of Long Term Nex loop */

    /* pass packet logic */
    boffset(off_seqcoilpass);

    /* Set DAB pass packet to end of scan */
    setwamp(SSPD + DABPASS + DABSCAN, &pass_pulsecoil, 2);
    printdbg("End of Scan and Pass", PSdebugstate);

    /* load last 3d packet */
    load3d(&d3dpasscoil,coil_yres,(TYPDAB_PACKETS)DABON);

    startseq(0,(SHORT)AUTO_PAUSE);
    syncoff(&seqcoil);

    boffset(off_seqcoil);

    printdbg("Returning from AutoCOil core",PSdebugstate);


    return SUCCESS;
}



/* CoilSwitchSetCoil
 *
 *  Description: MRIhc15304
 *    This sets the RF HUB index for the coil by changing the data on an ssp
 *    pulse and/or with the sethubindeximm function.  Also calls
 *    setrcvportimm, if requested.
 *
 *  Parameters:
 *  (I: for input parameters, O: for output parameters)
 *  
 *  (O) STATUS return variable - Did function complete successfully.
 *  (I) const COIL_INFO - coil info structure of coil to switch to
 *  (I) const INT setRcvPortFlag - Flag indicating that setrcvportimm needs
 *        to be executed.  This needs to be set whenever switching to or
 *        from the BODY coil.
 *  
 *  Globals:
 *  (I) txCoilInfo
 *
 */

STATUS
CoilSwitchSetCoil( const COIL_INFO coil,
                   const INT setRcvPortFlag)
{
    SHORT device = 0;

    if( setRcvPortFlag || (COIL_SWITCH_RSP_SETHUBINDEXIMM & cfcoilswitchmethod) )
    {
        int wait_rspimm = 0;

        /* MRIhc14300: When switching coils, play a delay sequence to
           wait for scan prep to complete and scanning to start before the
           first setrcvportimm() & sethubindeximm().  These functions may not
           be called until scanning starts and the first startseq will not
           return until scanning starts. After scanning has started this will
           merely add an additional short delay to the switch time */

        boffset(off_seqcswWaitBefore);
        startseq((short)0, (SHORT)MAY_PAUSE);

        /* Need additional delay for setrcvpowerimm & sethubindeximm
         * to take effect.  The delay time must be set to guarantee
         * the completion of both setrcvportimm and sethubindeximm */

        if( COIL_SWITCH_RSP_SETHUBINDEXIMM & cfcoilswitchmethod )
        {
            wait_rspimm = csw_wait_sethubindeximm;
        }

        if( setRcvPortFlag )
        {
            wait_rspimm = IMax(2, wait_rspimm, csw_wait_setrcvportimm);
        }

        setperiod(wait_rspimm, &csw_wait, 0);
    }
    else
    {
        /* No additional delay needed when not calling setrcvportimm */
        setperiod(SSP_UPDATE_TIME, &csw_wait, 0);
    }

    /* Setup hub index switching packet */
    device = 0;
    if( COIL_SWITCH_SSP_HUB_INDEX & cfcoilswitchmethod )
    {
        device = RDC;
        /* Set hub index on SSP packet */
        setwamp( (SHORT)(SSPD | (HUBIND + coil.hubIndex)), &contrfhubsel, (LONG)2 );
    }
    setwamp( (SHORT)(SSPDS | device), &contrfhubsel, (LONG)0 );

    /* Set receiver port & receiver input */
    if( setRcvPortFlag || (COIL_SWITCH_SSP_RECEIVER_INPUT & cfcoilswitchmethod) )
    {
        SHORT coil_port = PSD_RP_BODY;
        SHORT rcv_input = RFBODYI;

        /* Calculate coil port & receiver input */
        switch (coil.rxCoilType) 
        {
        case RX_COIL_BODY:
        default:
            /* Transmit & receive with body coil */
            coil_port = PSD_RP_BODY;
            rcv_input = RFBODYI;
            break;
        case RX_COIL_LOCAL:
            {
                /* Assume there is only one transmit coil.  If two transmit
                   coils, the primary will be used */
                n32 txCoilType = TX_COIL_BODY;
                if (TX_INDEX_NONE != coil.txIndexPri)
                {
                    txCoilType = txCoilInfo_tgt[coil.txIndexPri].txCoilType;
                }
                else if (TX_INDEX_NONE != coil.txIndexSec)
                {
                    txCoilType = txCoilInfo_tgt[coil.txIndexSec].txCoilType;
                }
                else
                {
                    printf("CoilSwitchSetCoil: No transmit coil defined!\n");
                    return FAILURE;
                }

                if (TX_COIL_LOCAL == txCoilType)
                {
                    /* Local transmit coil */
                    coil_port = PSD_RP_HEAD;
                    rcv_input = RHEADI;
                }
                else
                {
                    /* Surface coil */
                    coil_port = PSD_RP_SURFACE;
                    rcv_input = RFAUX;
                }
            }
            break;
        }

        /* Setup receiver input switching packet */
        device = 0;
        if( COIL_SWITCH_SSP_RECEIVER_INPUT & cfcoilswitchmethod )
        {
            device = RDC;
            setwamp( (SHORT)(SSPD | rcv_input), &contrfsel, (LONG)2 );
        }
        setwamp( (SHORT)(SSPDS | device), &contrfsel, (LONG)0 );

        /* Set receiver port using RSP function call when switching to/from 
         * body coil */
        if (setRcvPortFlag) 
        {
#ifdef PSD_HW
            setrcvportimm( (SHORT)coil_port );
#endif /* PSD_HW */
        }
    }

    /* Select coil using RSP function on MGD Rx chain */
    if(COIL_SWITCH_RSP_SETHUBINDEXIMM & cfcoilswitchmethod)
    {
        sethubindeximm( coil.hubIndex );
    }
   
    boffset( off_seqcsw );
    startseq( (short)0, (SHORT)MAY_PAUSE );
    return SUCCESS;
}

/* phase_ordering 
 *
 *  Description: function for different phase ordering
 *  (O) SHORT* view_tab : View table with view acquisition order.
 *  (I) INT phase_order : Phase order variable.  Phase order types are:
 *           SEQUENTIAL 0
 *           CENTRIC 1
 *  (I) INT yviews : Number of views acquired in the scan.
 *
 *
*******************************/
STATUS
phase_ordering( SHORT *view_tab,
                const INT phase_order,
                const INT yviews, const INT yetl)
{
    INT i, j, num_trains, center;
    STATUS status = SUCCESS;

    num_trains = yviews/yetl;


    if(yetl >= 2)
    {
        switch (phase_order)
        {
            case PH_SEQUENTIAL: 
                for(i=0; i<num_trains/2; i++)
                {
                    for(j=0; j<yetl; j++)
                    {
                        view_tab[(i*2)*yetl+j] = (i*2)*yetl+j+1;
                        view_tab[(i*2+1)*yetl+j] = (i*2+1)*yetl+j+1; 
                    }
                }
                break;
            case PH_CENTRIC_LOW:
                for(i=0; i<num_trains/2; i++)
                {
                    for(j=0; j<yetl; j++)
                    {
                        view_tab[(i*2)*yetl+j] = (yviews/2 - i - j*num_trains/2);
                        view_tab[(i*2+1)*yetl+j] = (yviews/2 + i + 1 + j*num_trains/2);
                    }
                }
                break;
            case PH_CENTRIC_HIGH:
                for(i=0; i<num_trains/2; i++)
                {
                    for(j=0; j<yetl; j++)
                    {
                        view_tab[(i*2)*yetl+j] = yviews/2 + i - j*num_trains/2 - num_trains/2 + 1;
                        view_tab[(i*2+1)*yetl+j] = yviews/2 - i + j*num_trains/2 + num_trains/2;
                    }
                }
                break;
        }
    }
    else
    {
        switch (phase_order)
        {
            case PH_SEQUENTIAL:
                {
                    for(i=0;i<yviews;i++)
                    {
                        view_tab[i]=i+1;
                    }
                }
                break;
            case PH_CENTRIC_LOW:
            case PH_CENTRIC_HIGH:
                center = yviews/2;

                for( i = 0, j = 0; i < yviews/ 2; ++i, j += 2 )
                {
                    view_tab[j % yviews] = center - i;
                    view_tab[(j + 1) % yviews] = center + i + 1;
                }
                break;
        }
    }
    return status;
}




/* For Prescan: MPS2 Function */
STATUS mps2( void )
{
	boffset(off_seqcore);
	/* Initialize RSP parameters */
	rspent = L_MPS2;	
	rspdda = 2;
	rspbas = 0;
	rspvus = 30000;
	rspgy1 = 0;
	rspnex = 2;
	rspesl = -1;
	rspasl = pre_slice;
	rspslq = slquant1;
	rspsct = 0;

	if( psdinit() == FAILURE )
	{
		return rspexit();
	}

	prescanCore();
	rspexit();

	return SUCCESS;
}   /* end mps2() */


/* For Prescan: APS2 Function */
STATUS aps2( void )
{
	boffset(off_seqcore);
	/* Initialize RSP parameters */
	rspent = L_APS2;	
	rspdda = 2;
	rspbas = 0;
	rspvus = 1024;
	rspgy1 = 0;
	rspnex = 2;
	rspesl = -1;
	rspasl = -1;
	rspslq = slquant1;
	rspsct = 0;

	if( psdinit() == FAILURE )
	{
		return rspexit();
	}

	prescanCore();
	rspexit();

	return SUCCESS;
}   /* end aps2() */


/************************************************************************/
/* 				SCAN FUNCTION				*/
/************************************************************************/
STATUS scan( void )
{
	if( psdinit() == FAILURE )
	{
		return rspexit();
	}
	boffset( off_seqcore );	/* start the hardware in the 'core' sequence */
	setrotatearray( opslquant, rsprot[0] );
	settriggerarray( opslquant, rsptrigger );
	setssitime( 250 );	/* allow time to update sequencer memory */

	/* Calculate the RF & slice frequencies */
	rf1_freq = (int *)AllocNode( opslquant * sizeof(int) );
	receive_freq1 = (int *)AllocNode( opslquant * sizeof(int) );

	/* Set the Slice Frequency */
	setupslices( rf1_freq, rsp_info, opslquant, a_gzrf1, (float)1, opfov,
			TYPTRANSMIT );
	setupslices( receive_freq1, rsp_info, opslquant,(float)0, echo1bw, opfov,
			TYPREC);

	setiamp( ia_rf1, &rf1, 0 );
	setupphasetable( viewtable, TYPNORM, opyres );

	/* The SLICE loop */
	for( slice = 0; slice < opslquant; ++slice )
	{
		setfrequency( rf1_freq[slice], &rf1, 0 );
		setfrequency( receive_freq1[slice], &echo1, 0 );

		/* equilibrium views */
		dabop = 0;
		loaddab( &echo1, 0, 0, dabop, (int)0, DABOFF, PSD_LOAD_DAB_ALL );  /* each slice is a pass, slice index in each pass should be 0 */
		setiampt( viewtable[1], &gy1, 0 );
		setiampt( viewtable[1], &gyr1, 0 );  

		for( view = 0; view < 4; ++view )
		{
			startseq( 0, (short)MAY_PAUSE );
			getiamp( &chopamp, &rf1, 0 );
			setiamp( -chopamp, &rf1, 0 );
		}

		for( view = 0; view < rhbline; ++view )
		{
			loaddab( &echo1, 0, 0, dabop, (int)0, DABON, PSD_LOAD_DAB_ALL );  /* each slice is a pass, slice index in each pass should be 0 */
			startseq( 0, (short)MAY_PAUSE );
			getiamp( &chopamp, &rf1, 0 );
			setiamp( -chopamp, &rf1, 0 );
			dabop = 1; /* accumulate base views */
		}

		/* The VIEW loop */
		for( view = 1; view < (opyres + 1); ++view )
		{
			for( excitation = 1; excitation <= opnex; ++excitation )
			{
				if( excitation == 1 )
				{
					dabop = 0;
				}
				else
				{
					dabop = 3 - 2 * (excitation % 2);
				}

				setiampt( viewtable[view], &gy1, 0 );
				setiampt( viewtable[view], &gyr1, 0 );
				/* loaddab loads SSP packet used by data acquisition */
				loaddab( &echo1, 0, 0, dabop, view, DABON, PSD_LOAD_DAB_ALL );  /* each slice is a pass, slice index in each pass should be 0 */

				startseq( 0, (short)MAY_PAUSE );
				getiamp( &chopamp, &rf1, 0 );
				setiamp( -chopamp, &rf1, 0 );

			} /* end-of-excitation loop */
		}  /* end-of-view loop */

		boffset( off_pass );
		if( slice == (opslquant - 1) ) /* Last pass */
		{
			/* Set DAB pass packet to end of scan */
			setwamp( SSPD + DABPASS + DABSCAN, &endpass, 2 );
		}
		else
		{
			/* Set DAB pass packet to end of pass */
			setwamp( SSPD + DABPASS, &endpass, 2 );
		}
		startseq( 0, (short)MAY_PAUSE );

		boffset( off_seqcore ); /* reset the hardware in the 'core' sequence */
	} /* end-of-slice loop */

	rspexit();

	return SUCCESS;
}   /* end scan() */


/*************************************************/
/* Runtime core section executed during prescan. */
/*************************************************/
STATUS prescanCore( void )
{

	/*
	 * Core rsp routine for prescan entry points. Same as scan, only
	 *  no PE gradients or chopping. 
	 */
	boffset( off_seqcore );

	if( psdinit() == FAILURE )
	{
		rspexit();
	}

	setrotatearray( 1, rsprot[0] );
	settriggerarray( 1, rsptrigger );

	rf1_freq = (int *)AllocNode( sizeof(int) );
	receive_freq1 = (int *)AllocNode( sizeof(int) );

	(*rf1_freq) = (int)(GAM * a_gzrf1 * rsp_info[rspesl].rsptloc/ (10 * TARDIS_FREQ_RES));
	(*receive_freq1) = (int)((float)cfreceiveroffsetfreq/ TARDIS_FREQ_RES);

	setiamp( ia_rf1, &rf1, 0 );

	setfrequency( (*rf1_freq), &rf1, 0 );
	setfrequency( (*receive_freq1), &echo1, 0 );

	dabop = 0;

	loaddab( &echo1, 0, 0, dabop, (int) 0, DABOFF, PSD_LOAD_DAB_ALL );

	setiampt( 0, &gy1, 0 );

	for( view = 0; view < numdda; ++view ) 
	{
		startseq( 0, (short)MAY_PAUSE );
		getiamp( &chopamp, &rf1, 0 );
		setiamp( -chopamp, &rf1, 0 );
	}

	for( view = 1; view < rspvus + 1; ++view ) 
	{
		loaddab( &echo1, 0, 0, dabop, view, DABON, PSD_LOAD_DAB_ALL );
		startseq( 0, (short)MAY_PAUSE );
		getiamp( &chopamp, &rf1, 0 );
		setiamp( -chopamp, &rf1, 0 );
	} /* views */

	rspexit();

	return SUCCESS;
}   /* end prescanCore() */


/********************************************
 * dummylinks
 *
 * This routine just pulls in routines from
 * the archive files by making a dummy call.
 ********************************************/
void dummylinks( void )
{
	epic_loadcvs( "thefile" );            /* for downloading CVs */
}

/************************ END OF GRASS.E ******************************/


/* Include special CV download code */
#include "grass.cvcopy.cpp"

