/*
 *  grass.host.cpp
 *
 *  Do not edit this file. It is automatically generated by EPIC.
 *
 *  Date : Mar 18 2021
 *  Time : 22:18:04
 */

#include <values.h>
#include <string.h>
#include "epic_macros.h"
#include "epic_struct.h"
#include "grass.global.h"
#include "pgen_tmpl.h"
#include "grass.allcv.h"
#include "grass.tgtex.h"
#include "grass.hostdecl.h"
#include "grass.exportstr.h"
#include "grass.runtime.h"
/*********************************************************************
 *                      GRASS.E HOST SECTION                         *
 *                                                                   *
 * Write here the code unique to the Host PSD process. The following *
 * functions must be declared here: cvinit(), cveval(), cvcheck(),   *
 * and predownload().                                                *
 *                                                                   *
 *********************************************************************/
#include <math.h>
#include <stdlib.h>
#include "grad_rf_grass.h"
#include "psdopt.h"
#include "sar_pm.h"
#include "support_func.host.h"

/* fec : Field strength dependency library */
#include <sysDep.h>
#include <sysDepSupport.h>      /* FEC : fieldStrength dependency libraries */

#include "helperfuns.h"

#include "physics.h"
#include "psdIF.h"
#include <sys/time.h>

MODEL_PARAMETERS_STRUCT model_parameters;
PURE_MIX_STRUCT pure_mix;
SCENIC_STRUCT scenic;

int anatomy_channel_compr_enable = PSD_OFF;
int anatomy_optimal_recon_enable = PSD_OFF;
int anatomy_self_uni_corr_enable = PSD_OFF;

int apps_channel_compr_enable = PSD_OFF;
int apps_self_uni_corr_enable = PSD_OFF;


/** Load PSD Header **/
abstract("grass sequence");
psdname("grass");

int num_conc_grad = 3;          /* always three for grass 	*/
int entry;

/* peak B1 amplitudes */
float maxB1[MAX_ENTRY_POINTS], maxB1Seq;

/* This will point to a structure defining parameters of the filter
   used for the 1st echo */
FILTER_INFO *echo1_filt; 

/* Use real time filters, so allocate space for them instead of trying
   to point to an infinite number of structures in filter.h. */
FILTER_INFO echo1_rtfilt;

/* import host functions from ktraj.e */
/* Golden ratio numbers */
float PHI = (1.0 + sqrt(5.0))/2.0;
float phi1 = 0.4656;
float phi2 = 0.6823;

/* Gradient waveforms */
int Gx[MAXWAVELEN];
int Gy[MAXWAVELEN];
int Gz[MAXWAVELEN];
int T_v[MAXNTRAINS*MAXNECHOES][9];

/* Gradient amplitudes */
float a_Gx;
float a_Gy;
float a_Gz;

/* Gradient width */
int pw_G = 5000;

/* Function prototypes */
int genspiral(int N);
int genviews();
int sinsmooth(float *x, int N, int L);

/* genspiral() function definition */
int genspiral(int N) {

	/* Declare files */
	FILE *fID_k;
	FILE *fID_g;

	/* Declare/initialize variables */
	int n, m;
	float dn;
	float nturns = THETA_accel * (float)opxres/ sqrt( (float)ntrains );
	int L = 4 * round( (float)N/ (float)nturns/ 2.0 );

	/* Declare waveforms */
	float kx[N], ky[N], kz[N];
	float gx[N], gy[N], gz[N];
	float sx[N], sy[N], sz[N];

	/* Declare maximum values */
	float kxy_max = (float)opxres/ (float)opfov/10.0/ 2.0;
	float kz_max = (float)nechoes/ (float)opfov/10.0/ 2.0;
	float gx_max, gy_max, gz_max;
	float sx_max, sy_max, sz_max;

	/* Declare values */
	float R[N], THETA[N], PSI[N];
	float THETA_0 = 0;
	float PSI_0 = 0;

	/* Loop through points */
	for (n = 0; n < N; n++) {
		/* Zero out ramp points */
		if (n < L || N - n < L || (sptype2d > 2 && fabs(N/2 - n) < 1 + nnav/2))
			R[n] = 0.0;
		else { 
			/* Get radius of spiral at sample */
			switch (sptype2d) {
				case 1 : /* spiral out */
					m = fabs(n);
					dn = 1.0/ (float)(N - L);
					R[n] = pow((float)fmod(m - L/2, N) * dn, R_accel);
					break;
				case 2 : /* spiral in */
					m = fabs(n);
					dn = 1.0/ (float)(N - L);
					R[n] = pow(1.0 - (float)fmod(m - L/2, N) * dn, R_accel);
					break;
				case 3 : /* spiral out-in */
					m = fabs(n - N/2);
					dn = 2.0/ (float)(N - 2*L - nnav);
					R[n] = pow(1.0 - (float)fmod(m - nnav/2, N) * dn, R_accel);
					break;
				case 4 : /* spiral in-out */
					m = fabs(n - N/2);
					dn = 2.0/ (float)(N - 2*L - nnav);
					R[n] = pow((float)fmod(m - nnav/2, N) * dn, R_accel);
					break;
				default :
					fprintf(stderr, "Invalid sptype2d: %d", sptype2d);
					return 0;
			}
		}

		/* Get phase of spiral */
		dn = 1.0/ (float)N;
		m = (sptype2d < 3) ? (n - N/2) : (fabs(n - N/2));
		if (sptype3d == 4) { /* for orbital trajectory (3d spiral) */
			THETA[n] = (float)nturns * acos(fmod(m*dn * phi1, 1.0));
			PSI[n] = 2.0 * (float)nturns * M_PI * fmod(m*dn * phi2, 1.0);
		}
		else {
			THETA[n] = M_PI * (float)nturns * (float)m*dn;
			PSI[n] = 0.0;
		}

	};

	/* Smooth waveforms using a sinusoidal convolution */
	sinsmooth(R, (sptype2d < 3) ? (N) : (N/2), L);
	reverse(R, 0, N);
	sinsmooth(R, (sptype2d < 3) ? (N) : (N/2), L);
	reverse(R, 0, N);

	/* Loop through points */
	for (n = 0; n < N; n++) {
		/* Offset phase for 2nd half of spiral for both in and out */
		if (sptype2d > 2 && n >= N/2)
			THETA_0 = M_PI;

		/* Translate polar coordinates to cartesian */
		kx[n] = kxy_max * R[n]*cos(THETA_0 + THETA[n])*cos(PSI_0 + PSI[n]);
		ky[n] = kxy_max * R[n]*sin(THETA_0 + THETA[n])*cos(PSI_0 + PSI[n]);
		if (sptype3d > 1)
			kz[n] = kxy_max * R[n]*sin(THETA_0 + THETA[n])*sin(PSI_0 + PSI[n]);
		else /* SOS case */
			kz[n] = kz_max;
	}
	if (sptype3d == 1) {
		/* Smooth kz ramp for SOS */
		sinsmooth(kz, N, L);
	}

	/* Calculate gradient waveforms by differentiating trajectory */
	diff(kx, N, dt*1e-6*GAMMA/2.0/M_PI, gx);
	diff(ky, N, dt*1e-6*GAMMA/2.0/M_PI, gy);
	diff(kz, N, dt*1e-6*GAMMA/2.0/M_PI, gz);
	gx_max = fabs(getmaxabs(gx, N));
	gy_max = fabs(getmaxabs(gy, N));
	gz_max = fabs(getmaxabs(gz, N));

	/* Calculate slew waveforms by differentiating gradient */
	diff(gx, N, dt*1e-6, sx);
	diff(gy, N, dt*1e-6, sy);
	diff(gz, N, dt*1e-6, sz);
	sx_max = fabs(getmaxabs(sx, N));
	sy_max = fabs(getmaxabs(sy, N));
	sz_max = fabs(getmaxabs(sz, N));

	/* Determine if function exceeds gradient/slew limits */
	float stretch[6] = {gx_max/GMAX, gy_max/GMAX, gz_max/GMAX,
		sqrt(sx_max/SLEWMAX), sqrt(sy_max/SLEWMAX), sqrt(sz_max/SLEWMAX)};
	int N_stretch = 4 * round(getmaxabs(stretch, 6) * N/ 4.0);

	/* Determine if N can be stretched any more */
	if (fabs(N_stretch - N) <= 4) {
		/* Save values */
		pw_G = N;
		a_Gx = gx_max;
		a_Gy = gy_max;
		a_Gz = gz_max;
		fID_k = fopen("./ktraj.txt", "w");
		fID_g = fopen("./grad.txt", "w");
		for (n = 0; n < N; n++) {
			Gx[n] = round(32767.0/ a_Gx * gx[n]);
			Gy[n] = round(32767.0/ a_Gy * gy[n]);
			Gz[n] = round(32767.0/ a_Gz * gz[n]);
			fprintf(fID_k, "%f \t%f \t%f\n", kx[n], ky[n], kz[n]);	
			fprintf(fID_g, "%d \t%d \t%d\n", Gx[n], Gy[n], Gz[n]);	
		}
		fclose(fID_k);
		fclose(fID_g);
	}
	else {
		/* Recurse */
		genspiral(N_stretch);
	}	

	return 1;
};

/* genviews() function definition */
int genviews() {

	/* Declare values and matrices */
	FILE* fID = fopen("kviews.txt","w");
	int trainn, echon, n;
	float rx, ry, rz, dz;
	float Rx[9], Ry[9], Rz[9], Tz[9];
	float T_0[9], T[9];

	/* Initialize z translation to identity matrix */
	eye(T_0,3);
	eye(Tz, 3);

	/* Loop through all views */
	for (trainn = 0; trainn < ntrains; trainn++) {
		for (echon = 0; echon < nechoes; echon++) {

			/* Determine type of transformation */
			switch (sptype3d) {
				case 1 : /* Kz shifts */
					rx = 0.0;
					ry = 0.0;
					rz = (float)trainn * PHI;
					dz = pow(-1, (float)trainn) * (float)trainn/ (float)ntrains;
					dz += pow(-1, (float)echon) * floor((float)(echon + 1)/ 2.0);
					dz *= 2.0/ (float)nechoes;
					break;
				case 2 : /* Single axis rotation */
					rx = 0.0;
					ry = (float)(trainn*nechoes + echon) * PHI;
					rz = 0.0;
					dz = 1.0;
					break;
				case 3 :
				case 4 : /* Double axis rotations */
					rx = 2.0 * M_PI * (float)(trainn*nechoes + echon)/ PHI;
					ry = acos(fmod(1.0 - 2.0*(float)(trainn*nechoes + echon + 0.5), 1.0));
					ry *= 1.0/ (float)(ntrains * nechoes);
					rz = 0.0;
					dz = 1.0;
					break;
				default:
					return 0;
			}
			
			/* Calculate the transformation matrices */
			Tz[8] = dz;
			genrotmat('x', rx, Rx);
			genrotmat('y', ry, Ry);
			genrotmat('z', rz, Rz);

			/* Multiply the transformation matrices */
			multmat(3,3,3,T_0,Tz,T);
			multmat(3,3,3,Rx,T,T);
			multmat(3,3,3,Ry,T,T);
			multmat(3,3,3,Rz,T,T);
			
			/* Save the matrix to file */
			printmat(fID,3,3,T);
			fprintf(fID,"\n");

			/* Save the matrix to the table of matrices */
			for (n = 0; n < 9; n++)
				T_v[trainn*nechoes + echon][n] = (int)round(32767.0*T[n]);
		}
	}

	/* Close the file */
	fclose(fID);

	return 1;
};

/* sinsmooth() function definition */
int sinsmooth(float *x, int N, int L) {

	/* Initialize indexing variables */
	float y[N];
	int n, l;
	float dl = 1.0/ (float)L;

	/* Make smoothing kernel */
	float k[L];
	for (l = 0; l < L; l++)
		k[l] = 0.5 * (cos(2 * M_PI * (float)l*dl - M_PI) + 1);

	/* Make a cut version of x to preserve length */
	int N_cut = N - L;
	float x_cut[N_cut];
	for (n = 0; n < N_cut; n++)
		x_cut[n] = x[n+L];

	/* Convolve waveforms */
	conv(x_cut, N_cut, k, L, y);

	/* Copy result */
	for (n = 0; n < N; n++) x[n] = y[n];

	return 1;
};

#include "rfsspsummary.h"

/* Structure definitions for prescan filters*/
FILTER_INFO echo1as_filt;
FILTER_INFO echo1mps1_filt;
FILTER_INFO echo1ftg_filt;
FILTER_INFO echo1xtg_filt;
FILTER_INFO echo1cfl;
FILTER_INFO echo1cfh;
FILTER_INFO echo1rcvn;
FILTER_INFO echo1rs_filt;
FILTER_INFO echo1dtg_filt;
FILTER_INFO echo1cal_filt;
FILTER_INFO echo1coil_filt;

/* defines for pimrsaps CVs from op_prescan.h */
#ifndef PSC_MAX_CONTROL_ARRAY
#define PSC_MAX_CONTROL_ARRAY 15
#endif

#define COILLOG_LOG_MAXSIZE 262144 /* quarter-Meg */

int* pimrs[PSC_MAX_CONTROL_ARRAY];

/* YMSmr09211 04/26/2006 YI */
SCAN_INFO rcvnscan_info[1];
SCAN_INFO cfh_info[MAX_PSC_VQUANT];
SCAN_INFO ps1scan_info[PRESCAN_ROT_MAX];
SCAN_INFO rsscan_info[RFSHIM_SLQ];
SCAN_INFO maptgscan_info[MAPTG_SLQ];



static char supfailfmt[] = "Support routine %s failed";


/************************************************************************/
/*       			CVINIT    				*/
/* Invoked once (& only once) when the PSD host process	is started up.	*/
/* Code which is independent of any OPIO button operation is put here.	*/
/************************************************************************/
STATUS
cvinit( void )
{
	/* Initialize RBW pulldown menus */
	pircbnub = pircb2nub = 0;
	pite2nub = 6;

	/* Default RBW */
	cvdef(oprbw, 15.625);
	oprbw  = _oprbw.fixedflag ?  ((void)(15.625), oprbw) : 15.625;

	/* Do not show any fractional NEX values */
	pinexnub = 57;

#ifdef ERMES_DEBUG
	use_ermes  = _use_ermes.fixedflag ?  ((void)(0), use_ermes) : 0;
#else /* !ERMES_DEBUG */
	use_ermes  = _use_ermes.fixedflag ?  ((void)(1), use_ermes) : 1;
#endif /* ERMES_DEBUG */

	configSystem();
	EpicConf();
	inittargets(&loggrd, &phygrd);

	/* Init filter slots */
	initfilter();

	if( obloptimize( &loggrd, &phygrd, scan_info, exist(opslquant),
				exist(opplane), exist(opcoax), obl_method, obl_debug,
				&opnewgeo, cfsrmode ) == FAILURE )
	{
		return FAILURE;
	}


    { /* Start of code inlined from Prescan.e PScvinit */
        /*********************************************************************
         *                     PRESCAN.E HOST SECTION                        *
         *                           PScvinit                                *
         *                                                                   *
         * Write here the code unique to the Host PSD process. All code to   *
         * be executed in cvinit() must be written here.                     *
         *********************************************************************/
        
        cvdef(mpsfov, cfsystemmaxfov);
        cvdef(FTGfov, cfsystemmaxfov);
        
        FTGfov  = _FTGfov.fixedflag ?  ((void)(cfsystemmaxfov), FTGfov) : cfsystemmaxfov;

        pipscshimtgnub = PSD_ON;
        if(PSD_SPECTRO == exist(opimode))
        {
            pipscshimtgnub = PSD_OFF;
        }

        local_tg  = _local_tg.fixedflag ?      ((void)((exist(oppscshimtg)&&(exist(oppscvquant)>0))), local_tg) : (exist(oppscshimtg)&&(exist(oppscvquant)>0));

        getAnatomyAttributeCached(exist(opanatomy), ATTRIBUTE_CODE_MEANING, PSattribute_codeMeaning);

        if( (cffield == B0_30000 && !isDVSystem())  /* Not Architect config */
            && (isCategoryMatchForAnatomy(exist(opanatomy), ATTRIBUTE_CATEGORY_SPINE) && strstr(PSattribute_codeMeaning, "Lumbar spine"))
            && (PSD_OFF == opdyntg) && (PSD_OFF == local_tg) && (LOWSAR_CONTROL_MODE != exist(opsarmode)) )
        {
            enableMapTg  = _enableMapTg.fixedflag ?  ((void)(PSD_ON), enableMapTg) : PSD_ON;
        }
        else
        {
            enableMapTg  = _enableMapTg.fixedflag ?  ((void)(PSD_OFF), enableMapTg) : PSD_OFF;
        }

        PScvinit();
        FTGcvinit();
        XTGcvinit();
        AScvinit();
        RGcvinit();
        RScvinit();
        DTGcvinit();
        AutoCoilcvinit();
        ExtCalcvinit();
    } /* End of code inlined from Prescan.e PScvinit */


#include "cvinit.in"	/* Runs the code generated by macros in preproc.*/

		return SUCCESS;
}   /* end cvinit() */


#include "InitAdvisories.h"

/*-------------------------------------------------------------------
 * PROCEDURE: InitAdvPnlCVs
 * INPUT: none
 * OUTPUT: none
 * RETURN: none
 * SYNOPSIS: This function sets the advisory panel minimum and maximum values
 *           for advisory panel cvs which are not set in cveval. This gives us
 *           the opportunity to start placing items into the 8.0 EPIC Advisory
 *           Panel popup as desired.
 *
 *           Example:
 *                 if (exist(opssfse)!=PSD_OFF && exist(opnex)!=0.5) {
 *                      avminnex = avmaxnex = 0.5;
 *                      return ADVISORY_FAILURE;
 *                 }
 *           The above will ensure that (Nex 0.5) appears in the popup as a valid choice.
 *
 *---------------------------------------------------------------------*/
void 
InitAdvPnlCVs( void )
{
 avmaxnecho = _opnecho.maxval;
 avmaxte = _opte.maxval;
 avmaxte2 = _opte2.maxval;
 avmaxti = _opti.maxval;
 avmaxtr = _optr.maxval;
 avmaxfov = _opfov.maxval;
 avmaxyres = _opyres.maxval;
 avmaxxres = _opxres.maxval;
 avmaxrbw = _oprbw.maxval; 
 avmaxrbw2 = _oprbw2.maxval;
 avmaxsldelay = _opsldelay.maxval;
 avmaxetl = _opetl.maxval;
 avmaxslicecnt = _opslicecnt.maxval;
 avmaxnshots = _opnshots.maxval;
 avmaxphasefov = _opphasefov.maxval;
 avmaxslthick = _opslthick.maxval;
 avmaxnex = _opnex.maxval;
 avmaxflip = _opflip.maxval;
 avminnecho = _opnecho.minval;
 avminte = _opte.minval;
 avminte2 = _opte2.minval;
 avminti = _opti.minval;
 avmintr = _optr.minval;
 avminfov = _opfov.minval;
 avmaxslquant = _opslquant.maxval;
 avminslquant = _opslquant.minval;
 avminrbw = _oprbw.minval; 
 avminrbw2 = _oprbw2.minval;
 avminsldelay  = _avminsldelay.fixedflag ?  ((void)(_opsldelay.minval), avminsldelay) : _opsldelay.minval;
 avminetl = _opetl.minval;
 avminyres = _opyres.minval;
 avminslicecnt = _opslicecnt.minval;
 avminxres = _opxres.minval;
 avminnshots = _opnshots.minval;
 avminphasefov = _opphasefov.minval;
 avminslthick = _opslthick.minval;
 avminnex = _opnex.minval;
 avminflip = _opflip.minval;
 avminslspace = _opslspace.minval;
 avmaxslspace = _opslspace.maxval;
 avminbspti = _opbspti.minval;
 avmaxbspti = _opbspti.maxval;
 avminvest = _opvest.minval;
 avmaxvest = _opvest.maxval;
 avminnpwfactor = _opnpwfactor.minval;
 avmaxnpwfactor = _opnpwfactor.maxval;

 return;
}


/************************************************************************/
/*       			CVEVAL    				*/
/* Called w/ every OPIO button push which has a corresponding CV. 	*/
/* CVEVAL should only contain code which impacts the advisory panel--	*/
/* put other code in cvinit or predownload				*/
/************************************************************************/
	STATUS
cveval( void )
{

	configSystem();
	InitAdvPnlCVs();

	/* 
	 * Calculate RF filter and update RBW:
	 *   &echo1_rtfilt: I: all the filter parameters.
	 *   exist(oprbw): I/O: desired and final allowable bw.
	 *   exist(opxres): I: output pts generated by filter.
	 *   OVERWRITE_OPRBW: oprbw will be updated.
	 */
	if( calcfilter( &echo1_rtfilt,
				exist(oprbw),
				exist(opxres),
				OVERWRITE_OPRBW ) == FAILURE)
	{
		epic_error( use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE,
				EE_ARGS(1), STRING_ARG, "calcfilter:echo1" );
		return FAILURE;
	}

	echo1_filt = &echo1_rtfilt;

	/* Divide by 0 protection */
	if( (echo1_filt->tdaq == 0) || 
			floatsAlmostEqualEpsilons(echo1_filt->decimation, 0.0f, 2) ) 
	{
		epic_error( use_ermes, "echo1 tdaq or decimation = 0",
				EM_PSD_BAD_FILTER, EE_ARGS(0) );
		return FAILURE;
	}

	/* For use on the RSP side */
	echo1bw  = _echo1bw.fixedflag ?  ((void)(echo1_filt->bw), echo1bw) : echo1_filt->bw;

	/*
	 * Generate 2d spiral and 3d transformations 
	 * (functions came from ktraj.e)
	 */
	genspiral(pw_G);
	genviews();

	/*
	 * The minimum TR is based on the time before the RF pulse +
	 * half the RF pulse + the TE time + the last half of the
	 * readout + the time for the end of sequence killers
	 */
	avmintr = 1000 + pw_rf1/ 2 + exist(opte) + echo1_rtfilt.tdaq/ 2 + 2000;

    { /* Start of code inlined from Prescan.e PScveval */
        /*********************************************************************
         *                     PRESCAN.E HOST SECTION                        *
         *                           PScveval                                *
         *                                                                   *
         * Write here the code unique to the Host PSD process. All code to   *
         * be executed in cveval() must be written here.                     *
         *********************************************************************/

#ifndef SIM
        /* MRIhc49539: check current nucleus against coil DB: */
        n32 psd_nucleus = specnuc;

        if(psd_nucleus != coilInfo[0].rxNucleus)
        {
            epic_error(use_ermes, "%s is incompatible with %s.", EM_PSD_INCOMPATIBLE, EE_ARGS(2), STRING_ARG, "This PSD", STRING_ARG, "the selected coil");
            return FAILURE; 
        }
#endif /* !SIM_IO */
         
        TGspf  = _TGspf.fixedflag ?        ((void)(((0==getAps1Mod())&&opspf)), TGspf) : ((0==getAps1Mod())&&opspf);
    	read_axis = TGspf ? YGRAD : XGRAD;
        if(read_axis == XGRAD)
        {
            killer_axis = YGRAD;
        }
        else
        {
            killer_axis = XGRAD;
        }

        local_tg  = _local_tg.fixedflag ?      ((void)((exist(oppscshimtg)&&(exist(oppscvquant)>0))), local_tg) : (exist(oppscshimtg)&&(exist(oppscvquant)>0));
                
        /* set up axis for XTG */
        if(local_tg && oppscvquant > 0)
        {
            tg_read_axis = XGRAD;
            tg_killer_axis = YGRAD;
        }
        else
        {
            tg_read_axis = read_axis;
            tg_killer_axis = killer_axis;
        }

        /* Set flag for minimizing time between XTG Y Killers */
        if ( ( getAps1Mod() == 2 ) && (local_tg == PSD_OFF) )
        {
            XTG_minimizeYKillerGap  = _XTG_minimizeYKillerGap.fixedflag ?  ((void)(PSD_ON), XTG_minimizeYKillerGap) : PSD_ON;
        }
        else
        {
            XTG_minimizeYKillerGap  = _XTG_minimizeYKillerGap.fixedflag ?  ((void)(PSD_OFF), XTG_minimizeYKillerGap) : PSD_OFF;
        }

        /* Set min_ssp */
        min_ssp = IMax( 2, RF_MIN_BLANK, RUP_GRD(-rfupa + rfupd + RFUNBLANK_LENGTH + RFFREQ_LENGTH) );

        TGopslthick  = _TGopslthick.fixedflag ?  ((void)(10.0), TGopslthick) : 10.0;

        if((PSD_ON == local_tg) && (oppscvquant >0)) /* use shim vol for TG */
        {
            TGopslthickx  = _TGopslthickx.fixedflag ?  ((void)(psc_info[0].oppsclenx), TGopslthickx) : psc_info[0].oppsclenx;
            TGopslthicky  = _TGopslthicky.fixedflag ?  ((void)(psc_info[0].oppscleny), TGopslthicky) : psc_info[0].oppscleny;
            TGopslthick  = _TGopslthick.fixedflag ?  ((void)(psc_info[0].oppsclenz), TGopslthick) : psc_info[0].oppsclenz;


            TGopslthickx  = _TGopslthickx.fixedflag ?    ((void)(FMin(2,TGopslthickx,cfsystemmaxfov)), TGopslthickx) : FMin(2,TGopslthickx,cfsystemmaxfov);
            TGopslthicky  = _TGopslthicky.fixedflag ?    ((void)(FMin(2,TGopslthicky,cfsystemmaxfov)), TGopslthicky) : FMin(2,TGopslthicky,cfsystemmaxfov);
            TGopslthick   = _TGopslthick.fixedflag ?     ((void)(FMin(2,TGopslthick,cfsystemmaxfov)), TGopslthick) : FMin(2,TGopslthick,cfsystemmaxfov);

            TGopslthick   = _TGopslthick.fixedflag ?     ((void)(FMax(2,TGopslthick,MINFOV_TG)), TGopslthick) : FMax(2,TGopslthick,MINFOV_TG);
            TGopslthickx  = _TGopslthickx.fixedflag ?    ((void)(FMax(2,TGopslthickx,MINFOV_TG)), TGopslthickx) : FMax(2,TGopslthickx,MINFOV_TG);
            TGopslthicky  = _TGopslthicky.fixedflag ?    ((void)(FMax(2,TGopslthicky,MINFOV_TG)), TGopslthicky) : FMax(2,TGopslthicky,MINFOV_TG);
        }
        else if(PSD_ON == local_tg)
        {
            /* For Research purpose only. Localized TG is normally enabled only if
             * Shim volume has been set by user via GRx. If this case is reached, 
             * local_tg flag was intentionally modified by user for Research purposes. */

            fov_scaling  = _fov_scaling.fixedflag ?  ((void)(0.8), fov_scaling) : 0.8;
            if(PSD_ON == opfus)
            {
                fov_scaling  = _fov_scaling.fixedflag ?  ((void)(0.5), fov_scaling) : 0.5;
            }
            TGopslthick  = _TGopslthick.fixedflag ?  ((void)(opslthick*opslquant*fov_scaling), TGopslthick) : opslthick*opslquant*fov_scaling;
            TGopslthickx  = _TGopslthickx.fixedflag ?  ((void)(get_act_freq_fov()*fov_scaling), TGopslthickx) : get_act_freq_fov()*fov_scaling;  /* use scan Rx */
            TGopslthicky  = _TGopslthicky.fixedflag ?  ((void)(get_act_phase_fov()*fov_scaling), TGopslthicky) : get_act_phase_fov()*fov_scaling;  /* use scan Rx */

            TGopslthick   = _TGopslthick.fixedflag ?     ((void)(FMax(2,TGopslthick,20.0)), TGopslthick) : FMax(2,TGopslthick,20.0);
            TGopslthickx  = _TGopslthickx.fixedflag ?    ((void)(FMax(2,TGopslthickx,MINFOV_TG)), TGopslthickx) : FMax(2,TGopslthickx,MINFOV_TG);
            TGopslthicky  = _TGopslthicky.fixedflag ?    ((void)(FMax(2,TGopslthicky,MINFOV_TG)), TGopslthicky) : FMax(2,TGopslthicky,MINFOV_TG);
        }

        cal_btw_rf_rba_ssp  = _cal_btw_rf_rba_ssp.fixedflag ?       ((void)(IMax(3,DABSETUP,4+attenlen+tns_len+XTR_length[bd_index]+DAB_length[bd_index]+fast_xtr,cfrfminunblk)), cal_btw_rf_rba_ssp) : IMax(3,DABSETUP,4+attenlen+tns_len+XTR_length[bd_index]+DAB_length[bd_index]+fast_xtr,cfrfminunblk);
        cal_grd_rf_delays  = _cal_grd_rf_delays.fixedflag ?      ((void)(IMax(2,0,psd_rf_wait-psd_grd_wait)), cal_grd_rf_delays) : IMax(2,0,psd_rf_wait-psd_grd_wait);

        psd_dump_coil_info();

        getAnatomyAttributeCached(exist(opanatomy), ATTRIBUTE_CODE_MEANING, PSattribute_codeMeaning);
        if (FAILURE==PScveval())
        {
            return FAILURE;
        }
        if (FAILURE==FTGcveval())
        {
            return FAILURE;
        }
        if (FAILURE==XTGcveval())
        {
            return FAILURE;
        }
        if (FAILURE==AScveval())
        {
            return FAILURE;
        }
        if (FAILURE==RGcveval())
        {
            return FAILURE;
        }

        if (FAILURE==RScveval())
        {
            return FAILURE;
        }
        if (FAILURE==DTGcveval())
        {
            return FAILURE;
        }
        if (FAILURE==AutoCoilcveval())
        {
            return FAILURE;
        }
        if (FAILURE==ExtCalcveval())
        {
            return FAILURE;
        }

    } /* End of code inlined from Prescan.e PScveval */



	return SUCCESS;
}   /* end cveval() */

	void
getAPxParam(optval   *min,
		optval   *max,
		optdelta *delta,
		optfix   *fix,
		float    coverage,
		int      algorithm)
{
	/* Need to be filled when APx is supported in this PSD */
}

int getAPxAlgorithm(optparam *optflag, int *algorithm)
{
	return APX_CORE_NONE;
}

/************************************************************************/
/*       			CVCHECK    				*/
/* Executed on each 'next page' to ensure prescription can proceed 	*/
/* to the next page. 							*/
/************************************************************************/
	STATUS
cvcheck( void )
{
	if( exist(optr) < avmintr )
	{
		int min_tr = (int)ceil( (double)avmintr/ 1000 );

		epic_error( use_ermes,
				"The TR needs to be increased to %d ms for the current prescription.",
				EM_PSD_TR_OUT_OF_RANGE, EE_ARGS(1), INT_ARG, min_tr );
		return ADVISORY_FAILURE;
	}

	return SUCCESS;
}   /* end cvcheck() */


/************************************************************************/
/*             		    PRE-DOWNLOAD           		        */
/* Executed prior to a download--all operations not needed for the 	*/
/* advisory panel results.  Execute the	pulsegen macro expansions for	*/
/* the predownload section here.  All internal amps, slice ordering,  	*/
/* prescan slice calc., and SAT placement calculations are performed 	*/
/* in this section.  Time anchor settings for pulsegen are done in this */
/* section too.  				 			*/
/************************************************************************/
	STATUS
predownload( void )
{
	/* Set the defaults for the excitation pulse */
	a_rf1  = _a_rf1.fixedflag ?  ((void)(opflip/180.0), a_rf1) : opflip/180.0;
	thk_rf1  = _thk_rf1.fixedflag ?  ((void)(opslthick), thk_rf1) : opslthick;
	res_rf1  = _res_rf1.fixedflag ?  ((void)(320), res_rf1) : 320;
	flip_rf1  = _flip_rf1.fixedflag ?  ((void)(opflip), flip_rf1) : opflip;

	/* Set the phase encode amplitude*/

	yfov_aspect  = _yfov_aspect.fixedflag ?  ((void)(nop*exist(opphasefov)), yfov_aspect) : nop*exist(opphasefov);
	rhnframes  = _rhnframes.fixedflag ?  ((void)(opyres*fn*yfov_aspect), rhnframes) : opyres*fn*yfov_aspect;

	if( endview( (int)(rhnframes/ fn), _endview_iamp.fixedflag ? (_temp0_endview_iamp=endview_iamp,&_temp0_endview_iamp) : &endview_iamp ) == FAILURE )
	{
		epic_error( use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE,
				EE_ARGS(1), STRING_ARG, "endview" );
		return FAILURE;
	}

	endview_scale  = _endview_scale.fixedflag ?   ((void)((float)max_pg_iamp/(float)endview_iamp), endview_scale) : (float)max_pg_iamp/(float)endview_iamp;

	if( amppwencode( &grady[GY1_SLOT], _pw_gy1_tot.fixedflag ? (_temp1_pw_gy1_tot=pw_gy1_tot,&_temp1_pw_gy1_tot) : &pw_gy1_tot,
				FMin( 2, loggrd.ty_xyz,loggrd.ty/ endview_scale ),
				(int)loggrd.yrt,
				(float)(nop * opfov * opphasefov), (int)(rhnframes/ fn ),
				(float)0.0 /* offset area */ ) == FAILURE )
	{
		epic_error( use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE,
				EE_ARGS(1), STRING_ARG, "amppwencode:gy1" );
		return FAILURE;
	}

	grady[GY1_SLOT].num = 1;

	/* Set the Read Out gradient amplitude */
	if( ampfov( _a_gxw.fixedflag ? (_temp2_a_gxw=a_gxw,&_temp2_a_gxw) : &a_gxw, echo1_filt->bw, opfov ) == FAILURE )
	{
		epic_error( use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE,
				EE_ARGS(1), STRING_ARG, "ampfov" );
		return FAILURE;
	}

	/* Duration of read lobe to match acquisition interval */
	pw_gxw  = _pw_gxw.fixedflag ?  ((void)(echo1_filt->tdaq), pw_gxw) : echo1_filt->tdaq;

	a_gy1a  = _a_gy1a.fixedflag ?  ((void)(-a_gy1a), a_gy1a) : -a_gy1a;
	a_gy1b  = _a_gy1b.fixedflag ?  ((void)(-a_gy1b), a_gy1b) : -a_gy1b;
	a_gy1  = _a_gy1.fixedflag ?  ((void)(-0.9), a_gy1) : -0.9;     /* to make it visible in plotpulse */

	a_gyr1a  = _a_gyr1a.fixedflag ?  ((void)(-a_gy1a), a_gyr1a) : -a_gy1a;
	a_gyr1b  = _a_gyr1b.fixedflag ?  ((void)(-a_gy1b), a_gyr1b) : -a_gy1b;
	a_gyr1  = _a_gyr1.fixedflag ?  ((void)(a_gy1), a_gyr1) : a_gy1;   /* to make it visible in plotpulse */

	pw_gyr1  = _pw_gyr1.fixedflag ?  ((void)(pw_gy1), pw_gyr1) : pw_gy1;
	pw_gyr1a  = _pw_gyr1a.fixedflag ?  ((void)(pw_gy1a), pw_gyr1a) : pw_gy1a;
	pw_gyr1d  = _pw_gyr1d.fixedflag ?  ((void)(pw_gy1d), pw_gyr1d) : pw_gy1d;

/*********************************************************************/
#include "predownload.in"	/* include 'canned' predownload code */
/*********************************************************************/

	/* Set up the filter structures to be downloaded for realtime 
	   filter generation. Get the slot number of the filter in the filter rack 
	   and assign to the appropriate acquisition pulse for the right 
	   filter selection - LxMGD, RJF */
	setfilter( echo1_filt, SCAN );
	filter_echo1  = _filter_echo1.fixedflag ?  ((void)(echo1_filt->fslot), filter_echo1) : echo1_filt->fslot;

{ /* Start of code inlined from Prescan.e PSfilter */
    /*********************************************************************
     *                     PRESCAN.E HOST SECTION                        *
     *                            PSfilter                               *
     *                                                                   *
     * Write here the code unique to the Host PSD process.               *
     *********************************************************************/
    /* PS filter must be called with no arguments. num_filter_slot 
       is a CV which comes from individual PSDs, which get incremented 
       in the PSD so that Prescan filter generation takes place for 
       the next slot in psd_filter_spec. - RJF 13/Oct/1998 */
    /* vmx 10/13/94 YI */
    PSfilter();
    /* end vmx */

    if(psddebugcode)
    {
        dump_runtime_filter_info(psd_filt_spec);
    }
} /* End of code inlined from Prescan.e PSfilter */


		/* Set the Slope of the Read Out window's leading edge */
		if( optramp( _pw_gxwa.fixedflag ? (_temp3_pw_gxwa=pw_gxwa,&_temp3_pw_gxwa) : &pw_gxwa, a_gxw, loggrd.tx, loggrd.xrt, TYPDEF ) == FAILURE )
		{
			epic_error( use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE,
					EE_ARGS(1), STRING_ARG, "optramp" );
			return FAILURE;
		}
	pw_gxwd  = _pw_gxwd.fixedflag ?  ((void)(pw_gxwa), pw_gxwd) : pw_gxwa;		/* Set trailing edge ramp to same duration. */

	/* For Prescan: Inform 'Auto' Prescan about prescan parameters 	*/
	pislquant = opslquant;	/* # of 2nd pass slices */
	/* slquant1 = max # of locations in 1 pass */

	/* For Prescan: Declare the entry point table 	*/
	if( entrytabinit( entry_point_table, (int)ENTRY_POINT_MAX ) == FAILURE ) 
	{
		epic_error( use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE,
				EE_ARGS(1), STRING_ARG, "entrytabinit" );
		return FAILURE;
	}

	/* For Prescan: Define the entry points in the table */
	/* Scan Entry Point */
	(void)strcpy( entry_point_table[L_SCAN].epname, "scan" );
	entry_point_table[L_SCAN].epfilter = (unsigned char)echo1_filt->fslot;

	/* First, find the peak B1 for the whole sequence. */
	maxB1Seq = 0.0;
	for( entry=0; entry < MAX_ENTRY_POINTS; ++entry )
	{
		if( peakB1( &maxB1[entry], entry, RF_FREE, rfpulse ) == FAILURE )
		{
			epic_error( use_ermes, "peakB1 failed.", EM_PSD_SUPPORT_FAILURE,
					EE_ARGS(1), STRING_ARG, "peakB1" );
			return FAILURE;
		}
		if( maxB1[entry] > maxB1Seq )
		{
			maxB1Seq = maxB1[entry];
		}
	}

	/* Set xmtadd according to maximum B1 and rescale for powermon,
	   adding additional (audio) scaling if xmtadd is too big.
	   Add in coilatten, too. */
	xmtaddScan  = _xmtaddScan.fixedflag ?         ((void)(-200*log10(maxB1[L_SCAN]/maxB1Seq)+getCoilAtten()), xmtaddScan) : -200*log10(maxB1[L_SCAN]/maxB1Seq)+getCoilAtten(); 

	if( xmtaddScan > cfdbmax )
	{
		extraScale  = _extraScale.fixedflag ?        ((void)((float)pow(10.0,(cfdbmax-xmtaddScan)/200.0)), extraScale) : (float)pow(10.0,(cfdbmax-xmtaddScan)/200.0);
		xmtaddScan  = _xmtaddScan.fixedflag ?  ((void)(cfdbmax), xmtaddScan) : cfdbmax;
	} 
	else
	{
		extraScale  = _extraScale.fixedflag ?  ((void)(1.0), extraScale) : 1.0;
	}

	if( setScale( L_SCAN, RF_FREE, rfpulse, maxB1[L_SCAN], 
				extraScale) == FAILURE )
	{
		epic_error( use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE,
				EE_ARGS(1), STRING_ARG, "setScale" );
		return FAILURE;
	}

	ia_rf1  = _ia_rf1.fixedflag ?    ((void)(max_pg_iamp*(*rfpulse[RF1_SLOT].amp)), ia_rf1) : max_pg_iamp*(*rfpulse[RF1_SLOT].amp);
	entry_point_table[L_SCAN].epxmtadd = (short)rint( (double)xmtaddScan );

	/* APS2 & MPS2 */
	entry_point_table[L_APS2] = entry_point_table[L_MPS2] = entry_point_table[L_SCAN];	/* copy scan into APS2 & MPS2 */
	(void)strcpy( entry_point_table[L_APS2].epname, "aps2" );
	(void)strcpy( entry_point_table[L_MPS2].epname, "mps2" );

	if( orderslice( TYPNCAT, (int)opslquant, (int)1, TRIG_INTERN ) == FAILURE )
	{
		epic_error( use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE,
				EE_ARGS(1), STRING_ARG, "orderslice" );
		return FAILURE;
	}

	/* nex, exnex, acqs and acq_type are used in the rhheaderinit routine */
	/* -- to initialize recon header variables */
	if( floatsAlmostEqualEpsilons(opnex, 1.0, 2) )
	{
		baseline  = _baseline.fixedflag ?  ((void)(8), baseline) : 8;
		nex  = _nex.fixedflag ?  ((void)(1), nex) : 1;
		exnex  = _exnex.fixedflag ?  ((void)(1), exnex) : 1;
	}
	else
	{
		baseline  = _baseline.fixedflag ?  ((void)(0), baseline) : 0;
		nex  = _nex.fixedflag ?  ((void)(opnex), nex) : opnex;
		exnex  = _exnex.fixedflag ?  ((void)(opnex), exnex) : opnex;
	}
	acqs  = _acqs.fixedflag ?  ((void)(opslquant), acqs) : opslquant;	/* Fixes the # of rhnpasses to the # of passes */
	acq_type  = _acq_type.fixedflag ?  ((void)(TYPGRAD), acq_type) : TYPGRAD;
    { /* Start of code inlined from loadrheader.e rheaderinit */
        /*
          rawdata   0=NOREC, 1=NPPROC
          eepf      1 for even echo phase flip
          oepf      1 for odd echo phase flip
          eeff      1 for even echo freq flip
        */

        eepf  = _eepf.fixedflag ?  ((void)(0), eepf) : 0;
        oepf  = _oepf.fixedflag ?  ((void)(0), oepf) : 0;
        eeff  = _eeff.fixedflag ?  ((void)(0), eeff) : 0;
        oeff  = _oeff.fixedflag ?  ((void)(0), oeff) : 0;

        pinex = nex; /* initialize for pinex so APS can use it */

        if( (nex == 1) || (isOddNexGreaterThanOne) || (isNonIntNexGreaterThanOne) )
        {
            rhbline  = _rhbline.fixedflag ?  ((void)(baseline), rhbline) : baseline;
        }
        else
        {
            rhbline  = _rhbline.fixedflag ?  ((void)(0), rhbline) : 0;
        }

        if( opimode == PSD_CINE )
        {
            rhbline  = _rhbline.fixedflag ?  ((void)(0), rhbline) : 0;
            if (isOddNexGreaterThanOne || isNonIntNexGreaterThanOne || nex < 2)
                cine_choplet  = _cine_choplet.fixedflag ?  ((void)(PSD_ON), cine_choplet) : PSD_ON;
            else
                cine_choplet  = _cine_choplet.fixedflag ?  ((void)(PSD_OFF), cine_choplet) : PSD_OFF;
        }

        if( rhbline )
        {
            rhblank  = _rhblank.fixedflag ?  ((void)(blank), rhblank) : blank;
        }
        else
        {
            rhblank  = _rhblank.fixedflag ?  ((void)(0), rhblank) : 0;
        }

        rhtype  = _rhtype.fixedflag ?  ((void)(0), rhtype) : 0;
        if( (nex > 1) && (opimode != PSD_CINE) )
        {
            rhtype  = _rhtype.fixedflag ?    ((void)(rhtype+RHTYPCHP), rhtype) : rhtype+RHTYPCHP;
        }
        if ( isOddNexGreaterThanOne || isNonIntNexGreaterThanOne )
        {
            rhtype  = _rhtype.fixedflag ?  ((void)(0), rhtype) : 0;
        }
        if( (opimode == PSD_CINE) && (!cine_choplet) )
        {
            rhtype  = _rhtype.fixedflag ?    ((void)(rhtype+RHTYPCHP), rhtype) : rhtype+RHTYPCHP;
        }
        if( opimode == PSD_CINE )
        {
            rhtype  = _rhtype.fixedflag ?    ((void)(rhtype+RHTYPCINE), rhtype) : rhtype+RHTYPCINE;
        }
        if( oppseq == PSD_GE || 
            oppseq == PSD_TOF || oppseq == PSD_TOFSP ||
            oppseq == PSD_PC  || oppseq == PSD_PCSP ||
            oppseq == PSD_3PLANELOC )
        {
            rhtype  = _rhtype.fixedflag ?    ((void)(rhtype+RHTYPGR), rhtype) : rhtype+RHTYPGR;
        }
        if(floatsAlmostEqualEpsilons(fn, 0.5, 2))
        {
            rhtype  = _rhtype.fixedflag ?    ((void)(rhtype+RHTYPFRACTNEX), rhtype) : rhtype+RHTYPFRACTNEX;
        }
        if( opimode == PSD_3D )
        {
            rhtype  = _rhtype.fixedflag ?    ((void)(rhtype+RHTYP3D), rhtype) : rhtype+RHTYP3D;
        }
        if( (nop > 1) && (oppomp == PSD_OFF) )
        {
            rhtype  = _rhtype.fixedflag ?    ((void)(rhtype+RHTYPNPW), rhtype) : rhtype+RHTYPNPW;
        }
        if( pitfeextra > 0 )
        {
            rhtype  = _rhtype.fixedflag ?    ((void)(rhtype+RHTYPFRACTECHO), rhtype) : rhtype+RHTYPFRACTECHO;
        }
        if(floatsAlmostEqualEpsilons(fn, 0.75, 2))
        {
            rhtype  = _rhtype.fixedflag ?    ((void)(rhtype+RHTYP75NEX), rhtype) : rhtype+RHTYP75NEX;
        }
        if( oppomp )
        {
            rhtype  = _rhtype.fixedflag ?    ((void)(rhtype+RHTYPPOMP), rhtype) : rhtype+RHTYPPOMP;
        }

        rhnecho  = _rhnecho.fixedflag ?  ((void)(opnecho), rhnecho) : opnecho;

        if( (opimode == PSD_CINE)
            && ((oppseq == PSD_PC) || (oppseq == PSD_PCSP)) )
        {
            rhnslices  = _rhnslices.fixedflag ?          ((void)(opslquant*(2+2*(exist(opflaxall)==1))), rhnslices) : opslquant*(2+2*(exist(opflaxall)==1));
        }
        else if( opcgate )
        {
            rhnslices  = _rhnslices.fixedflag ?    ((void)(opslquant*opphases), rhnslices) : opslquant*opphases;
        }
        else
        {
            rhnslices  = _rhnslices.fixedflag ?  ((void)(opslquant), rhnslices) : opslquant;
        }

        rhptsize  = _rhptsize.fixedflag ?  ((void)(opptsize), rhptsize) : opptsize;



     rhnavs  = _rhnavs.fixedflag ?      ((void)(IMax(2,(INT)(nex/2),(INT)1)), rhnavs) : IMax(2,(INT)(nex/2),(INT)1);

        rhformat  = _rhformat.fixedflag ?  ((void)(0), rhformat) : 0;
        if (nofermi)
        {
            rhformat  = _rhformat.fixedflag ?  ((void)(RHF_NO_FERMI), rhformat) : rhformat|RHF_NO_FERMI;
        }
        else
        {
            rhformat  = _rhformat.fixedflag ?  ((void)(~RHF_NO_FERMI), rhformat) : rhformat&~RHF_NO_FERMI;
        }

        if (nograd == PSD_OFF) /* use 2d or 3d gradwarp */
        {
            rhformat  = _rhformat.fixedflag ?  ((void)(~RHF_NO_GRADWARP), rhformat) : rhformat&~RHF_NO_GRADWARP;
            if ((op3dgradwarp == PSD_ON) && (exist(opslquant)>1)) /* do 3d gradwarp */
            {
                rhtype1  = _rhtype1.fixedflag ?  ((void)(RHTYP13DGRADWARP), rhtype1) : rhtype1|RHTYP13DGRADWARP;
            }
            else   /* do 2d gradwarp */
            {
                rhtype1  = _rhtype1.fixedflag ?  ((void)(~RHTYP13DGRADWARP), rhtype1) : rhtype1&~RHTYP13DGRADWARP;
            }
        }
        else  /* no gradwarp */
        {
            rhtype1  = _rhtype1.fixedflag ?  ((void)(~RHTYP13DGRADWARP), rhtype1) : rhtype1&~RHTYP13DGRADWARP;
            rhformat  = _rhformat.fixedflag ?  ((void)(RHF_NO_GRADWARP), rhformat) : rhformat|RHF_NO_GRADWARP;
        }
                
            
        if( opimode == PSD_3D )
        {
            if( zchop )
            {
                rhformat  = _rhformat.fixedflag ?  ((void)(RHF_ZCHOP), rhformat) : rhformat|RHF_ZCHOP;
            }
            else
            {
                rhformat  = _rhformat.fixedflag ?  ((void)(RHF_YCHOP), rhformat) : rhformat|RHF_YCHOP;
            }
        }

        rhapp  = _rhapp.fixedflag ?         
                      ((void)(((PSD_ON==opscic)&&(PSD_OFF==oprealtime)&&(PSD_OFF==opfluorotrigger))), rhapp) : ((PSD_ON==opscic)&&(PSD_OFF==oprealtime)&&(PSD_OFF==opfluorotrigger));

        if( (acq_type == TYPGRAD) && (opimode != PSD_CINE) )
        {
            eeff  = _eeff.fixedflag ?  ((void)(1), eeff) : 1;
        }
        else
        {
            eeff  = _eeff.fixedflag ?  ((void)(0), eeff) : 0;
        }

        if( (acq_type == TYPSPIN) && (opexor == PSD_OFF) )
        {
            eepf  = _eepf.fixedflag ?  ((void)(1), eepf) : 1;
        }
        else if( (acq_type == TYPSPIN) && (opexor == PSD_ON) )
        {
            eepf  = _eepf.fixedflag ?  ((void)(0), eepf) : 0;
        }
        else
        {
            eepf  = _eepf.fixedflag ?  ((void)(0), eepf) : 0;
        }

        /* set bit0 in rhdacqctrl with rawdata */
        if( rawdata )
        {
            rhdacqctrl  = _rhdacqctrl.fixedflag ?  ((void)(RHDC_RAWDATA), rhdacqctrl) : rhdacqctrl|RHDC_RAWDATA; 
        }
        else
        {
            rhdacqctrl  = _rhdacqctrl.fixedflag ?  ((void)(~(RHDC_RAWDATA)), rhdacqctrl) : rhdacqctrl&~(RHDC_RAWDATA);
        }

        set_echo_flip(_rhdacqctrl.fixedflag ? (_temp4_rhdacqctrl=rhdacqctrl,&_temp4_rhdacqctrl) : &rhdacqctrl, &chksum_rhdacqctrl, eepf, oepf, eeff, oeff);

        rhexecctrl  = _rhexecctrl.fixedflag ?      
                        ((void)(RHXC_AUTO_DISPLAY|RHXC_AUTO_LOCK*(0<autolock)|RHXC_AUTO_LOCK_ALLRECS*(2==autolock)|RHXC_XFER_IM|RHXC_INTERMEDIATE*saveinter), rhexecctrl) : RHXC_AUTO_DISPLAY|RHXC_AUTO_LOCK*(0<autolock)|RHXC_AUTO_LOCK_ALLRECS*(2==autolock)|RHXC_XFER_IM|RHXC_INTERMEDIATE*saveinter;

        /* Begin RTIA comment --- RJF */

        /*
          For RTIA, we don't need the images to be routed to TIR.
          Neither do we want them to be displayed in autoview.
          Here is the bit definitions for rhexecctrl.

          RDB_AUTO_DISPLAY               0x0001    1 
          RDB_AUTO_LOCK                  0x0002    2 
          RDB_AUTO_PERM                  0x0004    4 
          RDB_XFER_IM                    0x0008    8 
          RDB_SAVE_IM                    0x0010    16 
          RDB_TAPE_LOCK                  0x0020    32 
          RDB_INTERMEDIATE               0x0040    64 
          RDB_OVERRIDE_BROADCAST         0x0080    128 
          RDB_OVERRIDE_IMG_INSTALL       0x0100    256 
          RDB_OVERRIDE_AUTODISPLAY       0x0200    512 
          RDB_RTD_XFER_IM_REMOTE         0x0400    1024 
          RDB_RTD_SCAN                   0x0800    2048 
          RDB_REF_SCAN                   0x1000    4096 
          RDB_DONT_WRITE_OR_INSTALL      0x2000    8192 
          RDB_RTD_XFER_ALL_IM_PER_PASS   0x4000    16384 
          RDB_XFER_IMG_RIR               0x8000    32768 
        */
        /*  End RTIA comment */

        /* Begin RTIA */

        if( (oprealtime == PSD_ON) || (opfluorotrigger == PSD_ON) )
        { 
            rhexecctrl  = _rhexecctrl.fixedflag ?        ((void)(RHXC_OVERRIDE_IMG_INSTALL|RHXC_RTD_SCAN|RHXC_DONT_WRITE_OR_INSTALL|RHXC_XFER_IMG_RIR), rhexecctrl) : RHXC_OVERRIDE_IMG_INSTALL|RHXC_RTD_SCAN|RHXC_DONT_WRITE_OR_INSTALL|RHXC_XFER_IMG_RIR; 
            
            if ( (saveinter == PSD_ON) && (track_flag == PSD_ON) )
            { /*for realtime imaging, enable saving intermediate images*/
                rhexecctrl  = _rhexecctrl.fixedflag ?  ((void)(RHXC_INTERMEDIATE), rhexecctrl) : rhexecctrl|RHXC_INTERMEDIATE;
            }

            /* Added for Enabling Autoview for RTIA debug */
#ifdef RTIA_AUTOVIEW_ENABLE
            rhexecctrl  = _rhexecctrl.fixedflag ?  ((void)(RHXC_AUTO_DISPLAY), rhexecctrl) : rhexecctrl|RHXC_AUTO_DISPLAY; 
#endif
        }

        /* MRIge66773 */
        if( opfluorotrigger == PSD_ON )
        {
            rhexecctrl  = _rhexecctrl.fixedflag ?    ((void)(RHXC_AUTO_LOCK*(0<autolock)|RHXC_AUTO_LOCK_ALLRECS*(2==autolock)), rhexecctrl) : rhexecctrl|RHXC_AUTO_LOCK*(0<autolock)|RHXC_AUTO_LOCK_ALLRECS*(2==autolock);
        }
 
        /* End RTIA */
        rhvquant  = _rhvquant.fixedflag ?  ((void)(opvquant), rhvquant) : opvquant;
        rhslblank  = _rhslblank.fixedflag ?  ((void)(pislblank), rhslblank) : pislblank;
        rhzeroph  = _rhzeroph.fixedflag ?         ((void)((eg_phaseres*nop/2)*(opphasefov)+0.5), rhzeroph) : (eg_phaseres*nop/2)*(opphasefov)+0.5;
        if( pitfeextra > 0 )
        {
            rhnwin  = _rhnwin.fixedflag ?  ((void)(8), rhnwin) : 8;
        }
        else
        {
            rhnwin  = _rhnwin.fixedflag ?  ((void)(0), rhnwin) : 0;
        }

        if(pitfeextra > 0)
        {
            rhntran  = _rhntran.fixedflag ?  ((void)(4.0), rhntran) : 4.0;
        }
        else if( floatsAlmostEqualEpsilons(fn, 0.5, 2) && (nop > 1.0) )
        {
            rhntran  = _rhntran.fixedflag ?    ((void)(2.0*nop), rhntran) : 2.0*nop;
        }
        else
        {
            rhntran  = _rhntran.fixedflag ?  ((void)(2.0), rhntran) : 2.0;
        }

        if (APODIZE_STRONG == apodize_level_flag)
        {
            fermi_r_factor  = _fermi_r_factor.fixedflag ?  ((void)(0.9), fermi_r_factor) : 0.9;
            fermi_w_factor  = _fermi_w_factor.fixedflag ?  ((void)(3.0), fermi_w_factor) : 3.0;
        }
        else if (APODIZE_MEDIUM == apodize_level_flag)
        {
            fermi_r_factor  = _fermi_r_factor.fixedflag ?  ((void)(0.9), fermi_r_factor) : 0.9;
            fermi_w_factor  = _fermi_w_factor.fixedflag ?  ((void)(1.0), fermi_w_factor) : 1.0;
        }
        else
        {
            fermi_r_factor  = _fermi_r_factor.fixedflag ?  ((void)(1.0), fermi_r_factor) : 1.0;
            fermi_w_factor  = _fermi_w_factor.fixedflag ?  ((void)(1.0), fermi_w_factor) : 1.0;
        }

        if( (PSD_ON == opprop) || (PSD_ON == opdwprop) )
        {
            rhfermr  = _rhfermr.fixedflag ?        ((void)(fermi_rc*fermi_r_factor*(float)exist(opxres)*prop_act_oversamplingfactor), rhfermr) : fermi_rc*fermi_r_factor*(float)exist(opxres)*prop_act_oversamplingfactor;
        }
        else
        {
            rhfermr  = _rhfermr.fixedflag ?      ((void)(fermi_rc*fermi_r_factor*(float)exist(opxres)), rhfermr) : fermi_rc*fermi_r_factor*(float)exist(opxres);
        }
        rhfermw  = _rhfermw.fixedflag ?      ((void)(fermi_wc*fermi_w_factor*(float)10.0), rhfermw) : fermi_wc*fermi_w_factor*(float)10.0;

        /* JAH: MRIge68280 -- need to use this more robust means of defining
           the eccentricity of the fermi filter so the radius in the X and Y
           directions need not be equal or based on data acquisition or
           reconstruction sizes as determined in recon. */
        /* KVA: MRIge73462 Square pixel rhferme addition */

        if( (PSD_ON == opspiral) || (PSD_ON == exist(opsilentmr)) || 
            (PSD_SPECTRO == opimode) || (PSD_ON == opprop) || (PSD_ON == opdwprop) )
        {
            rhferme  = _rhferme.fixedflag ?  ((void)(1.0), rhferme) : 1.0;
        }
        else if( (PSD_ON == opepi) || (PSD_ON == opsquare) )
        {
            rhferme  = _rhferme.fixedflag ?    ((void)(opxres/(opyres*nop)), rhferme) : opxres/(opyres*nop);
        }
        else
        {
            rhferme  = _rhferme.fixedflag ?      ((void)(opxres/(opyres*opphasefov*nop)), rhferme) : opxres/(opyres*opphasefov*nop);
        }

        rhnpasses  = _rhnpasses.fixedflag ?  ((void)(acqs), rhnpasses) : acqs;

        rhdab0s  = _rhdab0s.fixedflag ?  ((void)(cfrecvst), rhdab0s) : cfrecvst;
        rhdab0e  = _rhdab0e.fixedflag ?    ((void)((int)getRxNumChannels()-1), rhdab0e) : (int)getRxNumChannels()-1;

        /* PURE */
        /*MRIge91361 add rhpure for PURE*/
        if (exist(oppurecal))
        {
            rhpure  = _rhpure.fixedflag ?  ((void)(PURE_CAL), rhpure) : PURE_CAL;
        }
        else
        {
            rhpure  = _rhpure.fixedflag ?  ((void)(exist(oppure)), rhpure) : exist(oppure);
        }

        /* Turn on pure mix if PURE_ITKN4 is applied under SCENIC */
        if (PSD_ON == opscenic && SCENIC_TYPE_PURE_ITKN4 == rhscenic_type)
        {
            rhpure  = _rhpure.fixedflag ?  ((void)(PURE2), rhpure) : PURE2;
        }

        /*MRIge93538 set rhpurefilter to 1 as default*/
        rhpurefilter  = _rhpurefilter.fixedflag ?  ((void)(1), rhpurefilter) : 1;

        {
            int attribute_result_int = 0;
            float attribute_result_float = 0.0;

            /* PURE 2 */
            if(isDVSystem() && ((B0_15000 == cffield) && (!strncmp("memp_pure", get_psd_name(), 9) || !strncmp("fse_pure", get_psd_name(), 8))))
            {            	
                rhpure_filtering_mode  = _rhpure_filtering_mode.fixedflag ?  ((void)(0), rhpure_filtering_mode) : 0;
            }
            else if(isCategoryMatchForAnatomy(exist(opanatomy), ATTRIBUTE_CATEGORY_LOWEREXTREMITIES) || /* Turn on MSK PURE Mix for all products*/ 
                     isCategoryMatchForAnatomy(exist(opanatomy), ATTRIBUTE_CATEGORY_UPPEREXTREMITIES))
            {		
                rhpure_filtering_mode  = _rhpure_filtering_mode.fixedflag ?  ((void)(0), rhpure_filtering_mode) : 0;
            }
            else
            {
                rhpure_filtering_mode  = _rhpure_filtering_mode.fixedflag ?  ((void)(exist(cfpure_filtering_mode)), rhpure_filtering_mode) : exist(cfpure_filtering_mode);
            }
            rhpure_lambda  = _rhpure_lambda.fixedflag ?  ((void)(coilInfo[0].pureLambda), rhpure_lambda) : coilInfo[0].pureLambda;
            rhpure_tuning_factor_surface  = _rhpure_tuning_factor_surface.fixedflag ?  ((void)(coilInfo[0].pureTuningFactorSurface), rhpure_tuning_factor_surface) : coilInfo[0].pureTuningFactorSurface;
            rhpure_tuning_factor_body  = _rhpure_tuning_factor_body.fixedflag ?  ((void)(coilInfo[0].pureTuningFactorBody), rhpure_tuning_factor_body) : coilInfo[0].pureTuningFactorBody;

            /* PURE Blur */
            rhpure_blur_enable  = _rhpure_blur_enable.fixedflag ?        ((void)(getIntAnatomyAttribute(exist(opanatomy),ATTRIBUTE_ENABLE_PURE_BLUR,&attribute_result_int)?attribute_result_int:0), rhpure_blur_enable) : getIntAnatomyAttribute(exist(opanatomy),ATTRIBUTE_ENABLE_PURE_BLUR,&attribute_result_int)?attribute_result_int:0;
            rhpure_blur  = _rhpure_blur.fixedflag ?        ((void)(getFloatAnatomyAttribute(exist(opanatomy),ATTRIBUTE_PURE_BLUR,&attribute_result_float)?attribute_result_float:0.0), rhpure_blur) : getFloatAnatomyAttribute(exist(opanatomy),ATTRIBUTE_PURE_BLUR,&attribute_result_float)?attribute_result_float:0.0;

            /* PURE Mix */
            strcpy(model_parameters.psd_name, get_psd_name());
            model_parameters.flip = exist(opflip);
            model_parameters.slthick = exist(opslthick);
            model_parameters.cffield  = _cffield.fixedflag ?  ((void)(cffield), cffield) : cffield;
            model_parameters.slquant = exist(opslquant);
            model_parameters.irmode = exist(opirmode);
            model_parameters.irprep = exist(opirprep);
            model_parameters.fatsat_flag = exist(opfatcl) || exist(opfat) || exist(opspecir);
            model_parameters.flex_flag = exist(opmedal);
            model_parameters.ideal_flag = exist(opdixon);
            model_parameters.obplane = exist(opobplane);
            model_parameters.plane = exist(opplane);
            model_parameters.tr = exist(optr);
            model_parameters.xtg_volRecCoil  = _xtg_volRecCoil.fixedflag ?  ((void)(xtg_volRecCoil), xtg_volRecCoil) : xtg_volRecCoil;
            model_parameters.pure_support = pipure;
            model_parameters.pseq_type = exist(oppseq);
            model_parameters.realtime_flag = exist(oprealtime);
            model_parameters.imode = exist(opimode);
            model_parameters.imsize = rhimsize;
            model_parameters.fov = exist(opfov);
            model_parameters.slzipfactor = exist(opslzip4)? 4 : (exist(opslzip2)? 2 : 1);
            model_parameters.rhscenic_type  = _rhscenic_type.fixedflag ?  ((void)(rhscenic_type), rhscenic_type) : rhscenic_type;
            model_parameters.cal_based_recon_flag = cal_based_optimal_recon_enabled;

            pure_mix.enable = 0;
            pure_mix.tuning_factor_surface = rhpure_tuning_factor_surface;
            pure_mix.tuning_factor_body = rhpure_tuning_factor_body;
            pure_mix.blur_enable = rhpure_blur_enable;
            pure_mix.blur = rhpure_blur;

            /* SCENIC */
            scenic.itkn4.allow = ((cfn4_num_levels_max>0) && cfn4_allowed);
            scenic.itkn4.slice_down_sample_rate = cfn4_slice_down_sample_rate;
            scenic.itkn4.inplane_down_sample_rate = cfn4_inplane_down_sample_rate;
            scenic.itkn4.num_levels_max = cfn4_num_levels_max;
            scenic.itkn4.num_iterations_max = cfn4_num_iterations_max;
            scenic.itkn4.convergence_threshold = cfn4_convergence_threshold;
            scenic.itkn4.gain_clamp_mode = cfn4_gain_clamp_mode;
            scenic.itkn4.gain_clamp_value = cfn4_gain_clamp_value;

            scenic.scic.allow = ((cfscic_focus>0.0) && cfscic_allowed);
            scenic.scic.focus = cfscic_focus;
            scenic.scic.smooth = cfscic_smooth;
            scenic.scic.edge = cfscic_edge;
            scenic.scic.gauss = cfscic_gauss;
            scenic.scic.reduction = cfscic_reduction;
            scenic.scic.threshold = cfscic_threshold;
            scenic.scic.contrast = cfscic_contrast;

            if (B0_30000 == cffield || PSD_PURE_COMPATIBLE_2==pipure || PURE2 == rhpure)
            {
                if (FAILURE == getPUREMixParameters(model_parameters, coilInfo, exist(opanatomy), &pure_mix, _pure_mix_tx_scale.fixedflag ? (_temp5_pure_mix_tx_scale=pure_mix_tx_scale,&_temp5_pure_mix_tx_scale) : &pure_mix_tx_scale))
                {
                    epic_error(use_ermes, "Support routine %s failed.",
                               EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                               STRING_ARG, "getPUREMixParameters");
                    return FAILURE;
                }
            }

            if (pure_mix.enable)
            {
                rhpure_mix_lambda  = _rhpure_mix_lambda.fixedflag ?  ((void)(pure_mix.lambda), rhpure_mix_lambda) : pure_mix.lambda;
                if ((!strncmp("dwi_pure",model_parameters.psd_name,8) || !strncmp("fsemaster_pure",model_parameters.psd_name,14) ||
                     !strncmp("t1memp_pure",model_parameters.psd_name,11) || !strncmp("2dfast_pure",model_parameters.psd_name,11) ||
                     !strncmp("3dfse_pure",model_parameters.psd_name,10) || !strncmp("3dradial_pure",model_parameters.psd_name,13) ||
                     !strncmp("efgre3d_pure",model_parameters.psd_name,12) || !strncmp("3dtof_pure",model_parameters.psd_name,10) ||
                     !strncmp("csmemp_pure",model_parameters.psd_name,11) || !strncmp("ssfse_pure",model_parameters.psd_name,10) ||
                     !strncmp("epi_pure",model_parameters.psd_name,8) || !strncmp("asl_pure",model_parameters.psd_name,8)) &&
                    (isCategoryMatchForAnatomy(exist(opanatomy), ATTRIBUTE_CATEGORY_HEAD)) && (isSVSystem()))
                {
                    rhpure_mix_lambda  = _rhpure_mix_lambda.fixedflag ?  ((void)(exist(opuser31)), rhpure_mix_lambda) : exist(opuser31);                
                }
                rhpure_mix_tuning_factor_surface  = _rhpure_mix_tuning_factor_surface.fixedflag ?  ((void)(pure_mix.tuning_factor_surface), rhpure_mix_tuning_factor_surface) : pure_mix.tuning_factor_surface;
                rhpure_mix_tuning_factor_body  = _rhpure_mix_tuning_factor_body.fixedflag ?  ((void)(pure_mix.tuning_factor_body), rhpure_mix_tuning_factor_body) : pure_mix.tuning_factor_body;
                rhpure_mix_blur_enable  = _rhpure_mix_blur_enable.fixedflag ?  ((void)(pure_mix.blur_enable), rhpure_mix_blur_enable) : pure_mix.blur_enable;
                rhpure_mix_blur  = _rhpure_mix_blur.fixedflag ?  ((void)(pure_mix.blur), rhpure_mix_blur) : pure_mix.blur;
                if (PURE2 == exist(oppure) && pure_mix.enable)
                {
                    rhpure_mix_alpha  = _rhpure_mix_alpha.fixedflag ?        ((void)(FMax(2,0.0,FMin(2,1.0,pure_mix.alpha+(exist(opuser40)/100.0)))), rhpure_mix_alpha) : FMax(2,0.0,FMin(2,1.0,pure_mix.alpha+(exist(opuser40)/100.0)));
                }
                else if (PSD_ON == exist(opscenic) && pure_mix.enable)
                {
                    rhpure_mix_alpha  = _rhpure_mix_alpha.fixedflag ?        ((void)(FMax(2,0.0,FMin(2,1.0,pure_mix.alpha+(exist(opuser41)/100.0)))), rhpure_mix_alpha) : FMax(2,0.0,FMin(2,1.0,pure_mix.alpha+(exist(opuser41)/100.0)));
                }
                else
                {
                    rhpure_mix_alpha  = _rhpure_mix_alpha.fixedflag ?      ((void)(FMax(2,0.0,FMin(2,1.0,pure_mix.alpha))), rhpure_mix_alpha) : FMax(2,0.0,FMin(2,1.0,pure_mix.alpha));
                }
                rhpure_mix_otsu_class_qty  = _rhpure_mix_otsu_class_qty.fixedflag ?  ((void)(pure_mix.otsu_class_qty), rhpure_mix_otsu_class_qty) : pure_mix.otsu_class_qty;
                rhpure_mix_exp_wt  = _rhpure_mix_exp_wt.fixedflag ?  ((void)(pure_mix.exp_wt), rhpure_mix_exp_wt) : pure_mix.exp_wt;
                rhpure_mix_erode_dist  = _rhpure_mix_erode_dist.fixedflag ?  ((void)(pure_mix.erode_dist), rhpure_mix_erode_dist) : pure_mix.erode_dist;
                rhpure_mix_dilate_dist  = _rhpure_mix_dilate_dist.fixedflag ?  ((void)(pure_mix.dilate_dist), rhpure_mix_dilate_dist) : pure_mix.dilate_dist;
                rhpure_mix_aniso_blur  = _rhpure_mix_aniso_blur.fixedflag ?  ((void)(pure_mix.aniso_blur), rhpure_mix_aniso_blur) : pure_mix.aniso_blur;
                rhpure_mix_aniso_erode_dist  = _rhpure_mix_aniso_erode_dist.fixedflag ?  ((void)(pure_mix.aniso_erode_dist), rhpure_mix_aniso_erode_dist) : pure_mix.aniso_erode_dist;
                rhpure_mix_aniso_dilate_dist  = _rhpure_mix_aniso_dilate_dist.fixedflag ?  ((void)(pure_mix.aniso_dilate_dist), rhpure_mix_aniso_dilate_dist) : pure_mix.aniso_dilate_dist;
            }
            else
            {
                rhpure_mix_lambda  = _rhpure_mix_lambda.fixedflag ?  ((void)(rhpure_lambda), rhpure_mix_lambda) : rhpure_lambda;
                rhpure_mix_tuning_factor_surface  = _rhpure_mix_tuning_factor_surface.fixedflag ?  ((void)(rhpure_tuning_factor_surface), rhpure_mix_tuning_factor_surface) : rhpure_tuning_factor_surface;
                rhpure_mix_tuning_factor_body  = _rhpure_mix_tuning_factor_body.fixedflag ?  ((void)(rhpure_tuning_factor_body), rhpure_mix_tuning_factor_body) : rhpure_tuning_factor_body;
                rhpure_mix_blur_enable  = _rhpure_mix_blur_enable.fixedflag ?  ((void)(rhpure_blur_enable), rhpure_mix_blur_enable) : rhpure_blur_enable;
                rhpure_mix_blur  = _rhpure_mix_blur.fixedflag ?  ((void)(rhpure_blur), rhpure_mix_blur) : rhpure_blur;
                rhpure_mix_alpha  = _rhpure_mix_alpha.fixedflag ?        
                                        
                                           ((void)((isDVSystem()&&(B0_15000==cffield)&&(!strncmp("memp_pure",get_psd_name(),9)||!strncmp("fse_pure",get_psd_name(),8)))?1.0:0.0), rhpure_mix_alpha) : (isDVSystem()&&(B0_15000==cffield)&&(!strncmp("memp_pure",get_psd_name(),9)||!strncmp("fse_pure",get_psd_name(),8)))?1.0:0.0;
            }

            /* SCENIC */
            if (FAILURE == getScenicParameters(model_parameters, &scenic))
            {
                epic_error(use_ermes, "Support routine %s failed.",
                           EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                           STRING_ARG, "getScenicParameters");
                return FAILURE;
            }
            rhn4_slice_down_sample_rate    = _rhn4_slice_down_sample_rate.fixedflag ?  ((void)(scenic.itkn4.slice_down_sample_rate), rhn4_slice_down_sample_rate) : scenic.itkn4.slice_down_sample_rate;
            rhn4_inplane_down_sample_rate  = _rhn4_inplane_down_sample_rate.fixedflag ?  ((void)(scenic.itkn4.inplane_down_sample_rate), rhn4_inplane_down_sample_rate) : scenic.itkn4.inplane_down_sample_rate;
            rhn4_num_levels_max            = _rhn4_num_levels_max.fixedflag ?  ((void)(scenic.itkn4.num_levels_max), rhn4_num_levels_max) : scenic.itkn4.num_levels_max;
            rhn4_num_iterations_max        = _rhn4_num_iterations_max.fixedflag ?  ((void)(scenic.itkn4.num_iterations_max), rhn4_num_iterations_max) : scenic.itkn4.num_iterations_max;
            rhn4_convergence_threshold     = _rhn4_convergence_threshold.fixedflag ?  ((void)(scenic.itkn4.convergence_threshold), rhn4_convergence_threshold) : scenic.itkn4.convergence_threshold;
            rhn4_gain_clamp_mode           = _rhn4_gain_clamp_mode.fixedflag ?  ((void)(scenic.itkn4.gain_clamp_mode), rhn4_gain_clamp_mode) : scenic.itkn4.gain_clamp_mode;
            rhn4_gain_clamp_value          = _rhn4_gain_clamp_value.fixedflag ?  ((void)(scenic.itkn4.gain_clamp_value), rhn4_gain_clamp_value) : scenic.itkn4.gain_clamp_value;
    
            rh_ime_scic_enable   = _rh_ime_scic_enable.fixedflag ?    ((void)((scenic.scic.allow&&SCENIC_TYPE_SCIC_FILTER==rhscenic_type)), rh_ime_scic_enable) : (scenic.scic.allow&&SCENIC_TYPE_SCIC_FILTER==rhscenic_type);
            rh_ime_scic_focus    = _rh_ime_scic_focus.fixedflag ?  ((void)(scenic.scic.focus), rh_ime_scic_focus) : scenic.scic.focus;
            rh_ime_scic_smooth   = _rh_ime_scic_smooth.fixedflag ?  ((void)(scenic.scic.smooth), rh_ime_scic_smooth) : scenic.scic.smooth;
            rh_ime_scic_edge     = _rh_ime_scic_edge.fixedflag ?  ((void)(scenic.scic.edge), rh_ime_scic_edge) : scenic.scic.edge;
            rh_ime_scic_gauss    = _rh_ime_scic_gauss.fixedflag ?  ((void)(scenic.scic.gauss), rh_ime_scic_gauss) : scenic.scic.gauss;
            rh_ime_scic_reduction  = _rh_ime_scic_reduction.fixedflag ?  ((void)(scenic.scic.reduction), rh_ime_scic_reduction) : scenic.scic.reduction;
            rh_ime_scic_threshold  = _rh_ime_scic_threshold.fixedflag ?  ((void)(scenic.scic.threshold), rh_ime_scic_threshold) : scenic.scic.threshold;
            rh_ime_scic_contrast   = _rh_ime_scic_contrast.fixedflag ?  ((void)(scenic.scic.contrast), rh_ime_scic_contrast) : scenic.scic.contrast;

            if (PURE2 == exist(oppure) || SCENIC_TYPE_ITKN4_FILTER <= rhscenic_type) 
            {
                /* turn off gain clamp mode when gain_clamp_value is less
                 *              * than 0.5 or bigger than 5.0*/
                rhn4_gain_clamp_mode  = _rhn4_gain_clamp_mode.fixedflag ?    ((void)((rhn4_gain_clamp_value<5.0f)&&(rhn4_gain_clamp_value>=0.5f)), rhn4_gain_clamp_mode) : (rhn4_gain_clamp_value<5.0f)&&(rhn4_gain_clamp_value>=0.5f);
            }
            else
            {
                rhn4_gain_clamp_value  = _rhn4_gain_clamp_value.fixedflag ?  ((void)(5.0f), rhn4_gain_clamp_value) : 5.0f;
                rhn4_gain_clamp_mode  = _rhn4_gain_clamp_mode.fixedflag ?  ((void)(0), rhn4_gain_clamp_mode) : 0;
            }
            rhpure_gain_clamp_value  = _rhpure_gain_clamp_value.fixedflag ?  ((void)(rhn4_gain_clamp_value), rhpure_gain_clamp_value) : rhn4_gain_clamp_value;
            rhpure_gain_clamp_mode  = _rhpure_gain_clamp_mode.fixedflag ?  ((void)(rhn4_gain_clamp_mode), rhpure_gain_clamp_mode) : rhn4_gain_clamp_mode;        
        }

        if( truenex <= 0 )
        {
            /* PSDs which do not use truenex, as tools, and Spectro,
               will use nex. Truenex is used in Odd Nex NPW cases */
            truenex  = _truenex.fixedflag ?  ((void)(nex), truenex) : nex;
        }

        /* Set NEX for unacquired encodes for when zero-fill BAM is enabled */
        rhnex_unacquired  = _rhnex_unacquired.fixedflag ?  ((void)((int)(ceil(truenex))), rhnex_unacquired) : (int)(ceil(truenex));

        if( opimode==PSD_CINE )
        {
            rhrawsize = (n64)opclocs * (n64)opnecho * (n64)rhfrsize
                * (n64)((oppseq == PSD_PC || oppseq == PSD_PCSP) ?
                        (2 + (opflaxall == 1 ? 2 : 0)) : 1)
                * (n64)(2*rhptsize) * (n64)opcphases
                * (n64)ceil((float)(1 + (rhbline * rawdata) + rhnframes + rhhnover)
                            * ((float)(1 - rawdata) + (truenex * (float)rawdata)));

        }
        else
        {
            rhrawsize = (n64)slquant1 * (n64)opnecho * (n64)rhfrsize * (n64)(2*rhptsize)
                * (n64)ceil((float)(1 + (rhbline * rawdata) + rhnframes + rhhnover)
                            * ((exnex * (float)(1 - rawdata)) + (truenex * (float)rawdata)));

            /*a MRIge91983 - RDP - minimal acquisition size (single coil, single slice, 50 views) */
            if (rotateflag == 2)
            {
                rhrawsize = (n64)opnecho * (n64)rhfrsize * (n64)(2*rhptsize)
                    * (n64)ceil((float)(1 + (rhbline * rawdata) + 50 + rhhnover)
                                * ((exnex * (float)(1 - rawdata)) + (truenex * (float)rawdata)));
            }
        }


     if( oppomp )
     {
         if( opxres == 512 )
         {
             rhrcyres  = _rhrcyres.fixedflag ?  ((void)(1024), rhrcyres) : 1024;
         }
         else
         {
             rhrcyres  = _rhrcyres.fixedflag ?  ((void)(512), rhrcyres) : 512;
         }
     }
     else
     {
         rhrcyres  = _rhrcyres.fixedflag ?  ((void)(eg_phaseres), rhrcyres) : eg_phaseres;
     }

     if( (exist(opzip1024) == PSD_ON) || (exist(opxres) > 512) )
     {
         rhrcxres  = _rhrcxres.fixedflag ?  ((void)(1024), rhrcxres) : 1024;          /* 1024 ZIP */
     } 
     else if( ((exist(opzip512) == PSD_ON) && (existcv(opzip512)) )
              || (exist(opxres) > 256) || (exist(opairecon) > DL_RECON_MODE_OFF) )
     {
         rhrcxres  = _rhrcxres.fixedflag ?  ((void)(512), rhrcxres) : 512;           /* 512 ZIP or standard 512 recon */
     }
     else 
     {
         rhrcxres  = _rhrcxres.fixedflag ?  ((void)(256), rhrcxres) : 256;           /* Standard 256 recon */
     }

        rhmethod  = _rhmethod.fixedflag ?  ((void)(oppomp), rhmethod) : oppomp;
        rhdaxres  = _rhdaxres.fixedflag ?  ((void)(opxres), rhdaxres) : opxres;

        rhrcctrl  = _rhrcctrl.fixedflag ?            
                          ((void)(recon_mag_image*RHRCMAG|rawmode*RHRCRAW|recon_pha_image*RHRCPHS|recon_imag_image*RHRCIMAG|recon_qmag_image*RHRCQMAG), rhrcctrl) : recon_mag_image*RHRCMAG|rawmode*RHRCRAW|recon_pha_image*RHRCPHS|recon_imag_image*RHRCIMAG|recon_qmag_image*RHRCQMAG;
        if( cfcompress < 100 )
        {
            rhrcctrl  = _rhrcctrl.fixedflag ?  ((void)(RHRCCOMP), rhrcctrl) : rhrcctrl+RHRCCOMP;
        }

        if ( opimode==PSD_CINE )
        {
            rhcphases  = _rhcphases.fixedflag ?  ((void)(opcphases), rhcphases) : opcphases;
            /*have to convert this from uSec to Sec */
            rhctr  = _rhctr.fixedflag ?  ((void)((FLOAT)optr/1000000.0), rhctr) : (FLOAT)optr/1000000.0;
            rhcrrtime  = _rhcrrtime.fixedflag ?  ((void)(60.0/(FLOAT)opchrate), rhcrrtime) : 60.0/(FLOAT)opchrate; /* also in Sec */
        }

        /* Support choice of gradient coil for twin gradient coils (Gili) */
        rhgradmode  = _rhgradmode.fixedflag ?  ((void)(opgradmode), rhgradmode) : opgradmode;

        rhte  = _rhte.fixedflag ?  ((void)(opte), rhte) : opte;
        rhte2  = _rhte2.fixedflag ?  ((void)(opte2), rhte2) : opte2;
        
        rhscancent  = _rhscancent.fixedflag ?  ((void)(piscancenter), rhscancent) : piscancenter;
        
        if(fnecho_lim < 1.0)
        {
          if((PSD_3D == exist(opimode)) && (PSD_ON == exist(opdixon)))
            rhfeextra  = _rhfeextra.fixedflag ?       ((void)((int)((fnecho_lim-0.5)*rhfrsize+0.5)), rhfeextra) : (int)((fnecho_lim-0.5)*rhfrsize+0.5);
          else
           rhfeextra  = _rhfeextra.fixedflag ?    ((void)(rhfrsize-exist(opxres)/2), rhfeextra) : rhfrsize-exist(opxres)/2;
        }
        else
        {
          rhfeextra  = _rhfeextra.fixedflag ?  ((void)(0), rhfeextra) : 0;
        }

        rh3dgw_interptype  = _rh3dgw_interptype.fixedflag ?  ((void)(RH3DGW_BICUBIC_INTERP), rh3dgw_interptype) : RH3DGW_BICUBIC_INTERP; 

        /* Set DL Recon parameters */
        if(exist(opairecon) > DL_RECON_MODE_OFF)
        {
            rh_airiq_config  = _rh_airiq_config.fixedflag ?  ((void)(PSD_ON), rh_airiq_config) : PSD_ON;
            rh_airiq_level_b  = _rh_airiq_level_b.fixedflag ?  ((void)(1.0), rh_airiq_level_b) : 1.0;
            rh_airiq_win_r  = _rh_airiq_win_r.fixedflag ?  ((void)(0.85), rh_airiq_win_r) : 0.85;
            rh_airiq_win_w  = _rh_airiq_win_w.fixedflag ?  ((void)(0.075), rh_airiq_win_w) : 0.075;

            if(exist(opairecon) == DL_RECON_MODE_LOW)
            {
                rh_airiq_level_a  = _rh_airiq_level_a.fixedflag ?  ((void)(DL_RECON_DENOISE_LOW), rh_airiq_level_a) : DL_RECON_DENOISE_LOW;
            }
            else if(exist(opairecon) == DL_RECON_MODE_MEDIUM)
            {
                rh_airiq_level_a  = _rh_airiq_level_a.fixedflag ?  ((void)(DL_RECON_DENOISE_MEDIUM), rh_airiq_level_a) : DL_RECON_DENOISE_MEDIUM;
            }
            else if(exist(opairecon) == DL_RECON_MODE_HIGH)
            {
                rh_airiq_level_a  = _rh_airiq_level_a.fixedflag ?  ((void)(DL_RECON_DENOISE_HIGH), rh_airiq_level_a) : DL_RECON_DENOISE_HIGH;
            }
        }
        else
        {
            rh_airiq_config  = _rh_airiq_config.fixedflag ?  ((void)(PSD_OFF), rh_airiq_config) : PSD_OFF;
            rh_airiq_level_a  = _rh_airiq_level_a.fixedflag ?  ((void)(0.0), rh_airiq_level_a) : 0.0;
            rh_airiq_level_b  = _rh_airiq_level_b.fixedflag ?  ((void)(0.0), rh_airiq_level_b) : 0.0;
            rh_airiq_win_r  = _rh_airiq_win_r.fixedflag ?  ((void)(0.0), rh_airiq_win_r) : 0.0;
            rh_airiq_win_w  = _rh_airiq_win_w.fixedflag ?  ((void)(0.0), rh_airiq_win_w) : 0.0;
        }

        /* Generate unique ID for this scan for naming kacq files and debug files.
        Use the current time (HHMMSSmSmS).*/
        {
            int uid;
            time_t now_epoch = time(NULL);
            struct tm now;
            struct timeval now2;

            localtime_r(&now_epoch, &now);
            gettimeofday(&now2, NULL);
            uid = now2.tv_usec/1000 +
                now.tm_sec      * 1000 +
                now.tm_min      * 100000 +
                now.tm_hour     * 10000000;
            rhkacq_uid  = _rhkacq_uid.fixedflag ?  ((void)(uid), rhkacq_uid) : uid;
        }


    } /* End of code inlined from loadrheader.e rheaderinit */


	scalerotmats( rsprot, &loggrd, &phygrd, (int)(opslquant), obl_debug );

{ /* Start of code inlined from Prescan.e PSpredownload */
    /*********************************************************************
     *                     PRESCAN.E HOST SECTION                        *
     *                         PSpredownload                             *
     *                                                                   *
     * Write here the code unique to the Host PSD process. All code to   *
     * be executed in predownload() must be written here.                *
     *********************************************************************/
    if (FAILURE==PSpredownload())
    {
        return FAILURE;
    }
    if (FAILURE==FTGpredownload())
    {
        return FAILURE;
    }
    if (FAILURE==XTGpredownload())
    {
        return FAILURE;
    }
    if (FAILURE==ASpredownload())
    {
        return FAILURE;
    }
    if (FAILURE==RSpredownload())
    {
        return FAILURE;
    }
    if (FAILURE==DTGpredownload())
    {
        return FAILURE;
    }
    if (FAILURE==AutoCoilpredownload())
    {
        return FAILURE;
    }
    if (FAILURE==ExtCalpredownload())
    {
        return FAILURE;
    }

} /* End of code inlined from Prescan.e PSpredownload */


	/***************************** Gradient Structure Initializations ******************************/

	gradx[GX1_SLOT].num = 1;
	gradx[GXW2_SLOT].num = 1;
	grady[GY1_SLOT].num = 1;
	gradz[GZRF1_SLOT].num = 1;
	gradz[GZ1_SLOT].num = 1;

	avepepowscale(&(grady[GY1_SLOT].scale), rhnframes, rhnframes/2);

	gradx[GX1_SLOT].powscale = 1.0;
	gradx[GXW2_SLOT].powscale = 1.0;
	grady[GY1_SLOT].powscale = 1.0;
	gradz[GZRF1_SLOT].powscale = 1.0;
	gradz[GZ1_SLOT].powscale = 1.0;





	return SUCCESS;
}   /* end predownload() */


/*********************************************************************
 *                     PRESCAN.E HOST SECTION                        *
 *                             PShost                                *
 *                                                                   *
 * Write here the code unique to the Host PSD process.               *
 *********************************************************************/
#include <string.h>
#include "sar_limit_api.h"
#include "sar_pm.h" 

/*
 *  set_presscfh_mode
 *  
 *  Type: Private Function
 *  
 *  Description: Set the modes for presscfh
 * 			PRESSCFH_SLICE 1      
 * 			PRESSCFH_SLAB 2                                              
 * 			PRESSCFH_SHIMVOL 3
 * 			PRESSCFH_SHIMVOL_SLICE 4
 * 			PRESSCFH_NONE          5
 * 
 * */

STATUS
set_presscfh_mode (void)
{
    if(exist(oppscvquant) >= 1)
    {
        if (presscfh_override > 0) 
        {
            cvoverride(presscfh, presscfh_override, PSD_FIX_ON, PSD_EXIST_ON);
        }
        else if (cfh_steam_flag == PSD_ON)
        {
            /* For STEAM CFH mode, force to use shim volume mode */
            cvoverride(presscfh, PRESSCFH_SHIMVOL, PSD_FIX_ON, PSD_EXIST_ON);
        }
        else
        {
            switch(exist(opimode)) 
            {
                case PSD_2D:
                case PSD_CINE: 
                    if( (opplane == PSD_3PLANE) || ((exist(oprealtime) == PSD_ON)) || (exist(opcoax) == 0) )
                    {   /* For 3-Plane or Realtime or Radial mode use SHIMVOL Mode*/
                        cvoverride(presscfh, PRESSCFH_SHIMVOL, PSD_FIX_ON, PSD_EXIST_ON);
                    }
                    else if(exist(opassetcal) && existcv(opassetcal) 
                               && ( (1==exist(opasset)) || (exist(opasset) == ASSET_REG_CAL) ) && existcv(opasset)) 
                            {
                                cvoverride(presscfh, PRESSCFH_SHIMVOL, PSD_FIX_ON, PSD_EXIST_ON);
                            }
                    else /* NON-RADIAL MODE */
                    {
                        int vidx;
                        for( vidx = 0; vidx < exist(oppscvquant); vidx ++ )
                        {
                            if( shimvol_slice_intersect(&psc_info[vidx], &scan_info[PSslice_num], 0, PSdebugstate) != 0 ) 
                            {
                                cvoverride(presscfh, PRESSCFH_SHIMVOL, PSD_FIX_ON, PSD_EXIST_ON);
                            } 
                            else 
                            {
                                cvoverride(presscfh, PRESSCFH_NONE, PSD_FIX_ON, PSD_EXIST_ON);	
                                break;
                            }
                        }
                    }
                    break;
                case PSD_3D:
                case PSD_3DM:
                case PSD_ANGIO:
                    /* If Shim Volume is placed */
                    if( exist(opcoax) != 0 )      /* Non-Radial/Oblique MODE */
                    {
                        if( exist(opvquant) > 1 )     /* Multiple Slabs */
                        {
                            cvoverride(presscfh, PRESSCFH_SHIMVOL, PSD_FIX_ON, PSD_EXIST_ON);	
                        }
                        else     /* Single Slab */
                        {
                            int vidx;
                            for( vidx = 0; vidx < exist(oppscvquant); vidx ++ )
                            {
                                if( shimvol_slice_intersect(&psc_info[vidx], &scan_info[PSslice_num], 0, PSdebugstate) != 0 ) 
                                {
                                    cvoverride(presscfh, PRESSCFH_SHIMVOL, PSD_FIX_ON, PSD_EXIST_ON);
                                } 
                                else 
                                {
                                    cvoverride(presscfh, PRESSCFH_NONE, PSD_FIX_ON, PSD_EXIST_ON);	
                                    break;
                                }
                            }
                        }
                    }
                    else     /* Radial Case or Orthogonal Slabs */
                    {
                        cvoverride(presscfh, PRESSCFH_SHIMVOL, PSD_FIX_ON, PSD_EXIST_ON);
                    }
                    break;
                default: 
                    cvoverride(presscfh, PRESSCFH_NONE, PSD_FIX_ON, PSD_EXIST_ON);
                    break;
            }
        } 
    }
    else
    {
        cvoverride(presscfh, PRESSCFH_NONE, PSD_FIX_ON, PSD_EXIST_ON);
    }
    
    if(presscfh_debug) 
    {
        printf("\n The presscfh is %d (1 - SLICE, 2 - SLAB, 3 - SHIMVOL 4- NONE)\n",presscfh);
        printf("\n The presscfh_ctrl is %d (1 - SLICE, 2 - SLAB, 3 - SHIMVOL 4- NONE), \n",presscfh_ctrl);
        printf("\n The presscfh_override is %d (1 - SLICE, 2 - SLAB, 3 - SHIMVOL 4- NONE)\n",presscfh_override);
        fflush(stdout);
    }
    return SUCCESS;
}

/*
 *  sr_derate
 *  
 *  Type: Private Function
 *  
 *  Description:
 *    update the ramp time for loggrad by *sr_derate_factor  
 *    @param[out] lgrad, logical gradient characteristics
 *    @param[in]  sc_derate_factor, SR derating factor ( >=1.0 ) 
 *
 */

STATUS
sr_derate (LOG_GRAD *lgrad, const float sr_derate_factor, const float amp_derate_factor)
{
    STATUS status = SUCCESS;

    if ((sr_derate_factor < 1.0) || (amp_derate_factor < 1.0))
    {
        status = FAILURE;
    }
    else
    {
        lgrad->xrt = (int)ceilf(lgrad->xrt*sr_derate_factor);
        lgrad->yrt = (int)ceilf(lgrad->yrt*sr_derate_factor);
        lgrad->zrt = (int)ceilf(lgrad->zrt*sr_derate_factor);
        lgrad->xft = (int)ceilf(lgrad->xft*sr_derate_factor);
        lgrad->yft = (int)ceilf(lgrad->yft*sr_derate_factor);
        lgrad->zft = (int)ceilf(lgrad->zft*sr_derate_factor);
        
        lgrad->tx_xyz = lgrad->tx_xyz/amp_derate_factor;
        lgrad->ty_xyz = lgrad->ty_xyz/amp_derate_factor;
        lgrad->tz_xyz = lgrad->tz_xyz/amp_derate_factor;
        lgrad->tx_xy = lgrad->tx_xy/amp_derate_factor;
        lgrad->tx_xz = lgrad->tx_xz/amp_derate_factor;
        lgrad->ty_xy = lgrad->ty_xy/amp_derate_factor;
        lgrad->ty_yz = lgrad->ty_yz/amp_derate_factor;
        lgrad->tz_xz = lgrad->tz_xz/amp_derate_factor;
        lgrad->tz_yz = lgrad->tz_yz/amp_derate_factor;
        lgrad->tx = lgrad->tx/amp_derate_factor;
        lgrad->ty = lgrad->ty/amp_derate_factor;
        lgrad->tz = lgrad->tz/amp_derate_factor;

        status = SUCCESS;
    }

    return status;
}

/*
 *  PS1cvinit
 *  
 *  Type: Private Function
 *  
 *  Description:
 *  
 */
STATUS
PS1cvinit( void )
{
    INT index;

    /* initialize pulse widths */
    pw_rf1mps1  = _pw_rf1mps1.fixedflag ?  ((void)(rfpulse[RF1_APS1_SLOT].nom_pw), pw_rf1mps1) : rfpulse[RF1_APS1_SLOT].nom_pw;
    pw_rf2mps1  = _pw_rf2mps1.fixedflag ?  ((void)(rfpulse[RF2_APS1_SLOT].nom_pw), pw_rf2mps1) : rfpulse[RF2_APS1_SLOT].nom_pw;

    /* initialize resolutions */
    res_rf1mps1  = _res_rf1mps1.fixedflag ?  ((void)(0), res_rf1mps1) : 0;
    res_rf2mps1  = _res_rf2mps1.fixedflag ?  ((void)(0), res_rf2mps1) : 0;

    /* initialize amplitudes */
    a_rf1mps1  = _a_rf1mps1.fixedflag ?  ((void)(0.5), a_rf1mps1) : 0.5;
    a_rf2mps1  = _a_rf2mps1.fixedflag ?  ((void)(1.0), a_rf2mps1) : 1.0;

    /* initialize flip angles */
    flip_rf1mps1  = _flip_rf1mps1.fixedflag ?  ((void)(90), flip_rf1mps1) : 90;
    /* increase refocus flip angle in slow TG on 7T to achieve automatic
     * 20 count TG reduction. 
     * */
    if ( (cffield == B0_70000) && isCategoryMatchForAnatomy(exist(opanatomy), ATTRIBUTE_CATEGORY_HEAD) )
        flip_rf2mps1  = _flip_rf2mps1.fixedflag ?  ((void)(250), flip_rf2mps1) : 250;
    else
        flip_rf2mps1  = _flip_rf2mps1.fixedflag ?  ((void)(180), flip_rf2mps1) : 180;

    /* initialize sinc cycles */
    cyc_rf1mps1  = _cyc_rf1mps1.fixedflag ?  ((void)(1), cyc_rf1mps1) : 1;
    cyc_rf2mps1  = _cyc_rf2mps1.fixedflag ?  ((void)(1), cyc_rf2mps1) : 1;

    /* initialize gscale values */
    gscale_rf1mps1  = _gscale_rf1mps1.fixedflag ?  ((void)(0.90909), gscale_rf1mps1) : 0.90909;
    gscale_rf2mps1  = _gscale_rf2mps1.fixedflag ?  ((void)(0.4545), gscale_rf2mps1) : 0.4545;

    /* begin aps1_mod changes (GE) */
    if ( ( getAps1Mod() > 0 || ((B0_15000 == cffield) && isLowSarEnabled()) ) && (PSD_OFF == local_tg) )
    {
        for( index = 0; index < 9; index++)
        {
            ps1scan_info[0].oprot[index] = 0.0;
        }

        if (1==getAps1ModPlane()) /* Axial, read=x */
        {
            ps1scan_info[0].oprot[0] = ps1scan_info[0].oprot[4] = ps1scan_info[0].oprot[8] = 1.0;
        }
        if (2==getAps1ModPlane()) /* Sagittal, read=z */
        {
            ps1scan_info[0].oprot[2] = ps1scan_info[0].oprot[4] = ps1scan_info[0].oprot[6] = 1.0;
        }
        if (3==getAps1ModPlane()) /* Coronal, read=z */
        {
            ps1scan_info[0].oprot[1] = ps1scan_info[0].oprot[5] = ps1scan_info[0].oprot[6] = 1.0;
        }
        if (4==getAps1ModPlane()) /* Axial, read=y */
        {
            ps1scan_info[0].oprot[1] = ps1scan_info[0].oprot[3] = ps1scan_info[0].oprot[8] = 1.0;
        }
        if (5==getAps1ModPlane()) /* Sagittal, read=y */
        {
            ps1scan_info[0].oprot[2] = ps1scan_info[0].oprot[3] = ps1scan_info[0].oprot[7] = 1.0;
        }
        if (6==getAps1ModPlane()) /* Coronal, read=x */
        {
            ps1scan_info[0].oprot[0] = ps1scan_info[0].oprot[5] = ps1scan_info[0].oprot[7] = 1.0;
        }
    }
    else if((oppscvquant > 0) && (PSD_ON == local_tg))
    {
        for (index = 0; index < 9; index++)
        {
            ps1scan_info[0].oprot[index] = psc_info[0].oppscrot[index]; /* use shim vol rot for local tg */ 
        }
    }
    else
    {
        for (index = 0; index < 9; index++)
        {
            ps1scan_info[0].oprot[index] = scan_info[PSslice_num].oprot[index]; /* use Rxed slice rot */ 
        }
    }
    /* end aps1_mod changes (GE) */

    ps1_newgeo  = _ps1_newgeo.fixedflag ?  ((void)(1), ps1_newgeo) : 1;
    if (obloptimize(&ps1loggrd, &phygrd, ps1scan_info, 1, PSD_OBL,
                    0, obl_method, ps1obl_debug, _ps1_newgeo.fixedflag ? (_temp6_ps1_newgeo=ps1_newgeo,&_temp6_ps1_newgeo) : &ps1_newgeo,
                    cfsrmode) == FAILURE)
    {
        epic_error(use_ermes, "%s failed in PS1cvinit.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "obloptimize"); 
        return FAILURE;
    }

    /* derate SR for quiet PSC */ 
    sr_derate(&ps1loggrd, PSsr_derate_factor, PSamp_derate_factor);

    return SUCCESS;
}

/*
 *  CFLcvinit
 *  
 *  Type: Private Function
 *  
 *  Description:
 *  
 */
STATUS
CFLcvinit( void )
{
    /* initialize pulse widths */
    pw_rf1cfl  = _pw_rf1cfl.fixedflag ?  ((void)(rfpulse[RF1_CFL_SLOT].nom_pw), pw_rf1cfl) : rfpulse[RF1_CFL_SLOT].nom_pw;

    /* initialize resolutions */
    res_rf1cfl  = _res_rf1cfl.fixedflag ?   ((void)(0), res_rf1cfl) : 0;

    /* initialize amplitudes */
    a_rf1cfl  = _a_rf1cfl.fixedflag ?  ((void)(0.5), a_rf1cfl) : 0.5;

    /* initialize flip angles */
    flip_rf1cfl  = _flip_rf1cfl.fixedflag ?  ((void)(90), flip_rf1cfl) : 90;

    /* initialize sinc cycles */
    cyc_rf1cfl  = _cyc_rf1cfl.fixedflag ?  ((void)(2), cyc_rf1cfl) : 2; /* MRIhc54366: increased from 1 */

    /* initialize gscale values */
    gscale_rf1cfl  = _gscale_rf1cfl.fixedflag ?  ((void)(0.90909), gscale_rf1cfl) : 0.90909;

    return SUCCESS;
}


/*
 *  RCVNcvinit
 *  
 *  Type: Private Function
 *  
 *  Description:
 *  
 */
STATUS
RCVNcvinit( void )
{
    if (CFG_VAL_RECEIVER_RRF == cfreceivertype)
    {
        rcvn_xres  = _rcvn_xres.fixedflag ?  ((void)(1024), rcvn_xres) : 1024;
    }
    else
    {
        rcvn_xres  = _rcvn_xres.fixedflag ?  ((void)(4096), rcvn_xres) : 4096;
    }


    return SUCCESS;
}


/*
 *  CFHcvinit
 *  
 *  Type: Private Function
 *  
 *  Description:
 *  
 */
STATUS
CFHcvinit( void )
{
    /* initialize pulse widths */
    pw_rf0cfh  = _pw_rf0cfh.fixedflag ?  ((void)(rfpulse[RF0_CFH_SLOT].nom_pw), pw_rf0cfh) : rfpulse[RF0_CFH_SLOT].nom_pw;
    pw_rf1cfh  = _pw_rf1cfh.fixedflag ?  ((void)(rfpulse[RF1_CFH_SLOT].nom_pw), pw_rf1cfh) : rfpulse[RF1_CFH_SLOT].nom_pw;
    pw_rf2cfh  = _pw_rf2cfh.fixedflag ?  ((void)(rfpulse[RF2_CFH_SLOT].nom_pw), pw_rf2cfh) : rfpulse[RF2_CFH_SLOT].nom_pw;
    pw_rf3cfh  = _pw_rf3cfh.fixedflag ?  ((void)(rfpulse[RF3_CFH_SLOT].nom_pw), pw_rf3cfh) : rfpulse[RF3_CFH_SLOT].nom_pw; /* For presscfh MRIhc08321 */
    pw_rf4cfh  = _pw_rf4cfh.fixedflag ?  ((void)(rfpulse[RF4_CFH_SLOT].nom_pw), pw_rf4cfh) : rfpulse[RF4_CFH_SLOT].nom_pw;

    /* initialize resolutions */
    res_rf0cfh  = _res_rf0cfh.fixedflag ?   ((void)(RES_SH_ADIABATIC), res_rf0cfh) : RES_SH_ADIABATIC; /* Adiabatic pulse */
    res_rf1cfh  = _res_rf1cfh.fixedflag ?   ((void)(0), res_rf1cfh) : 0;
    res_rf2cfh  = _res_rf2cfh.fixedflag ?   ((void)(0), res_rf2cfh) : 0;
    res_rf3cfh  = _res_rf3cfh.fixedflag ?   ((void)(0), res_rf3cfh) : 0; /* For presscfh MRIhc08321 */
    res_rf4cfh  = _res_rf4cfh.fixedflag ?   ((void)(0), res_rf4cfh) : 0;

    /* initialize amplitudes */
    a_rf0cfh  = _a_rf0cfh.fixedflag ?  ((void)(0.61), a_rf0cfh) : 0.61;
    a_rf1cfh  = _a_rf1cfh.fixedflag ?  ((void)(0.5), a_rf1cfh) : 0.5;
    a_rf2cfh  = _a_rf2cfh.fixedflag ?  ((void)(1.0), a_rf2cfh) : 1.0;
    a_rf3cfh  = _a_rf3cfh.fixedflag ?  ((void)(1.0), a_rf3cfh) : 1.0; /* For presscfh MRIhc08321 */
    a_rf4cfh  = _a_rf4cfh.fixedflag ?  ((void)(1.0), a_rf4cfh) : 1.0;

    /* initialize flip angles */
    flip_rf0cfh  = _flip_rf0cfh.fixedflag ?  ((void)(180), flip_rf0cfh) : 180;
    flip_rf1cfh  = _flip_rf1cfh.fixedflag ?  ((void)(90), flip_rf1cfh) : 90;
    flip_rf2cfh  = _flip_rf2cfh.fixedflag ?  ((void)(180), flip_rf2cfh) : 180;
    flip_rf3cfh  = _flip_rf3cfh.fixedflag ?  ((void)(180), flip_rf3cfh) : 180; /* For presscfh MRIhc08321 */
    flip_rf4cfh  = _flip_rf4cfh.fixedflag ?  ((void)(180), flip_rf4cfh) : 180;

    /* initialize sinc cycles */
    cyc_rf0cfh  = _cyc_rf0cfh.fixedflag ?  ((void)(2), cyc_rf0cfh) : 2; /* Adiabatic pulse */
    cyc_rf1cfh  = _cyc_rf1cfh.fixedflag ?  ((void)(1), cyc_rf1cfh) : 1;
    cyc_rf2cfh  = _cyc_rf2cfh.fixedflag ?  ((void)(1), cyc_rf2cfh) : 1;
    cyc_rf3cfh  = _cyc_rf3cfh.fixedflag ?  ((void)(1), cyc_rf3cfh) : 1; /* For presscfh MRIhc08321 */
    cyc_rf4cfh  = _cyc_rf4cfh.fixedflag ?  ((void)(1), cyc_rf4cfh) : 1;
    a_gzrf4cfh  = _a_gzrf4cfh.fixedflag ?  ((void)(0.0), a_gzrf4cfh) : 0.0;
    a_gyrf3cfh  = _a_gyrf3cfh.fixedflag ?  ((void)(0.0), a_gyrf3cfh) : 0.0;/*For presscfh MRIhc11621 */
    a_gxrf2cfh  = _a_gxrf2cfh.fixedflag ?  ((void)(0.0), a_gxrf2cfh) : 0.0;/*For  presscfh MRIhc11621 */
    a_gzrf1cfh  = _a_gzrf1cfh.fixedflag ?  ((void)(0.0), a_gzrf1cfh) : 0.0;/*For presscfh MRIhc11621 */
    a_gzrf0cfh  = _a_gzrf0cfh.fixedflag ?  ((void)(0.0), a_gzrf0cfh) : 0.0;/*For presscfh MRIhc11621 */


    /* initialize gscale values */
    gscale_rf1cfh  = _gscale_rf1cfh.fixedflag ?  ((void)(0.90909), gscale_rf1cfh) : 0.90909;

#ifdef PSD_CFH_CHEMSAT
    rfpulse[RFCSSAT_CFH_SLOT].pw = &pw_rfcssatcfh;
    rfpulse[RFCSSAT_CFH_SLOT].amp = &a_rfcssatcfh;
    rfpulse[RFCSSAT_CFH_SLOT].act_fa = &flip_rfcssatcfh;
#endif

    if( presscfh_ctrl != PRESSCFH_NONE && cfh_steam_flag == PSD_ON )
    {
        setuprfpulse(RF1_CFH_SLOT, _pw_rf1cfh.fixedflag ? (_temp7_pw_rf1cfh=pw_rf1cfh,&_temp7_pw_rf1cfh) : &pw_rf1cfh, _a_rf1cfh.fixedflag ? (_temp8_a_rf1cfh=a_rf1cfh,&_temp8_a_rf1cfh) : &a_rf1cfh, SAR_ABS_SINC3, SAR_PSINC3,
                     SAR_ASINC3, SAR_DTYCYC_SINC3, SAR_MAXPW_SINC3, 1,
                     MAX_B1_SINC3_90, MAX_INT_B1_SQ_SINC3_90,
                     MAX_RMS_B1_SINC3_90, 90.0, _flip_rf1cfh.fixedflag ? (_temp9_flip_rf1cfh=flip_rf1cfh,&_temp9_flip_rf1cfh) : &flip_rf1cfh, 3200.0,
                     3750, PSD_CFH_ON, 0,
                     0, 0, _res_rf1cfh.fixedflag ? (_temp10_res_rf1cfh=res_rf1cfh,&_temp10_res_rf1cfh) : &res_rf1cfh, 0, _wg_rf1cfh.fixedflag ? (_temp11_wg_rf1cfh=wg_rf1cfh,&_temp11_wg_rf1cfh) : &wg_rf1cfh, 1, rfpulse);

        setuprfpulse(RF2_CFH_SLOT, _pw_rf2cfh.fixedflag ? (_temp12_pw_rf2cfh=pw_rf2cfh,&_temp12_pw_rf2cfh) : &pw_rf2cfh, _a_rf2cfh.fixedflag ? (_temp13_a_rf2cfh=a_rf2cfh,&_temp13_a_rf2cfh) : &a_rf2cfh, SAR_ABS_SINC3, SAR_PSINC3,
                     SAR_ASINC3, SAR_DTYCYC_SINC3, SAR_MAXPW_SINC3, 1,
                     MAX_B1_SINC3_90, MAX_INT_B1_SQ_SINC3_90,
                     MAX_RMS_B1_SINC3_90, 90.0, _flip_rf2cfh.fixedflag ? (_temp14_flip_rf2cfh=flip_rf2cfh,&_temp14_flip_rf2cfh) : &flip_rf2cfh, 3200.0,
                     3750, PSD_CFH_ON, 0,
                     0, 0, _res_rf2cfh.fixedflag ? (_temp15_res_rf2cfh=res_rf2cfh,&_temp15_res_rf2cfh) : &res_rf2cfh, 0, _wg_rf2cfh.fixedflag ? (_temp16_wg_rf2cfh=wg_rf2cfh,&_temp16_wg_rf2cfh) : &wg_rf2cfh, 1, rfpulse);

        setuprfpulse(RF3_CFH_SLOT, _pw_rf3cfh.fixedflag ? (_temp17_pw_rf3cfh=pw_rf3cfh,&_temp17_pw_rf3cfh) : &pw_rf3cfh, _a_rf3cfh.fixedflag ? (_temp18_a_rf3cfh=a_rf3cfh,&_temp18_a_rf3cfh) : &a_rf3cfh, SAR_ABS_SINC3, SAR_PSINC3,
                     SAR_ASINC3, SAR_DTYCYC_SINC3, SAR_MAXPW_SINC3, 1,
                     MAX_B1_SINC3_90, MAX_INT_B1_SQ_SINC3_90,
                     MAX_RMS_B1_SINC3_90, 90.0, _flip_rf3cfh.fixedflag ? (_temp19_flip_rf3cfh=flip_rf3cfh,&_temp19_flip_rf3cfh) : &flip_rf3cfh, 3200.0,
                     3750, PSD_CFH_ON, 0,
                     0, 0, _res_rf3cfh.fixedflag ? (_temp20_res_rf3cfh=res_rf3cfh,&_temp20_res_rf3cfh) : &res_rf3cfh, 0, _wg_rf3cfh.fixedflag ? (_temp21_wg_rf3cfh=wg_rf3cfh,&_temp21_wg_rf3cfh) : &wg_rf3cfh, 1, rfpulse);

        setuprfpulse(RF4_CFH_SLOT, _pw_rf4cfh.fixedflag ? (_temp22_pw_rf4cfh=pw_rf4cfh,&_temp22_pw_rf4cfh) : &pw_rf4cfh, _a_rf4cfh.fixedflag ? (_temp23_a_rf4cfh=a_rf4cfh,&_temp23_a_rf4cfh) : &a_rf4cfh, SAR_ABS_SINC3, SAR_PSINC3,
                     SAR_ASINC3, SAR_DTYCYC_SINC3, SAR_MAXPW_SINC3, 1,
                     MAX_B1_SINC3_90, MAX_INT_B1_SQ_SINC3_90,
                     MAX_RMS_B1_SINC3_90, 90.0, _flip_rf4cfh.fixedflag ? (_temp24_flip_rf4cfh=flip_rf4cfh,&_temp24_flip_rf4cfh) : &flip_rf4cfh, 3200.0,
                     3750, PSD_CFH_ON, 0,
                     0, 0, _res_rf4cfh.fixedflag ? (_temp25_res_rf4cfh=res_rf4cfh,&_temp25_res_rf4cfh) : &res_rf4cfh, 0, _wg_rf4cfh.fixedflag ? (_temp26_wg_rf4cfh=wg_rf4cfh,&_temp26_wg_rf4cfh) : &wg_rf4cfh, 1, rfpulse);

        a_rf0cfh  = _a_rf0cfh.fixedflag ?  ((void)(1), a_rf0cfh) : 1;
        a_rf1cfh  = _a_rf1cfh.fixedflag ?  ((void)(0.5464), a_rf1cfh) : 0.5464; /* 0.5/0.61*(60/90) */
        a_rf2cfh  = _a_rf2cfh.fixedflag ?  ((void)(0.5464), a_rf2cfh) : 0.5464;
        a_rf3cfh  = _a_rf3cfh.fixedflag ?  ((void)(0.5464), a_rf3cfh) : 0.5464; 
        a_rf4cfh  = _a_rf4cfh.fixedflag ?  ((void)(0.5464), a_rf4cfh) : 0.5464; 

        flip_rf1cfh  = _flip_rf1cfh.fixedflag ?  ((void)(60), flip_rf1cfh) : 60;
        flip_rf2cfh  = _flip_rf2cfh.fixedflag ?  ((void)(60), flip_rf2cfh) : 60;
        flip_rf3cfh  = _flip_rf3cfh.fixedflag ?  ((void)(60), flip_rf3cfh) : 60; 
        flip_rf4cfh  = _flip_rf4cfh.fixedflag ?  ((void)(60), flip_rf4cfh) : 60; 

        cyc_rf1cfh  = _cyc_rf1cfh.fixedflag ?  ((void)(3), cyc_rf1cfh) : 3;
        cyc_rf2cfh  = _cyc_rf2cfh.fixedflag ?  ((void)(3), cyc_rf2cfh) : 3;
        cyc_rf3cfh  = _cyc_rf3cfh.fixedflag ?  ((void)(3), cyc_rf3cfh) : 3; 
        cyc_rf4cfh  = _cyc_rf4cfh.fixedflag ?  ((void)(3), cyc_rf4cfh) : 3; 
    }
    else
    {
        setuprfpulse(RF1_CFH_SLOT, _pw_rf1cfh.fixedflag ? (_temp27_pw_rf1cfh=pw_rf1cfh,&_temp27_pw_rf1cfh) : &pw_rf1cfh, _a_rf1cfh.fixedflag ? (_temp28_a_rf1cfh=a_rf1cfh,&_temp28_a_rf1cfh) : &a_rf1cfh, SAR_ABS_SINC1, SAR_PSINC1,
                     SAR_ASINC1, SAR_DTYCYC_SINC1, SAR_MAXPW_SINC1, 1,
                     MAX_B1_SINC1_90, MAX_INT_B1_SQ_SINC1_90,
                     MAX_RMS_B1_SINC1_90, 90.0, _flip_rf1cfh.fixedflag ? (_temp29_flip_rf1cfh=flip_rf1cfh,&_temp29_flip_rf1cfh) : &flip_rf1cfh, 3200.0,
                     1250, PSD_CFH_ON, 0,
                     0, 0, _res_rf1cfh.fixedflag ? (_temp30_res_rf1cfh=res_rf1cfh,&_temp30_res_rf1cfh) : &res_rf1cfh, 0, _wg_rf1cfh.fixedflag ? (_temp31_wg_rf1cfh=wg_rf1cfh,&_temp31_wg_rf1cfh) : &wg_rf1cfh, 1, rfpulse);

        setuprfpulse(RF2_CFH_SLOT, _pw_rf2cfh.fixedflag ? (_temp32_pw_rf2cfh=pw_rf2cfh,&_temp32_pw_rf2cfh) : &pw_rf2cfh, _a_rf2cfh.fixedflag ? (_temp33_a_rf2cfh=a_rf2cfh,&_temp33_a_rf2cfh) : &a_rf2cfh, SAR_ABS_SINC1, SAR_PSINC1,
                     SAR_ASINC1, SAR_DTYCYC_SINC1, SAR_MAXPW_SINC1, 1,
                     MAX_B1_SINC1_90, MAX_INT_B1_SQ_SINC1_90,
                     MAX_RMS_B1_SINC1_90, 90.0, _flip_rf2cfh.fixedflag ? (_temp34_flip_rf2cfh=flip_rf2cfh,&_temp34_flip_rf2cfh) : &flip_rf2cfh, 3200.0,
                     1250, PSD_CFH_ON, 0,
                     0, 0, _res_rf2cfh.fixedflag ? (_temp35_res_rf2cfh=res_rf2cfh,&_temp35_res_rf2cfh) : &res_rf2cfh, 0, _wg_rf2cfh.fixedflag ? (_temp36_wg_rf2cfh=wg_rf2cfh,&_temp36_wg_rf2cfh) : &wg_rf2cfh, 1, rfpulse);

        setuprfpulse(RF3_CFH_SLOT, _pw_rf3cfh.fixedflag ? (_temp37_pw_rf3cfh=pw_rf3cfh,&_temp37_pw_rf3cfh) : &pw_rf3cfh, _a_rf3cfh.fixedflag ? (_temp38_a_rf3cfh=a_rf3cfh,&_temp38_a_rf3cfh) : &a_rf3cfh, SAR_ABS_SINC1, SAR_PSINC1,
                     SAR_ASINC1, SAR_DTYCYC_SINC1, SAR_MAXPW_SINC1, 1,
                     MAX_B1_SINC1_90, MAX_INT_B1_SQ_SINC1_90,
                     MAX_RMS_B1_SINC1_90, 90.0, _flip_rf3cfh.fixedflag ? (_temp39_flip_rf3cfh=flip_rf3cfh,&_temp39_flip_rf3cfh) : &flip_rf3cfh, 3200.0,
                     1250, PSD_CFH_ON, 0,
                     0, 0, _res_rf3cfh.fixedflag ? (_temp40_res_rf3cfh=res_rf3cfh,&_temp40_res_rf3cfh) : &res_rf3cfh, 0, _wg_rf3cfh.fixedflag ? (_temp41_wg_rf3cfh=wg_rf3cfh,&_temp41_wg_rf3cfh) : &wg_rf3cfh, 1, rfpulse);

        setuprfpulse(RF4_CFH_SLOT, _pw_rf4cfh.fixedflag ? (_temp42_pw_rf4cfh=pw_rf4cfh,&_temp42_pw_rf4cfh) : &pw_rf4cfh, _a_rf4cfh.fixedflag ? (_temp43_a_rf4cfh=a_rf4cfh,&_temp43_a_rf4cfh) : &a_rf4cfh, SAR_ABS_SINC1, SAR_PSINC1,
                     SAR_ASINC1, SAR_DTYCYC_SINC1, SAR_MAXPW_SINC1, 1,
                     MAX_B1_SINC1_90, MAX_INT_B1_SQ_SINC1_90,
                     MAX_RMS_B1_SINC1_90, 90.0, _flip_rf4cfh.fixedflag ? (_temp44_flip_rf4cfh=flip_rf4cfh,&_temp44_flip_rf4cfh) : &flip_rf4cfh, 3200.0,
                     1250, PSD_CFH_ON, 0,
                     0, 0, _res_rf4cfh.fixedflag ? (_temp45_res_rf4cfh=res_rf4cfh,&_temp45_res_rf4cfh) : &res_rf4cfh, 0, _wg_rf4cfh.fixedflag ? (_temp46_wg_rf4cfh=wg_rf4cfh,&_temp46_wg_rf4cfh) : &wg_rf4cfh, 1, rfpulse);

        a_rf0cfh  = _a_rf0cfh.fixedflag ?  ((void)(0.61), a_rf0cfh) : 0.61;
        a_rf1cfh  = _a_rf1cfh.fixedflag ?  ((void)(0.5), a_rf1cfh) : 0.5;
        a_rf2cfh  = _a_rf2cfh.fixedflag ?  ((void)(1.0), a_rf2cfh) : 1.0;
        a_rf3cfh  = _a_rf3cfh.fixedflag ?  ((void)(1.0), a_rf3cfh) : 1.0; 
        a_rf4cfh  = _a_rf4cfh.fixedflag ?  ((void)(1.0), a_rf4cfh) : 1.0; 

        flip_rf1cfh  = _flip_rf1cfh.fixedflag ?  ((void)(90), flip_rf1cfh) : 90;
        flip_rf2cfh  = _flip_rf2cfh.fixedflag ?  ((void)(180), flip_rf2cfh) : 180;
        flip_rf3cfh  = _flip_rf3cfh.fixedflag ?  ((void)(180), flip_rf3cfh) : 180; 
        flip_rf4cfh  = _flip_rf4cfh.fixedflag ?  ((void)(180), flip_rf4cfh) : 180; 

        cyc_rf1cfh  = _cyc_rf1cfh.fixedflag ?  ((void)(1), cyc_rf1cfh) : 1;
        cyc_rf2cfh  = _cyc_rf2cfh.fixedflag ?  ((void)(1), cyc_rf2cfh) : 1;
        cyc_rf3cfh  = _cyc_rf3cfh.fixedflag ?  ((void)(1), cyc_rf3cfh) : 1; 
        cyc_rf4cfh  = _cyc_rf4cfh.fixedflag ?  ((void)(1), cyc_rf4cfh) : 1; 
    }
    return SUCCESS;
}



/*
 *  PScvinit
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
PScvinit( void )
{
    if( (exist(opimode) == PSD_SPECTRO) || (PSD_ON == pimrsapsflg) )
    {
        fastprescan  = _fastprescan.fixedflag ?  ((void)(0), fastprescan) : 0;
    }
    else
    {
        fastprescan  = _fastprescan.fixedflag ?  ((void)(cffastprescan), fastprescan) : cffastprescan;
    }

    /* Set the modes for presscfh */
    set_presscfh_mode();
    
    /* Fix to set CFH,CFL,APS1, FTG slice location to be axial mid slice to ensure
       the presence of signal when sample position is off iso center such as wrist scout scans */
    if (opplane == PSD_3PLANE)
    {
        PSslice_num  = _PSslice_num.fixedflag ?  ((void)((int)(opaxial_slice/2)), PSslice_num) : (int)(opaxial_slice/2);
    }
    else
    {  /* Start of code moved up from PSpredownload section below by SL */
        FLOAT minloc;
        FLOAT maxloc;         /* For MRIge45995 */
        FLOAT midloc;         /* For MRIge45995 */
        FLOAT minimum;        /* For MRIge45995 */
        FLOAT loc;
        INT index;

        /* search through the scan table to find the location nearest
           isocenter. Save the location information for prescan since
           graphic sat and different imaging techniques can alter the
           content and format of the rspinfo structure
        */

        minloc = MAXFLOAT;  /* For MRIge45995 */
        maxloc = -MAXFLOAT; /* For MRIge45995 */

        /* First to find the center of the prescribed region, MRIge45995 */
        for (index=0;index<opslquant*opvquant;index++)
        {
            loc = scan_info[index].optloc + scan_info[index].optloc_shift;
            if (loc < minloc)
            {
                minloc = loc;
            }
            if (loc > maxloc)
            {
                maxloc = loc;
            }
        }
        midloc = 0.5*(minloc + maxloc);

        /* Find the slice most close to the center of the prescribed region, MRIge45995 */
        minimum = MAXFLOAT;
        for (index=0;index<opslquant*opvquant;index++)
        {
            loc = scan_info[index].optloc + scan_info[index].optloc_shift;
            if (fabs(loc-midloc) < minimum)
            {
                minimum = fabs(loc-midloc);
                PSslice_num  = _PSslice_num.fixedflag ?  ((void)(index), PSslice_num) : index;
            }
        }
    } /* End of code moved up from PSpredownload section below */

    /* Comment from /vobs/scan/MrScan/SrxControl/SrxGeos.m on setting opcoax */
    /* slightly modified */

    /* This next section determines the value of the opcoax CV  */
    /* The rules are as follows:  */
    /*   */
    /* coaxial      N   Y   Y  */
    /* offcenter    -   N   Y  */
    /* ======================  */
    /* opcoax       0   1   2  */
    /*  */
    /* The decision of NOT coaxial is determined by the following three  */
    /* conditions: (graphic rx imaging option selected) AND (oblique   */
    /* prescription) AND ( (more than one group has been prescribed) OR (Number
     * of radial slices > 1 ) ).  */
    /*  */
    /* The decision of offcenter is made based on whether or not   */
    /* all of the slices have 0 offset in their phase and frequency  */
    /* directions.  If even one is not 0, then the prescription is  */
    /* said to be offcenter.  */

    /* Use the below in the PSD Code if the HDMR2 changes for MRIhc08321
     * need to be overridden. RBA for MRIhc08321.
     */
    
    
    PS1cvinit();
    CFLcvinit();
    CFHcvinit();
    RCVNcvinit();

    /* initialize field strength and PS variables */ /* vmx 05/02/95 YO */
    PSfield_strength  = _PSfield_strength.fixedflag ?   ((void)((int)cffield), PSfield_strength) : (int)cffield;
    if(PSfield_strength <= B0_5000)
    {
        PScs_sat  = _PScs_sat.fixedflag ?  ((void)(1), PScs_sat) : 1;
        PSmt  = _PSmt.fixedflag ?  ((void)(0), PSmt) : 0;
    }
    else
    {
        if (aspir_flag || (PSD_ON == exist(opspecir)))
        {   /* turn OFF ASPIR/SPECIAL during CFH */
            PScs_sat  = _PScs_sat.fixedflag ?  ((void)(0), PScs_sat) : 0;
        } else {
            PScs_sat  = _PScs_sat.fixedflag ?  ((void)(1), PScs_sat) : 1;
        }

        PSmt  = _PSmt.fixedflag ?  ((void)(1), PSmt) : 1;
    }

    pimrs[0] = _pimrsaps1.fixedflag ? (_temp47_pimrsaps1=pimrsaps1,&_temp47_pimrsaps1) : &pimrsaps1;
    pimrs[1] = _pimrsaps2.fixedflag ? (_temp48_pimrsaps2=pimrsaps2,&_temp48_pimrsaps2) : &pimrsaps2;
    pimrs[2] = _pimrsaps3.fixedflag ? (_temp49_pimrsaps3=pimrsaps3,&_temp49_pimrsaps3) : &pimrsaps3;
    pimrs[3] = _pimrsaps4.fixedflag ? (_temp50_pimrsaps4=pimrsaps4,&_temp50_pimrsaps4) : &pimrsaps4;
    pimrs[4] = _pimrsaps5.fixedflag ? (_temp51_pimrsaps5=pimrsaps5,&_temp51_pimrsaps5) : &pimrsaps5;
    pimrs[5] = _pimrsaps6.fixedflag ? (_temp52_pimrsaps6=pimrsaps6,&_temp52_pimrsaps6) : &pimrsaps6;
    pimrs[6] = _pimrsaps7.fixedflag ? (_temp53_pimrsaps7=pimrsaps7,&_temp53_pimrsaps7) : &pimrsaps7;
    pimrs[7] = _pimrsaps8.fixedflag ? (_temp54_pimrsaps8=pimrsaps8,&_temp54_pimrsaps8) : &pimrsaps8;
    pimrs[8] = _pimrsaps9.fixedflag ? (_temp55_pimrsaps9=pimrsaps9,&_temp55_pimrsaps9) : &pimrsaps9;
    pimrs[9] = _pimrsaps10.fixedflag ? (_temp56_pimrsaps10=pimrsaps10,&_temp56_pimrsaps10) : &pimrsaps10;
    pimrs[10] = _pimrsaps11.fixedflag ? (_temp57_pimrsaps11=pimrsaps11,&_temp57_pimrsaps11) : &pimrsaps11;
    pimrs[11] = _pimrsaps12.fixedflag ? (_temp58_pimrsaps12=pimrsaps12,&_temp58_pimrsaps12) : &pimrsaps12;
    pimrs[12] = _pimrsaps13.fixedflag ? (_temp59_pimrsaps13=pimrsaps13,&_temp59_pimrsaps13) : &pimrsaps13;
    pimrs[13] = _pimrsaps14.fixedflag ? (_temp60_pimrsaps14=pimrsaps14,&_temp60_pimrsaps14) : &pimrsaps14;
    pimrs[14] = _pimrsaps15.fixedflag ? (_temp61_pimrsaps15=pimrsaps15,&_temp61_pimrsaps15) : &pimrsaps15;

    
    /* MRIhc15304: we will keep asfov as cv and fill it with the value
     * from coil. Some application (Spectro related) need to decide the
     * asfov based on the application (overriding the value decided by
     * coil). */ 
    asfov  = _asfov.fixedflag ?  ((void)(coilInfo[0].autoshimFov), asfov) : coilInfo[0].autoshimFov;

    /* 
     * Set the wait time for sethubindeximm.  A 100 ms delay is
     * sufficent to apply the settings on the driver module.  On systems
     * with an RRF receiver, a longer delay (250 ms) is needed for the
     * new receiver channel map to be loaded into the DRF. 
     */
    if( cfcoilswitchmethod & COIL_SWITCH_RSP_SETHUBINDEXIMM )
    {
        if( CFG_VAL_RECEIVER_RRF == cfreceivertype )
        {
            csw_wait_sethubindeximm   = _csw_wait_sethubindeximm.fixedflag ?  ((void)(250000), csw_wait_sethubindeximm) : 250000;
        }
        else
        {
            csw_wait_sethubindeximm   = _csw_wait_sethubindeximm.fixedflag ?  ((void)(100000), csw_wait_sethubindeximm) : 100000;
        }
    }

    return SUCCESS;
}   /* end PScvinit() */


/*
 *  FTGcvinit
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
FTGcvinit( void )
{
    a_rf1ftg     = _a_rf1ftg.fixedflag ?  ((void)(0.5), a_rf1ftg) : 0.5;
    a_rf2ftg     = _a_rf2ftg.fixedflag ?  ((void)(1.0), a_rf2ftg) : 1.0;
    a_rf3ftg     = _a_rf3ftg.fixedflag ?  ((void)(1.0), a_rf3ftg) : 1.0;
    pw_rf1ftg    = _pw_rf1ftg.fixedflag ?  ((void)((int)rfpulse[RF1_FTG_SLOT].nom_pw), pw_rf1ftg) : (int)rfpulse[RF1_FTG_SLOT].nom_pw;
    pw_rf2ftg    = _pw_rf2ftg.fixedflag ?  ((void)((int)rfpulse[RF2_FTG_SLOT].nom_pw), pw_rf2ftg) : (int)rfpulse[RF2_FTG_SLOT].nom_pw;
    pw_rf3ftg    = _pw_rf3ftg.fixedflag ?  ((void)((int)rfpulse[RF3_FTG_SLOT].nom_pw), pw_rf3ftg) : (int)rfpulse[RF3_FTG_SLOT].nom_pw;
    cyc_rf1ftg   = _cyc_rf1ftg.fixedflag ?  ((void)(1), cyc_rf1ftg) : 1;
    res_rf1ftg   = _res_rf1ftg.fixedflag ?  ((void)(800), res_rf1ftg) : 800;
    cyc_rf2ftg   = _cyc_rf2ftg.fixedflag ?  ((void)(1), cyc_rf2ftg) : 1;
    res_rf2ftg   = _res_rf2ftg.fixedflag ?  ((void)(800), res_rf2ftg) : 800;
    cyc_rf3ftg   = _cyc_rf3ftg.fixedflag ?  ((void)(1), cyc_rf3ftg) : 1;
    res_rf3ftg   = _res_rf3ftg.fixedflag ?  ((void)(800), res_rf3ftg) : 800;
    flip_rf1ftg  = _flip_rf1ftg.fixedflag ?   ((void)(90.0), flip_rf1ftg) : 90.0;
    flip_rf2ftg  = _flip_rf2ftg.fixedflag ?  ((void)(180.0), flip_rf2ftg) : 180.0;
    flip_rf3ftg  = _flip_rf3ftg.fixedflag ?  ((void)(180.0), flip_rf3ftg) : 180.0;

    return SUCCESS;
} /* end FTGcvinit() */


/*
 *  XTGcvinit
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
XTGcvinit( void )
{   
    double coil_maxb1, coil_maxb1_gauss, fermi_b1; /* HCSDM00157626 */
    a_rf1xtg     = _a_rf1xtg.fixedflag ?  ((void)(0.5), a_rf1xtg) : 0.5;
    a_rf2xtg     = _a_rf2xtg.fixedflag ?  ((void)(1.0), a_rf2xtg) : 1.0;
    pw_rf1xtg    = _pw_rf1xtg.fixedflag ?  ((void)((int)rfpulse[RF1_XTG_SLOT].nom_pw), pw_rf1xtg) : (int)rfpulse[RF1_XTG_SLOT].nom_pw;
    pw_rf2xtg    = _pw_rf2xtg.fixedflag ?  ((void)((int)rfpulse[RF2_XTG_SLOT].nom_pw), pw_rf2xtg) : (int)rfpulse[RF2_XTG_SLOT].nom_pw;
    cyc_rf1xtg   = _cyc_rf1xtg.fixedflag ?  ((void)(1), cyc_rf1xtg) : 1;
    res_rf1xtg   = _res_rf1xtg.fixedflag ?  ((void)(0), res_rf1xtg) : 0;
    cyc_rf2xtg   = _cyc_rf2xtg.fixedflag ?  ((void)(1), cyc_rf2xtg) : 1;
    res_rf2xtg   = _res_rf2xtg.fixedflag ?  ((void)(800), res_rf2xtg) : 800;
    flip_rf1xtg  = _flip_rf1xtg.fixedflag ?   ((void)(90.0), flip_rf1xtg) : 90.0;
    flip_rf2xtg  = _flip_rf2xtg.fixedflag ?  ((void)(180.0), flip_rf2xtg) : 180.0;

    a_rf3xtg  = _a_rf3xtg.fixedflag ?  ((void)(-1.0), a_rf3xtg) : -1.0; 
    a_rf4xtg  = _a_rf4xtg.fixedflag ?  ((void)(1.0), a_rf4xtg) : 1.0;
    res_rf3xtg  = _res_rf3xtg.fixedflag ?  ((void)(RES_FERMI_BLS), res_rf3xtg) : RES_FERMI_BLS;
    res_rf4xtg  = _res_rf4xtg.fixedflag ?  ((void)(res_rf3xtg), res_rf4xtg) : res_rf3xtg;
    pw_rf3xtg    = _pw_rf3xtg.fixedflag ?  ((void)(pw_bsrf), pw_rf3xtg) : pw_bsrf;
    pw_rf4xtg    = _pw_rf4xtg.fixedflag ?  ((void)(pw_rf3xtg), pw_rf4xtg) : pw_rf3xtg;
    
    flip_rf3xtg  = _flip_rf3xtg.fixedflag ?  ((void)((FA_FERMI_BLS*pw_rf3xtg)/SAR_FERMI_BLS_NOM_PW), flip_rf3xtg) : (FA_FERMI_BLS*pw_rf3xtg)/SAR_FERMI_BLS_NOM_PW;  /* scale flip to keep its maxB1 constant */
    /* 630 degree flip, 4ms pw: max B1 = 0.071 */
    flip_rf4xtg  = _flip_rf4xtg.fixedflag ?  ((void)(flip_rf3xtg), flip_rf4xtg) : flip_rf3xtg;       

    fermi_b1 = 100*FA_FERMI_BLS/NOM_FA_RFMT*SAR_MAXB1_FERMI_BLS;

    /* Find the maximum predicted B1 for the current weight and coil */
    /* HCSDM00384210 */

    if( SDL_RFDerating_entry( &coil_maxb1_gauss, cffield, opweight, txCoilInfo[getTxIndex(coilInfo[0])], (GRADIENT_COIL_E) cfgcoiltype, L_SCAN ) != SUCCESS)
    {
        epic_error(0, "Support routine %s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "SDL_RFDerating");
        return FAILURE;
    }

    coil_maxb1 = coil_maxb1_gauss/UTESLA2GAUSS;
        
    if(fermi_b1 > coil_maxb1)  /* disable XTG */ 
    {
        xtg_disabled = PSD_ON;
        rfpulse[RF1_XTG_SLOT].num = 0;  
        rfpulse[RF1_XTG_SLOT].activity = PSD_OFF;
        rfpulse[RF2_XTG_SLOT].num = 0; 
        rfpulse[RF2_XTG_SLOT].activity = PSD_OFF;    
        rfpulse[RF3_XTG_SLOT].num = 0;  
        rfpulse[RF3_XTG_SLOT].activity = PSD_OFF;
        rfpulse[RF4_XTG_SLOT].num = 0; 
        rfpulse[RF4_XTG_SLOT].activity = PSD_OFF;    
    }
    else
    {
        xtg_disabled = PSD_OFF;
        rfpulse[RF1_XTG_SLOT].num = 1;
        rfpulse[RF1_XTG_SLOT].activity = PSD_XTG_ON;
        rfpulse[RF2_XTG_SLOT].num = 1;
        rfpulse[RF2_XTG_SLOT].activity = PSD_XTG_ON;    
        rfpulse[RF3_XTG_SLOT].num = 1;
        rfpulse[RF3_XTG_SLOT].activity = PSD_XTG_ON;
        rfpulse[RF4_XTG_SLOT].num = 1;
        rfpulse[RF4_XTG_SLOT].activity = PSD_XTG_ON;    
    }
    
    xtgtr  = _xtgtr.fixedflag ?  ((void)(200000), xtgtr) : 200000;
    
    xtg_dda  = _xtg_dda.fixedflag ?  ((void)(2), xtg_dda) : 2;
    XTGacq1  = _XTGacq1.fixedflag ?  ((void)(PSD_ON), XTGacq1) : PSD_ON;
    
    return SUCCESS;
} /* end XTGcvinit() */

/*
 *  AScvinit
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
AScvinit( void )
{
    INT asplane;
    INT ascell;
    SCAN_INFO total_asscan_info[6];
    INT total_asplane = 3;

    td0as  = _td0as.fixedflag ?  ((void)(GRAD_UPDATE_TIME), td0as) : GRAD_UPDATE_TIME;

    /* Create a pseudo scan_info table for obloptimize to work with.
       The rotation matrices for the planes are what is important. */
    if(oppscvquant == 2)
    {
        total_asplane = oppscvquant * 3;
    }
    for( asplane = 0; asplane < total_asplane; asplane++ )
    {
        for( ascell = 0; ascell < 9; ascell++ )
        {
            total_asscan_info[asplane].oprot[ascell] = 0.0;
        }
    }

    /* Axial */
    total_asscan_info[0].oprot[0] = total_asscan_info[0].oprot[4] = total_asscan_info[0].oprot[8]
        = 1.0;
    /* Sagittal */
    total_asscan_info[1].oprot[2] = total_asscan_info[1].oprot[4] = total_asscan_info[1].oprot[6]
        = 1.0;
    /* Coronal */
    total_asscan_info[2].oprot[1] = total_asscan_info[2].oprot[5] = total_asscan_info[2].oprot[6]
        = 1.0;

    if (oppscvquant > 0)
    {
        for( ascell = 0; ascell < 9; ascell++ )
        {
            total_asscan_info[0].oprot[ascell] = psc_info[0].oppscrot[ascell]; /* use shim vol rot for autoshim planes */
            if (oppscvquant == 2)
            {
                total_asscan_info[3].oprot[ascell] = psc_info[1].oppscrot[ascell]; /* use shim vol rot for autoshim planes */
            }
        }

        /* Create 2nd orthogonal plane from first shim vol matrix */
        total_asscan_info[1].oprot[0] = -total_asscan_info[0].oprot[2];
        total_asscan_info[1].oprot[1] = total_asscan_info[0].oprot[1];
        total_asscan_info[1].oprot[2] = total_asscan_info[0].oprot[0];
        total_asscan_info[1].oprot[3] = -total_asscan_info[0].oprot[5];
        total_asscan_info[1].oprot[4] = total_asscan_info[0].oprot[4];
        total_asscan_info[1].oprot[5] = total_asscan_info[0].oprot[3];
        total_asscan_info[1].oprot[6] = -total_asscan_info[0].oprot[8];
        total_asscan_info[1].oprot[7] = total_asscan_info[0].oprot[7];
        total_asscan_info[1].oprot[8] = total_asscan_info[0].oprot[6];
        /* Create 3rd orthogonal plane */
        total_asscan_info[2].oprot[0] = total_asscan_info[0].oprot[0];
        total_asscan_info[2].oprot[1] = total_asscan_info[0].oprot[2];
        total_asscan_info[2].oprot[2] = -total_asscan_info[0].oprot[1];
        total_asscan_info[2].oprot[3] = total_asscan_info[0].oprot[3];
        total_asscan_info[2].oprot[4] = total_asscan_info[0].oprot[5];
        total_asscan_info[2].oprot[5] = -total_asscan_info[0].oprot[4];
        total_asscan_info[2].oprot[6] = total_asscan_info[0].oprot[6];
        total_asscan_info[2].oprot[7] = total_asscan_info[0].oprot[8];
        total_asscan_info[2].oprot[8] = -total_asscan_info[0].oprot[7];

        if (oppscvquant == 2)
        {
            /* Create 2nd orthogonal plane for 2nd shim vol */
            total_asscan_info[4].oprot[0] = -total_asscan_info[3].oprot[2];
            total_asscan_info[4].oprot[1] = total_asscan_info[3].oprot[1];
            total_asscan_info[4].oprot[2] = total_asscan_info[3].oprot[0];
            total_asscan_info[4].oprot[3] = -total_asscan_info[3].oprot[5];
            total_asscan_info[4].oprot[4] = total_asscan_info[3].oprot[4];
            total_asscan_info[4].oprot[5] = total_asscan_info[3].oprot[3];
            total_asscan_info[4].oprot[6] = -total_asscan_info[3].oprot[8];
            total_asscan_info[4].oprot[7] = total_asscan_info[3].oprot[7];
            total_asscan_info[4].oprot[8] = total_asscan_info[3].oprot[6];
            /* Create 3rd orthogonal plane */
            total_asscan_info[5].oprot[0] = total_asscan_info[3].oprot[0];
            total_asscan_info[5].oprot[1] = total_asscan_info[3].oprot[2];
            total_asscan_info[5].oprot[2] = -total_asscan_info[3].oprot[1];
            total_asscan_info[5].oprot[3] = total_asscan_info[3].oprot[3];
            total_asscan_info[5].oprot[4] = total_asscan_info[3].oprot[5];
            total_asscan_info[5].oprot[5] = -total_asscan_info[3].oprot[4];
            total_asscan_info[5].oprot[6] = total_asscan_info[3].oprot[6];
            total_asscan_info[5].oprot[7] = total_asscan_info[3].oprot[8];
            total_asscan_info[5].oprot[8] = -total_asscan_info[3].oprot[7];
        }
    }
  
    as_newgeo  = _as_newgeo.fixedflag ?  ((void)(1), as_newgeo) : 1;
    if (FAILURE==obloptimize(&asloggrd, &phygrd, total_asscan_info, total_asplane, PSD_OBL,
                             0, PSD_OBL_RESTRICT, asobl_debug, _as_newgeo.fixedflag ? (_temp62_as_newgeo=as_newgeo,&_temp62_as_newgeo) : &as_newgeo,
                             cfsrmode))
    {
        epic_error(use_ermes, "%s failed in AScvinit.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "obloptimize"); 
        return FAILURE;
    }

    /* derate SR for quiet PSC */ 
    sr_derate(&asloggrd, PSassr_derate_factor, PSasamp_derate_factor);

    /* X Killer CVs */
    if (FAILURE==amppwgrad(asx_killer_area, asloggrd.tx_xz, 0.0, 0.0, asloggrd.xrt,
                           MIN_PLATEAU_TIME, _a_gxkas.fixedflag ? (_temp63_a_gxkas=a_gxkas,&_temp63_a_gxkas) : &a_gxkas, _pw_gxkasa.fixedflag ? (_temp64_pw_gxkasa=pw_gxkasa,&_temp64_pw_gxkasa) : &pw_gxkasa,
                           _pw_gxkas.fixedflag ? (_temp65_pw_gxkas=pw_gxkas,&_temp65_pw_gxkas) : &pw_gxkas, _pw_gxkasd.fixedflag ? (_temp66_pw_gxkasd=pw_gxkasd,&_temp66_pw_gxkasd) : &pw_gxkasd ))
    {
        epic_error(use_ermes, "%s failed in AScvinit.",
                   EM_PSD_SUPPORT_FAILURE,EE_ARGS(1),
                   STRING_ARG,"amppwgrad:gxkas"); 
        return FAILURE;
    }

    /* Z Killer CVs */
    if (FAILURE==amppwgrad(asz_killer_area, asloggrd.tz_xz, 0.0, 0.0, asloggrd.zrt,
                           MIN_PLATEAU_TIME, _a_gzkas.fixedflag ? (_temp67_a_gzkas=a_gzkas,&_temp67_a_gzkas) : &a_gzkas, _pw_gzkasa.fixedflag ? (_temp68_pw_gzkasa=pw_gzkasa,&_temp68_pw_gzkasa) : &pw_gzkasa,
                           _pw_gzkas.fixedflag ? (_temp69_pw_gzkas=pw_gzkas,&_temp69_pw_gzkas) : &pw_gzkas, _pw_gzkasd.fixedflag ? (_temp70_pw_gzkasd=pw_gzkasd,&_temp70_pw_gzkasd) : &pw_gzkasd ))
    {
        epic_error(use_ermes, "%s failed in AScvinit.",
                   EM_PSD_SUPPORT_FAILURE,EE_ARGS(1),
                   STRING_ARG,"amppwgrad:gzkas"); 
        return FAILURE;
    }

    /* rf1 cvs  */
    a_rf1as  = _a_rf1as.fixedflag ?  ((void)(1.0), a_rf1as) : 1.0;
    pw_rf1as  = _pw_rf1as.fixedflag ?  ((void)(rfpulse[RF1_AUTOSHIM].nom_pw), pw_rf1as) : rfpulse[RF1_AUTOSHIM].nom_pw;
    gscale_rf1as  = _gscale_rf1as.fixedflag ?  ((void)(.90909), gscale_rf1as) : .90909;
    cyc_rf1as  = _cyc_rf1as.fixedflag ?  ((void)(1), cyc_rf1as) : 1;
    res_rf1as  = _res_rf1as.fixedflag ?  ((void)(0), res_rf1as) : 0; /* initialized to zero for system safety check in cveval */

    /* gzrf1 cvs */
    pw_gzrf1as  = _pw_gzrf1as.fixedflag ?  ((void)(pw_rf1as), pw_gzrf1as) : pw_rf1as;
    flip_rf1as  = _flip_rf1as.fixedflag ?  ((void)(asflip), flip_rf1as) : asflip;

    /*******************/
    /* Starting point  */
    /*******************/
    tleadas   = _tleadas.fixedflag ?    ((void)(RUP_GRD(24)), tleadas) : RUP_GRD(24);
    bw_rf1as  = _bw_rf1as.fixedflag ?      ((void)((int)(4*cyc_rf1as/((float)pw_rf1as/(float)1000000))), bw_rf1as) : (int)(4*cyc_rf1as/((float)pw_rf1as/(float)1000000));
    t_exaas   = _t_exaas.fixedflag ?     ((void)(pw_gzrf1asa+pw_rf1as/2), t_exaas) : pw_gzrf1asa+pw_rf1as/2;

    return SUCCESS;
} /* end AScvinit() */


/*
 *  RScvinit
 *  Description:
 *  CV init for RFShim 
 *  
 *  Type: Public Function
 *  
 */
STATUS
RScvinit( void )
{
    INT index;

    if(exist(opdrivemode) == 3)
    {
        B1Cal_mode  = _B1Cal_mode.fixedflag ?  ((void)(PSD_ON), B1Cal_mode) : PSD_ON;
    }
    else
    {
        B1Cal_mode  = _B1Cal_mode.fixedflag ?  ((void)(PSD_OFF), B1Cal_mode) : PSD_OFF;
    }

    flip_rfbrs  = _flip_rfbrs.fixedflag ?  ((void)(180), flip_rfbrs) : 180;  /* BLS RF pulse */
    flip_rf1rs  = _flip_rf1rs.fixedflag ?  ((void)(10.0), flip_rf1rs) : 10.0;

    /* BLS RF Pulse */
    rfpulse[RFB_RFSHIM_SLOT].abswidth = 0.8018;
    rfpulse[RFB_RFSHIM_SLOT].effwidth = 0.6755;
    rfpulse[RFB_RFSHIM_SLOT].area = 0.8018;
    rfpulse[RFB_RFSHIM_SLOT].dtycyc = 1.0;
    rfpulse[RFB_RFSHIM_SLOT].maxpw = 1.0;
    rfpulse[RFB_RFSHIM_SLOT].max_b1 = 0.036615;
    rfpulse[RFB_RFSHIM_SLOT].max_int_b1_sq = 0.00181119;
    rfpulse[RFB_RFSHIM_SLOT].max_rms_b1 = 0.0300931;
    rfpulse[RFB_RFSHIM_SLOT].nom_fa = 90.0;
    rfpulse[RFB_RFSHIM_SLOT].act_fa = _flip_rfbrs.fixedflag ? (_temp71_flip_rfbrs=flip_rfbrs,&_temp71_flip_rfbrs) : &flip_rfbrs;
    rfpulse[RFB_RFSHIM_SLOT].nom_pw = 2000;
    rfpulse[RFB_RFSHIM_SLOT].num = 1;

    pw_rfbrs  = _pw_rfbrs.fixedflag ?  ((void)(2000), pw_rfbrs) : 2000;
    pw_thetarfbrs  = _pw_thetarfbrs.fixedflag ?  ((void)(pw_rfbrs), pw_thetarfbrs) : pw_rfbrs;
    res_rfbrs  = _res_rfbrs.fixedflag ?  ((void)(1000), res_rfbrs) : 1000;
    res_thetarfbrs  = _res_thetarfbrs.fixedflag ?  ((void)(res_rfbrs), res_thetarfbrs) : res_rfbrs;

    /* B1 Map rf1 */
    gscale_rf1rs  = _gscale_rf1rs.fixedflag ?  ((void)(1.0), gscale_rf1rs) : 1.0;
    a_rf1rs  = _a_rf1rs.fixedflag ?  ((void)(1.0), a_rf1rs) : 1.0;

    switch (rf1rs_type)
    {
        case B1RF1_SINC:
            pw_rf1rs  = _pw_rf1rs.fixedflag ?  ((void)(3200), pw_rf1rs) : 3200;
            res_rf1rs  = _res_rf1rs.fixedflag ?  ((void)(pw_rf1rs/RF_UPDATE_TIME), res_rf1rs) : pw_rf1rs/RF_UPDATE_TIME;
            cyc_rf1rs  = _cyc_rf1rs.fixedflag ?  ((void)(1), cyc_rf1rs) : 1;
            a_rf1rs  = _a_rf1rs.fixedflag ?  ((void)(1.0), a_rf1rs) : 1.0;
            rs_off90  = _rs_off90.fixedflag ?  ((void)(PSoff90), rs_off90) : PSoff90;
            rfpulse[RF1_RFSHIM_SLOT].abswidth = SAR_ABS_SINC1;
            rfpulse[RF1_RFSHIM_SLOT].effwidth = SAR_PSINC1;
            rfpulse[RF1_RFSHIM_SLOT].area = SAR_ASINC1;
            rfpulse[RF1_RFSHIM_SLOT].dtycyc = SAR_DTYCYC_SINC1;
            rfpulse[RF1_RFSHIM_SLOT].maxpw = SAR_MAXPW_SINC1;
            rfpulse[RF1_RFSHIM_SLOT].max_b1 = MAX_B1_SINC1_90;
            rfpulse[RF1_RFSHIM_SLOT].max_int_b1_sq = MAX_INT_B1_SQ_SINC1_90;
            rfpulse[RF1_RFSHIM_SLOT].max_rms_b1 = MAX_RMS_B1_SINC1_90;
            rfpulse[RF1_RFSHIM_SLOT].nom_pw   = 3200;
            rfpulse[RF1_RFSHIM_SLOT].nom_bw = NOM_BW_SINC1_90;
            rfpulse[RF1_RFSHIM_SLOT].nom_fa   = 90;
            rfpulse[RF1_RFSHIM_SLOT].num = 1;
            break;

        case B1RF1_TBW:
        default:
            pw_rf1rs  = _pw_rf1rs.fixedflag ?  ((void)(1200), pw_rf1rs) : 1200;
            res_rf1rs  = _res_rf1rs.fixedflag ?  ((void)(RES_TBW6), res_rf1rs) : RES_TBW6;
            a_rf1rs  = _a_rf1rs.fixedflag ?  ((void)(1.0), a_rf1rs) : 1.0;
            rfpulse[RF1_RFSHIM_SLOT].abswidth = SAR_ABS_TBW6;
            rfpulse[RF1_RFSHIM_SLOT].area     = SAR_A_TBW6;
            rfpulse[RF1_RFSHIM_SLOT].effwidth = SAR_TBW6_EFF_WIDTH;
            rfpulse[RF1_RFSHIM_SLOT].dtycyc   = SAR_DTYCYC_TBW6;
            rfpulse[RF1_RFSHIM_SLOT].maxpw    = SAR_MAXPW_TBW6;
            rfpulse[RF1_RFSHIM_SLOT].max_b1   = MAX_B1_TBW6;
            rfpulse[RF1_RFSHIM_SLOT].max_int_b1_sq = MAX_INT_B1_SQ_TBW6;
            rfpulse[RF1_RFSHIM_SLOT].max_rms_b1 = MAX_RMS_B1_TBW6;
            rfpulse[RF1_RFSHIM_SLOT].nom_pw   = NOM_PW_TBW6;
            rfpulse[RF1_RFSHIM_SLOT].nom_bw   = NOM_BW_TBW6;
            rfpulse[RF1_RFSHIM_SLOT].nom_fa   = NOM_FA_TBW6;
            rfpulse[RF1_RFSHIM_SLOT].isodelay = NOM_PW_TBW6/2;
            rfpulse[RF1_RFSHIM_SLOT].num = 1;
            break;
    }

    /* Only support single slice RF Shim now */
    if ( PSD_ON == rsaxial_flag )
    {
        for( index = 0; index < 9; index++)
        {
            rsscan_info[0].oprot[index] = 0.0;
        }

        if ( (isCategoryMatchForAnatomy(exist(opanatomy), ATTRIBUTE_CATEGORY_CHEST) && strstr(PSattribute_codeMeaning, "Breast"))
             || isCategoryMatchForAnatomy(exist(opanatomy), ATTRIBUTE_CATEGORY_HEAD) ) 
        {
            /* Axial plane, Freq A/P for breast or Head Anatomy */
            rsscan_info[0].oprot[1] = rsscan_info[0].oprot[3] = rsscan_info[0].oprot[8] = 1.0;
        }
        else   /* Freq R/L */
        {
            rsscan_info[0].oprot[0] = rsscan_info[0].oprot[4] = rsscan_info[0].oprot[8] = 1.0;
        }
    }
    else
    {
        for (index = 0; index < 9; index++)
        {
            rsscan_info[0].oprot[index] = scan_info[PSslice_num].oprot[index]; /* use Rxed slice rot */ 
        }
    }

    ps1_newgeo  = _ps1_newgeo.fixedflag ?  ((void)(1), ps1_newgeo) : 1;
    if (obloptimize(&rsloggrd, &phygrd, rsscan_info, 1, PSD_OBL,
                    0, obl_method, ps1obl_debug, _ps1_newgeo.fixedflag ? (_temp72_ps1_newgeo=ps1_newgeo,&_temp72_ps1_newgeo) : &ps1_newgeo,
                    cfsrmode) == FAILURE)
    {
        epic_error(use_ermes, "%s failed in RScvinit.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "obloptimize"); 
        return FAILURE;
    }

    /* derate SR for silent PSC */ 
    sr_derate(&rsloggrd, PSsr_derate_factor, PSamp_derate_factor);

    /* gzrf1 cvs */
    pw_gzrf1rs  = _pw_gzrf1rs.fixedflag ?  ((void)(pw_rf1rs), pw_gzrf1rs) : pw_rf1rs;

    /*******************/
    /* Starting point  */
    /*******************/
    tleadrs   = _tleadrs.fixedflag ?    ((void)(RUP_GRD(24)), tleadrs) : RUP_GRD(24);

    return SUCCESS;
}  /* end RScvinit */

/* 
 *  DTGcvinit
 *  Description:
 *  CV init for Dynamic TG 
 *  
 *  Type: Public Function
 *  
 */
STATUS
DTGcvinit( void )
{

    flip_rfbdtg  = _flip_rfbdtg.fixedflag ?  ((void)(180.0), flip_rfbdtg) : 180.0;
    flip_rf1dtg  = _flip_rf1dtg.fixedflag ?  ((void)(10.0), flip_rf1dtg) : 10.0;

    /* BLS RF Pulse */
    rfpulse[RFB_DYNTG_SLOT].abswidth = 0.8018;
    rfpulse[RFB_DYNTG_SLOT].effwidth = 0.6755;
    rfpulse[RFB_DYNTG_SLOT].area = 0.8018;
    rfpulse[RFB_DYNTG_SLOT].dtycyc = 1.0;
    rfpulse[RFB_DYNTG_SLOT].maxpw = 1.0;
    rfpulse[RFB_DYNTG_SLOT].max_b1 = 0.036615;
    rfpulse[RFB_DYNTG_SLOT].max_int_b1_sq = 0.00181119;
    rfpulse[RFB_DYNTG_SLOT].max_rms_b1 = 0.0300931;
    rfpulse[RFB_DYNTG_SLOT].nom_fa = 90.0;
    rfpulse[RFB_DYNTG_SLOT].act_fa = _flip_rfbdtg.fixedflag ? (_temp73_flip_rfbdtg=flip_rfbdtg,&_temp73_flip_rfbdtg) : &flip_rfbdtg;
    rfpulse[RFB_DYNTG_SLOT].nom_pw = 2000;
    rfpulse[RFB_DYNTG_SLOT].num = 1;


    res_rfbdtg  = _res_rfbdtg.fixedflag ?  ((void)(1000), res_rfbdtg) : 1000;
    res_thetarfbdtg  = _res_thetarfbdtg.fixedflag ?  ((void)(res_rfbdtg), res_thetarfbdtg) : res_rfbdtg;
    pw_rfbdtg  = _pw_rfbdtg.fixedflag ?  ((void)(2000), pw_rfbdtg) : 2000;
    pw_thetarfbdtg  = _pw_thetarfbdtg.fixedflag ?  ((void)(pw_rfbdtg), pw_thetarfbdtg) : pw_rfbdtg;

    /* B1 Map rf1 */
    a_rf1dtg  = _a_rf1dtg.fixedflag ?  ((void)(1.0), a_rf1dtg) : 1.0;
    gscale_rf1dtg  = _gscale_rf1dtg.fixedflag ?  ((void)(1.0), gscale_rf1dtg) : 1.0;
    switch (rf1dtg_type)
    {
        case B1RF1_SINC:
            pw_rf1dtg  = _pw_rf1dtg.fixedflag ?  ((void)(3200), pw_rf1dtg) : 3200;
            res_rf1dtg  = _res_rf1dtg.fixedflag ?  ((void)(pw_rf1dtg/RF_UPDATE_TIME), res_rf1dtg) : pw_rf1dtg/RF_UPDATE_TIME;
            cyc_rf1dtg  = _cyc_rf1dtg.fixedflag ?  ((void)(1), cyc_rf1dtg) : 1;
            dtg_off90  = _dtg_off90.fixedflag ?  ((void)(PSoff90), dtg_off90) : PSoff90;
            rfpulse[RF1_DYNTG_SLOT].abswidth = SAR_ABS_SINC1;
            rfpulse[RF1_DYNTG_SLOT].effwidth = SAR_PSINC1;
            rfpulse[RF1_DYNTG_SLOT].area = SAR_ASINC1;
            rfpulse[RF1_DYNTG_SLOT].dtycyc = SAR_DTYCYC_SINC1;
            rfpulse[RF1_DYNTG_SLOT].maxpw = SAR_MAXPW_SINC1;
            rfpulse[RF1_DYNTG_SLOT].max_b1 = MAX_B1_SINC1_90;
            rfpulse[RF1_DYNTG_SLOT].max_int_b1_sq = MAX_INT_B1_SQ_SINC1_90;
            rfpulse[RF1_DYNTG_SLOT].max_rms_b1 = MAX_RMS_B1_SINC1_90;
            rfpulse[RF1_DYNTG_SLOT].nom_pw   = 3200;
            rfpulse[RF1_DYNTG_SLOT].nom_bw = NOM_BW_SINC1_90;
            rfpulse[RF1_DYNTG_SLOT].nom_fa   = 90;
            rfpulse[RF1_DYNTG_SLOT].num = 1;
            break;

        case B1RF1_TBW:
        default:
            pw_rf1dtg  = _pw_rf1dtg.fixedflag ?  ((void)(1200), pw_rf1dtg) : 1200;
            res_rf1dtg  = _res_rf1dtg.fixedflag ?  ((void)(RES_TBW6), res_rf1dtg) : RES_TBW6;
            rfpulse[RF1_DYNTG_SLOT].abswidth = SAR_ABS_TBW6;
            rfpulse[RF1_DYNTG_SLOT].area     = SAR_A_TBW6;
            rfpulse[RF1_DYNTG_SLOT].effwidth = SAR_TBW6_EFF_WIDTH;
            rfpulse[RF1_DYNTG_SLOT].dtycyc   = SAR_DTYCYC_TBW6;
            rfpulse[RF1_DYNTG_SLOT].maxpw    = SAR_MAXPW_TBW6;
            rfpulse[RF1_DYNTG_SLOT].max_b1   = MAX_B1_TBW6;
            rfpulse[RF1_DYNTG_SLOT].max_int_b1_sq = MAX_INT_B1_SQ_TBW6;
            rfpulse[RF1_DYNTG_SLOT].max_rms_b1 = MAX_RMS_B1_TBW6;
            rfpulse[RF1_DYNTG_SLOT].nom_pw   = NOM_PW_TBW6;
            rfpulse[RF1_DYNTG_SLOT].nom_bw   = NOM_BW_TBW6;
            rfpulse[RF1_DYNTG_SLOT].nom_fa   = NOM_FA_TBW6;
            rfpulse[RF1_DYNTG_SLOT].isodelay = NOM_PW_TBW6/2;
            rfpulse[RF1_DYNTG_SLOT].num = 1;
            break;
    }


    /* gzrf1 cvs */
    pw_gzrf1dtg  = _pw_gzrf1dtg.fixedflag ?  ((void)(pw_rf1dtg), pw_gzrf1dtg) : pw_rf1dtg;

    /*******************/
    /* Starting point  */
    /*******************/
    tleaddtg   = _tleaddtg.fixedflag ?    ((void)(RUP_GRD(24)), tleaddtg) : RUP_GRD(24);

    return SUCCESS;
}  /* end DTGcvinit */



/*
 *  ExtCalcvinit
 *  
 *  Type: Public Function
 *  
 *  Description:  cvinit section
 *  for ExtCal entry point
 *  
 */
STATUS
ExtCalcvinit( void )
{
    cal_xres  = _cal_xres.fixedflag ?  ((void)(32), cal_xres) : 32;
    cal_yres  = _cal_yres.fixedflag ?  ((void)(32), cal_yres) : 32;
    cal_nex  = _cal_nex.fixedflag ?  ((void)(2), cal_nex) : 2;
    cal_pass  = _cal_pass.fixedflag ?  ((void)(2), cal_pass) : 2;

    echo1bwcal  = _echo1bwcal.fixedflag ?  ((void)(62.5), echo1bwcal) : 62.5;  /* Rec Bandwidth fixed to +/- 62.5kHz */

    ps1_newgeo  = _ps1_newgeo.fixedflag ?  ((void)(1), ps1_newgeo) : 1;
    
    /* use original_phygrd to avoid ART derating; use phygrd to apply derating */
    original_pgrd = getOrigphygrd();
    if (((cffield == B0_30000) || ((cffield == B0_15000)))&& (opsilentmr || opsilent))
    {
        if (obloptimize(&calloggrd, &phygrd, calscan_info, cal_slq, PSD_AXIAL,
                    0, obl_method, ps1obl_debug, _ps1_newgeo.fixedflag ? (_temp74_ps1_newgeo=ps1_newgeo,&_temp74_ps1_newgeo) : &ps1_newgeo,
                    cfsrmode) == FAILURE)
        {
            epic_error(use_ermes, "%s failed in RScvinit.", EM_PSD_SUPPORT_FAILURE,
                       EE_ARGS(1), STRING_ARG, "obloptimize");
            return FAILURE;
        }
    }
    else
    {
        if (obloptimize(&calloggrd, &original_pgrd, calscan_info, cal_slq, PSD_AXIAL,
                        0, obl_method, ps1obl_debug, _ps1_newgeo.fixedflag ? (_temp75_ps1_newgeo=ps1_newgeo,&_temp75_ps1_newgeo) : &ps1_newgeo,
                        cfsrmode) == FAILURE)
        {
            epic_error(use_ermes, "%s failed in RScvinit.", EM_PSD_SUPPORT_FAILURE,
                       EE_ARGS(1), STRING_ARG, "obloptimize");
            return FAILURE;
        }
    }
    if (((cffield == B0_30000) || ((cffield == B0_15000)))&& (opsilentmr || opsilent))
    {
        cal_sr_derate  = _cal_sr_derate.fixedflag ?  ((void)(2.0), cal_sr_derate) : 2.0;
        cal_slewrate  = _cal_slewrate.fixedflag ?  ((void)(phygrd.zfs*10000.0/(cal_sr_derate*phygrd.zrt)), cal_slewrate) : phygrd.zfs*10000.0/(cal_sr_derate*phygrd.zrt);
        cal_slewrate  = _cal_slewrate.fixedflag ?    ((void)(FMax(2,10.0,cal_slewrate)), cal_slewrate) : FMax(2,10.0,cal_slewrate);  /* limited slewrate to 10 mT/m/ms and above */
        if(opsilentmr && (cal_slewrate > 10.0))
        {
            cal_slewrate  = _cal_slewrate.fixedflag ?  ((void)(10.0), cal_slewrate) : 10.0;  /* limited slewrate to 10 mT/m/ms for silenz */
        }
    }
    else
    {
        cal_sr_derate  = _cal_sr_derate.fixedflag ?  ((void)(1.0), cal_sr_derate) : 1.0;
        cal_slewrate  = _cal_slewrate.fixedflag ?  ((void)(original_pgrd.zfs*10000.0/(cal_sr_derate*original_pgrd.zrt)), cal_slewrate) : original_pgrd.zfs*10000.0/(cal_sr_derate*original_pgrd.zrt);
    }

    /* initialize pulse */
    a_rf1cal  = _a_rf1cal.fixedflag ?  ((void)(1.0), a_rf1cal) : 1.0;
    flip_rf1cal  = _flip_rf1cal.fixedflag ?  ((void)(1.0), flip_rf1cal) : 1.0;
    res_rf1cal  = _res_rf1cal.fixedflag ?  ((void)(150), res_rf1cal) : 150;
    pw_rf1cal  = _pw_rf1cal.fixedflag ?    ((void)(300), pw_rf1cal) : 300;

    pw_gzrf1cal  = _pw_gzrf1cal.fixedflag ?  ((void)(pw_rf1cal), pw_gzrf1cal) : pw_rf1cal;

    tleadcal  = _tleadcal.fixedflag ?    ((void)(RUP_GRD(24)), tleadcal) : RUP_GRD(24);

    return SUCCESS;
}

/*
 *  AutoCoilcvinit
 *
 *  Type: Public Function
 *
 *  Description:  cvinit section
 *  for Auto Coil entry point
 *
 */
STATUS
AutoCoilcvinit( void )
{
    float coil_sr_derate = 1.0;

    coil_nex  = _coil_nex.fixedflag ?  ((void)(2), coil_nex) : 2;
    coil_pass  = _coil_pass.fixedflag ?  ((void)(1), coil_pass) : 1;

    echo1bwcoil  = _echo1bwcoil.fixedflag ?  ((void)(62.5), echo1bwcoil) : 62.5;  /* Rec Bandwidth fixed to +/- 62.5kHz */

    ps1_newgeo  = _ps1_newgeo.fixedflag ?  ((void)(1), ps1_newgeo) : 1;

    if (obloptimize(&coilloggrd, &phygrd, coilscan_info, coil_slq, PSD_AXIAL,
                    0, obl_method, ps1obl_debug, _ps1_newgeo.fixedflag ? (_temp76_ps1_newgeo=ps1_newgeo,&_temp76_ps1_newgeo) : &ps1_newgeo,
                    cfsrmode) == FAILURE)
    {
        epic_error(use_ermes, "%s failed in RScvinit.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "obloptimize");
        return FAILURE;
    }

    if(opsilentmr)
    {
        coil_sr_derate = 40.0;
        coil_slewrate  = _coil_slewrate.fixedflag ?  ((void)(phygrd.zfs*10000.0/(coil_sr_derate*phygrd.zrt)), coil_slewrate) : phygrd.zfs*10000.0/(coil_sr_derate*phygrd.zrt);
        coil_slewrate  = _coil_slewrate.fixedflag ?    ((void)(FMax(2,3.0,coil_slewrate)), coil_slewrate) : FMax(2,3.0,coil_slewrate);  /* limited slewrate to 3 mT/m/ms and above */
    }
    else if(((cffield == B0_30000) || ((cffield == B0_15000))) && opsilent)
    {
        coil_sr_derate = 2.0;
        coil_slewrate  = _coil_slewrate.fixedflag ?  ((void)(phygrd.zfs*10000.0/(coil_sr_derate*phygrd.zrt)), coil_slewrate) : phygrd.zfs*10000.0/(coil_sr_derate*phygrd.zrt);
        coil_slewrate  = _coil_slewrate.fixedflag ?    ((void)(FMax(2,10.0,coil_slewrate)), coil_slewrate) : FMax(2,10.0,coil_slewrate);  /* limited slewrate to 10 mT/m/ms and above */
    }
    else
    {
        coil_sr_derate = 1.0;
        coil_slewrate  = _coil_slewrate.fixedflag ?  ((void)(phygrd.zfs*10000.0/(coil_sr_derate*phygrd.zrt)), coil_slewrate) : phygrd.zfs*10000.0/(coil_sr_derate*phygrd.zrt);
    }

    /* initialize pulse */
    a_rf1coil  = _a_rf1coil.fixedflag ?  ((void)(1.0), a_rf1coil) : 1.0;
    flip_rf1coil  = _flip_rf1coil.fixedflag ?  ((void)(1.0), flip_rf1coil) : 1.0;
    res_rf1coil  = _res_rf1coil.fixedflag ?  ((void)(150), res_rf1coil) : 150;
    pw_rf1coil  = _pw_rf1coil.fixedflag ?    ((void)(300), pw_rf1coil) : 300;

    pw_gzrf1coil  = _pw_gzrf1coil.fixedflag ?  ((void)(pw_rf1coil), pw_gzrf1coil) : pw_rf1coil;

    tleadcoil  = _tleadcoil.fixedflag ?    ((void)(RUP_GRD(24)), tleadcoil) : RUP_GRD(24);

    return SUCCESS;
}


/*
 *  PS1cveval
 *  
 *  Type: Private Function
 *  
 *  Description:
 *  
 */
STATUS
PS1cveval( FLOAT *opthickPS )
{
    LONG bw_rf1mps1, bw_rf2mps1;    /* band widths of rf pulses */
    FLOAT area_pulse;
    FLOAT area_readrampmps1;
    FLOAT area_gxwmps1;
    FLOAT av_temp_float1 = 0;
    INT ps1_xrt;
    FLOAT ps1_tx;
    FLOAT ps1_tx_xz;
    FLOAT ps1_tz_xz;

    /* check for breast L/R coil */
    if( isCategoryMatchForAnatomy(exist(opanatomy), ATTRIBUTE_CATEGORY_CHEST) && strstr(PSattribute_codeMeaning, "Breast") )
    {
        ps1_rxcoil  = _ps1_rxcoil.fixedflag ?  ((void)(PSD_ON), ps1_rxcoil) : PSD_ON;  /* Rxed rec coil for TG */
    }
    else
    {
        ps1_rxcoil  = _ps1_rxcoil.fixedflag ?  ((void)(PSD_OFF), ps1_rxcoil) : PSD_OFF;
    }

    /* begin aps1_mod changes (GE) */
    if ( (getAps1Mod() > 0) && (PSD_ON == ps1_rxcoil) )
    {
        mpsfov  = _mpsfov.fixedflag ?  ((void)(getAps1ModFov()), mpsfov) : getAps1ModFov();
    }
    else
    {
        mpsfov  = _mpsfov.fixedflag ?  ((void)(cfsystemmaxfov), mpsfov) : cfsystemmaxfov;
    }

    if(PSD_ON == local_tg)
    {
        mpsfov  = _mpsfov.fixedflag ?  ((void)(TGopslthickx), mpsfov) : TGopslthickx;
    }

    ps1_xrt = (TGspf ? ps1loggrd.yrt : ps1loggrd.xrt);
    ps1_tx = (TGspf ? ps1loggrd.ty : ps1loggrd.tx);
    ps1_tx_xz = (TGspf ? ps1loggrd.ty_yz : ps1loggrd.tx_xz);
    ps1_tz_xz = (TGspf ? ps1loggrd.tz_yz : ps1loggrd.tz_xz);

    /* Z slice select for 90 pulse */
    bw_rf1mps1 = (LONG)(rfpulse[RF1_APS1_SLOT].nom_bw*rfpulse[RF1_APS1_SLOT].nom_pw/(float)pw_rf1mps1);

    if (FAILURE== minslicethick(&av_temp_float1, bw_rf1mps1, ps1loggrd.tz, gscale_rf1mps1, TYPDEF))
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "minslicethick");
        return FAILURE;
    }

    av_temp_float1 = ceil(av_temp_float1*10.0)/10.0;
    if (av_temp_float1 > *opthickPS)
    {
        *opthickPS = av_temp_float1;
    }

    if (0 == getAps1Mod()) {
        cvoverride(thickPS_mod, *opthickPS, PSD_FIX_ON, PSD_EXIST_ON);
    } else {
        float fov = FMax(2, getAps1ModSlThick(), av_temp_float1);
        cvoverride(thickPS_mod, fov, PSD_FIX_ON, PSD_EXIST_ON);
    }

    if(PSD_ON == local_tg)
    {
        pw_gyrf1mps1  = _pw_gyrf1mps1.fixedflag ?  ((void)(pw_rf1mps1), pw_gyrf1mps1) : pw_rf1mps1;
        if(av_temp_float1 > TGopslthicky)
        {
            TGopslthicky  = _TGopslthicky.fixedflag ?  ((void)(av_temp_float1), TGopslthicky) : av_temp_float1;
        }

        if (FAILURE==ampslice(_a_gyrf1mps1.fixedflag ? (_temp77_a_gyrf1mps1=a_gyrf1mps1,&_temp77_a_gyrf1mps1) : &a_gyrf1mps1, bw_rf1mps1,TGopslthicky,gscale_rf1mps1,TYPDEF))
        {
            epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                       EE_ARGS(1), STRING_ARG, "ampslice for gyrf1mps1.");
            return FAILURE;
        }

        /* slice selection ramp */
        if (optramp(_pw_gyrf1mps1a.fixedflag ? (_temp78_pw_gyrf1mps1a=pw_gyrf1mps1a,&_temp78_pw_gyrf1mps1a) : &pw_gyrf1mps1a, a_gyrf1mps1, ps1loggrd.ty, ps1loggrd.yrt,
                    TYPDEF)==FAILURE) /* vmx 5/9/95 YI */
        {
            epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                       EE_ARGS(1), STRING_ARG, "optramp for gyrf1mps1a.");
            return FAILURE;
        }
        pw_gyrf1mps1d  = _pw_gyrf1mps1d.fixedflag ?  ((void)(pw_gyrf1mps1a), pw_gyrf1mps1d) : pw_gyrf1mps1a;

        area_pulse = a_gyrf1mps1*(pw_gyrf1mps1/2 + PSoff90 + pw_gyrf1mps1d/2);
        if (amppwgz1(_a_gy1mps1.fixedflag ? (_temp79_a_gy1mps1=a_gy1mps1,&_temp79_a_gy1mps1) : &a_gy1mps1,_pw_gy1mps1.fixedflag ? (_temp80_pw_gy1mps1=pw_gy1mps1,&_temp80_pw_gy1mps1) : &pw_gy1mps1,_pw_gy1mps1a.fixedflag ? (_temp81_pw_gy1mps1a=pw_gy1mps1a,&_temp81_pw_gy1mps1a) : &pw_gy1mps1a,_pw_gy1mps1d.fixedflag ? (_temp82_pw_gy1mps1d=pw_gy1mps1d,&_temp82_pw_gy1mps1d) : &pw_gy1mps1d,area_pulse,
                     (int)(1000000),MIN_PLATEAU_TIME,ps1loggrd.zrt,ps1_tz_xz) == FAILURE)
        {
            epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                       EE_ARGS(1), STRING_ARG, "amppwgz1 for gz1mps1.");
            return FAILURE;
        }

        if(av_temp_float1 > TGopslthick)
        {
            TGopslthick  = _TGopslthick.fixedflag ?  ((void)(av_temp_float1), TGopslthick) : av_temp_float1;
        }

        thickPS_mod  = _thickPS_mod.fixedflag ?  ((void)(TGopslthick), thickPS_mod) : TGopslthick;
    }
    else
    {
        pw_gzrf1mps1  = _pw_gzrf1mps1.fixedflag ?  ((void)(pw_rf1mps1), pw_gzrf1mps1) : pw_rf1mps1;
        if (FAILURE==ampslice(_a_gzrf1mps1.fixedflag ? (_temp83_a_gzrf1mps1=a_gzrf1mps1,&_temp83_a_gzrf1mps1) : &a_gzrf1mps1, bw_rf1mps1,thickPS_mod,gscale_rf1mps1,TYPDEF))
        {
            epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                       EE_ARGS(1), STRING_ARG, "ampslice for gzrf1mps1.");
            return FAILURE;
        }
        /* end aps1_mod changes (GE) */

        /* slice selection ramp */
        if (optramp(_pw_gzrf1mps1a.fixedflag ? (_temp84_pw_gzrf1mps1a=pw_gzrf1mps1a,&_temp84_pw_gzrf1mps1a) : &pw_gzrf1mps1a, a_gzrf1mps1, ps1loggrd.tz, ps1loggrd.zrt,
                    TYPDEF)==FAILURE) /* vmx 5/9/95 YI */ 
        {
            epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                       EE_ARGS(1), STRING_ARG, "optramp for gzrf1mps1a.");
            return FAILURE;
        }
        pw_gzrf1mps1d  = _pw_gzrf1mps1d.fixedflag ?  ((void)(pw_gzrf1mps1a), pw_gzrf1mps1d) : pw_gzrf1mps1a;

        /* Z gradient refocus */
        /* available time not calculated, defaulted to 10ms */
        area_pulse = a_gzrf1mps1*(pw_gzrf1mps1/2 + PSoff90 + pw_gzrf1mps1d/2);
        if (amppwgz1(_a_gz1mps1.fixedflag ? (_temp85_a_gz1mps1=a_gz1mps1,&_temp85_a_gz1mps1) : &a_gz1mps1,_pw_gz1mps1.fixedflag ? (_temp86_pw_gz1mps1=pw_gz1mps1,&_temp86_pw_gz1mps1) : &pw_gz1mps1,_pw_gz1mps1a.fixedflag ? (_temp87_pw_gz1mps1a=pw_gz1mps1a,&_temp87_pw_gz1mps1a) : &pw_gz1mps1a,_pw_gz1mps1d.fixedflag ? (_temp88_pw_gz1mps1d=pw_gz1mps1d,&_temp88_pw_gz1mps1d) : &pw_gz1mps1d,area_pulse,
                     (int)(1000000),MIN_PLATEAU_TIME,ps1loggrd.zrt,ps1_tz_xz) == FAILURE)
        {
            epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                       EE_ARGS(1), STRING_ARG, "amppwgz1 for gz1mps1.");
            return FAILURE;
        }
    }

    /* Z gradient crushers for 180 pulse */
    /* Left crusher. Denoted by the "l" after the "2"  in "gzrf2lmps1" */
    if (amppwgrad(ps_crusher_area, ps1_tz_xz, 0.0, 0.0, ps1loggrd.zrt,
                  MIN_PLATEAU_TIME, _a_gzrf2lmps1.fixedflag ? (_temp89_a_gzrf2lmps1=a_gzrf2lmps1,&_temp89_a_gzrf2lmps1) : &a_gzrf2lmps1, _pw_gzrf2lmps1a.fixedflag ? (_temp90_pw_gzrf2lmps1a=pw_gzrf2lmps1a,&_temp90_pw_gzrf2lmps1a) : &pw_gzrf2lmps1a,
                  _pw_gzrf2lmps1.fixedflag ? (_temp91_pw_gzrf2lmps1=pw_gzrf2lmps1,&_temp91_pw_gzrf2lmps1) : &pw_gzrf2lmps1, _pw_gzrf2lmps1d.fixedflag ? (_temp92_pw_gzrf2lmps1d=pw_gzrf2lmps1d,&_temp92_pw_gzrf2lmps1d) : &pw_gzrf2lmps1d) == FAILURE)
    {
        epic_error(use_ermes, "%s failed in PScveval.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgrad:gzrf2lmps1"); 
        return FAILURE;
    }
  
    /* Right crusher. Denoted by the "r" after the "2" in "gzrf2rmps1"*/
    /* This is identical to left crusher */
    pw_gzrf2rmps1  = _pw_gzrf2rmps1.fixedflag ?  ((void)(pw_gzrf2lmps1), pw_gzrf2rmps1) : pw_gzrf2lmps1;
    a_gzrf2rmps1  = _a_gzrf2rmps1.fixedflag ?   ((void)(a_gzrf2lmps1), a_gzrf2rmps1) : a_gzrf2lmps1;

    /* right crusher ramps */
    pw_gzrf2rmps1a  = _pw_gzrf2rmps1a.fixedflag ?  ((void)(pw_gzrf2lmps1a), pw_gzrf2rmps1a) : pw_gzrf2lmps1a;
    pw_gzrf2rmps1d  = _pw_gzrf2rmps1d.fixedflag ?  ((void)(pw_gzrf2lmps1d), pw_gzrf2rmps1d) : pw_gzrf2lmps1d;

    /* Z slice select for 180 pulse */
    pw_gzrf2mps1  = _pw_gzrf2mps1.fixedflag ?  ((void)(pw_rf2mps1), pw_gzrf2mps1) : pw_rf2mps1;
    bw_rf2mps1 = (LONG)(rfpulse[RF2_APS1_SLOT].nom_bw*rfpulse[RF2_APS1_SLOT].nom_pw/(float)pw_rf2mps1);

    /* begin aps1_mod changes (GE) */
    if (FAILURE==ampslice(_a_gzrf2mps1.fixedflag ? (_temp93_a_gzrf2mps1=a_gzrf2mps1,&_temp93_a_gzrf2mps1) : &a_gzrf2mps1, bw_rf2mps1, thickPS_mod, gscale_rf2mps1, TYPDEF))
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "ampslice for gzrf2mps1.");
        return FAILURE;
    }
    /* end aps1_mod changes (GE) */

    /* match ramps so gradient can be bridged in pulsegen */
    pw_gzrf2mps1a  = _pw_gzrf2mps1a.fixedflag ?  ((void)(pw_gzrf2lmps1d), pw_gzrf2mps1a) : pw_gzrf2lmps1d;
    pw_gzrf2mps1d  = _pw_gzrf2mps1d.fixedflag ?  ((void)(pw_gzrf2rmps1a), pw_gzrf2mps1d) : pw_gzrf2rmps1a;

    /* readout gradient */
    if (FAILURE==calcfilter( &echo1mps1_filt, 15.625, 256, OVERWRITE_NONE))
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "calcfilter for echo1mps1_filt");
        return FAILURE;
    }

    /* MRIge30642 */
    /* Need check on fov.  Otherwise causes dwnld failures w/0.8 G/cm. */ 
    if (ampfov(&av_temp_float1, echo1mps1_filt.bw, ps1_tx) == FAILURE)
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "ampfov");
        return FAILURE;
    }

    av_temp_float1 = ceil(av_temp_float1/ 10.0) * 10.0;
    if( av_temp_float1 > mpsfov )
    {
        mpsfov  = _mpsfov.fixedflag ?  ((void)(av_temp_float1), mpsfov) : av_temp_float1;
    }

    if (ampfov(_a_gxwmps1.fixedflag ? (_temp94_a_gxwmps1=a_gxwmps1,&_temp94_a_gxwmps1) : &a_gxwmps1, echo1mps1_filt.bw, mpsfov) == FAILURE)
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "ampfov for gxwmps1.");
        return FAILURE;
    }

    /* attack and decay ramps */
    if (optramp(_pw_gxwmps1a.fixedflag ? (_temp95_pw_gxwmps1a=pw_gxwmps1a,&_temp95_pw_gxwmps1a) : &pw_gxwmps1a, a_gxwmps1, ps1_tx, ps1_xrt,
                TYPDEF)==FAILURE)
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "optramp for gxwmps1a.");
        return FAILURE;
    }
  
    pw_gxwmps1d  = _pw_gxwmps1d.fixedflag ?  ((void)(pw_gxwmps1a), pw_gxwmps1d) : pw_gxwmps1a;

    pw_gxwmps1  = _pw_gxwmps1.fixedflag ?  ((void)(echo1mps1_filt.tdaq), pw_gxwmps1) : echo1mps1_filt.tdaq;
  
    /* dephaser */
    area_gxwmps1 = a_gxwmps1*(pw_gxwmps1);
    area_readrampmps1 = 0.5*pw_gxwmps1a*a_gxwmps1;

    if (amppwgx1(_a_gx1mps1.fixedflag ? (_temp96_a_gx1mps1=a_gx1mps1,&_temp96_a_gx1mps1) : &a_gx1mps1, _pw_gx1mps1.fixedflag ? (_temp97_pw_gx1mps1=pw_gx1mps1,&_temp97_pw_gx1mps1) : &pw_gx1mps1, _pw_gx1mps1a.fixedflag ? (_temp98_pw_gx1mps1a=pw_gx1mps1a,&_temp98_pw_gx1mps1a) : &pw_gx1mps1a ,_pw_gx1mps1d.fixedflag ? (_temp99_pw_gx1mps1d=pw_gx1mps1d,&_temp99_pw_gx1mps1d) : &pw_gx1mps1d, TYPSPIN,
                 area_gxwmps1, (float)area_readrampmps1, 
                 (int)1000000, 1.0, MIN_PLATEAU_TIME, ps1_xrt, ps1_tx_xz) == FAILURE)
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgx1 for gx1mps1.");
        return FAILURE;
    }

    /* Y gradient is not used in MPS1 */

    return SUCCESS;
}

/*
 *  CFLcveval
 *  
 *  Type: Private Function
 *  
 *  Description:
 *  
 */
STATUS
CFLcveval( FLOAT opthickPS )
{
    LONG bw_rf1cfl;
    FLOAT area_gz1cfl;

    cflloggrd = loggrd; /* same as imaging loggrd */
    /* derate SR for quiet PSC */ 
    sr_derate(&cflloggrd, PSsr_derate_factor, PSamp_derate_factor);

    if ((fastprescan == 1) &&
        ((cffield == B0_10000) || (cffield == B0_15000) || 
         (cffield == B0_30000) || (cffield == B0_40000) || (cffield == B0_70000)))
    {
        cfl_dda  = _cfl_dda.fixedflag ?  ((void)(2), cfl_dda) : 2;      /* BJM MRIge80347: Changed from 0 -> 2 for MGD, coil switch problem */
        cfl_nex  = _cfl_nex.fixedflag ?  ((void)(1), cfl_nex) : 1;
    }
    else
    {
        cfl_dda  = _cfl_dda.fixedflag ?  ((void)(4), cfl_dda) : 4;
        cfl_nex  = _cfl_nex.fixedflag ?  ((void)(2), cfl_nex) : 2;
    }

    if(cffield == B0_2000) 
    {
        echo1bwcfl  = _echo1bwcfl.fixedflag ?  ((void)(10.41666), echo1bwcfl) : 10.41666;
    } 
    else if(cffield == B0_15000)
    {
        /* MRIhc54366: accommodate B0 drift using larger receive bandwidth 
           with matched spectral resolution */
        echo1bwcfl  = _echo1bwcfl.fixedflag ?  ((void)(7.8125), echo1bwcfl) : 7.8125;         
        CFLxres  = _CFLxres.fixedflag ?  ((void)(1024), CFLxres) : 1024;
    }
    else
    {
        echo1bwcfl  = _echo1bwcfl.fixedflag ?  ((void)(15.625), echo1bwcfl) : 15.625;         
        CFLxres  = _CFLxres.fixedflag ?  ((void)(1024), CFLxres) : 1024;
    }

    /* MRIhc54366: changed hard coded number of output points to CFLxres */
    if ( FAILURE==calcfilter( &echo1cfl, echo1bwcfl, CFLxres, OVERWRITE_NONE) )
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "calcfilter for echo1cfl_filt");
        return FAILURE;
    }

    /* MRIhc54366: dynamic CFL excitation pulse selection: */
    if(floatsAlmostEqualEpsilons(cyc_rf1cfl, 2.0, 2)) 
    {
        rfpulse[RF1_CFL_SLOT].abswidth = SAR_ABS_SINC2;
        rfpulse[RF1_CFL_SLOT].effwidth = SAR_PSINC2;
        rfpulse[RF1_CFL_SLOT].area = SAR_ASINC2;
        rfpulse[RF1_CFL_SLOT].dtycyc = SAR_DTYCYC_SINC2;
        rfpulse[RF1_CFL_SLOT].maxpw = SAR_MAXPW_SINC2;
        rfpulse[RF1_CFL_SLOT].max_b1 = SAR_MAXB1_SINC2_90;
        rfpulse[RF1_CFL_SLOT].max_int_b1_sq = SAR_MAX_INT_B1_SQ_SINC2_90;
        rfpulse[RF1_CFL_SLOT].max_rms_b1 = SAR_MAX_RMS_B1_SINC2_90;
        rfpulse[RF1_CFL_SLOT].nom_bw = 2500;
    }
    else
    {
        rfpulse[RF1_CFL_SLOT].abswidth = SAR_ABS_SINC1;
        rfpulse[RF1_CFL_SLOT].effwidth = SAR_PSINC1;
        rfpulse[RF1_CFL_SLOT].area = SAR_ASINC1;
        rfpulse[RF1_CFL_SLOT].dtycyc = SAR_DTYCYC_SINC1;
        rfpulse[RF1_CFL_SLOT].maxpw = SAR_MAXPW_SINC1;
        rfpulse[RF1_CFL_SLOT].max_b1 = MAX_B1_SINC1_90;
        rfpulse[RF1_CFL_SLOT].max_int_b1_sq = MAX_INT_B1_SQ_SINC1_90;
        rfpulse[RF1_CFL_SLOT].max_rms_b1 = MAX_RMS_B1_SINC1_90;
        rfpulse[RF1_CFL_SLOT].nom_bw = 1250;
    }
    /* MRIhc54366: END pulse selection. */

    /* CFL acq duration needed for attenuator setting */
    cfl_tdaq = echo1cfl.tdaq;

    pw_gzrf1cfl  = _pw_gzrf1cfl.fixedflag ?  ((void)(pw_rf1cfl), pw_gzrf1cfl) : pw_rf1cfl;
    bw_rf1cfl = (LONG)(rfpulse[RF1_CFL_SLOT].nom_bw*rfpulse[RF1_CFL_SLOT].nom_pw/(float)pw_rf1cfl);

    /* MRIhc54366: new lower limit */
    opthickPS = (exist(opslthick) < 5.0) ? 5.0 : exist(opslthick);

    if ( FAILURE==ampslice(_a_gzrf1cfl.fixedflag ? (_temp100_a_gzrf1cfl=a_gzrf1cfl,&_temp100_a_gzrf1cfl) : &a_gzrf1cfl, bw_rf1cfl, opthickPS, gscale_rf1cfl, TYPDEF) ) 
    {
        epic_error(use_ermes, "%s failed for gzrf1cfl.",
                   EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "ampslice");
        return FAILURE;
    }

    if ( FAILURE==optramp(_pw_gzrf1cfla.fixedflag ? (_temp101_pw_gzrf1cfla=pw_gzrf1cfla,&_temp101_pw_gzrf1cfla) : &pw_gzrf1cfla, a_gzrf1cfl, cflloggrd.tz, cflloggrd.zrt, TYPDEF) )  
    {
        epic_error(use_ermes, "%s failed for gzrf1cfl.", 
                   EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "optramp");
        return FAILURE;
    }

    pw_gzrf1cfld  = _pw_gzrf1cfld.fixedflag ?  ((void)(pw_gzrf1cfla), pw_gzrf1cfld) : pw_gzrf1cfla;

    /* Find Params for refocusing pulse */
    area_gz1cfl =  a_gzrf1cfl *0.5* ( pw_gzrf1cfl + pw_gzrf1cfld);
    if ( FAILURE==amppwgz1(_a_gz1cfl.fixedflag ? (_temp102_a_gz1cfl=a_gz1cfl,&_temp102_a_gz1cfl) : &a_gz1cfl, _pw_gz1cfl.fixedflag ? (_temp103_pw_gz1cfl=pw_gz1cfl,&_temp103_pw_gz1cfl) : &pw_gz1cfl, _pw_gz1cfla.fixedflag ? (_temp104_pw_gz1cfla=pw_gz1cfla,&_temp104_pw_gz1cfla) : &pw_gz1cfla, _pw_gz1cfld.fixedflag ? (_temp105_pw_gz1cfld=pw_gz1cfld,&_temp105_pw_gz1cfld) : &pw_gz1cfld, 
                           area_gz1cfl, (INT)1000000, MIN_PLATEAU_TIME,
                           cflloggrd.zrt, cflloggrd.tz) ) 
    {
        epic_error(use_ermes, "%s failed in cfl.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgz1 for gz1cfl");
        return FAILURE;
    }

    /* Find Params for killer pulse */
    area_gykcfl  = _area_gykcfl.fixedflag ?  ((void)(amp_killer*pw_killer), area_gykcfl) : amp_killer*pw_killer;
    if ( FAILURE==amppwgrad(area_gykcfl, cflloggrd.ty, 0.0, 0.0, cflloggrd.yrt,
                            MIN_PLATEAU_TIME, _a_gykcfl.fixedflag ? (_temp106_a_gykcfl=a_gykcfl,&_temp106_a_gykcfl) : &a_gykcfl, _pw_gykcfla.fixedflag ? (_temp107_pw_gykcfla=pw_gykcfla,&_temp107_pw_gykcfla) : &pw_gykcfla,
                            _pw_gykcfl.fixedflag ? (_temp108_pw_gykcfl=pw_gykcfl,&_temp108_pw_gykcfl) : &pw_gykcfl, _pw_gykcfld.fixedflag ? (_temp109_pw_gykcfld=pw_gykcfld,&_temp109_pw_gykcfld) : &pw_gykcfld) ) 
    {
        epic_error(use_ermes, "%s failed in cfl.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgrad:gykcfl");
        return FAILURE;
    }

    return SUCCESS;
}


/*
 *  RCVNcveval
 *  
 *  Type: Private Function
 *  
 *  Description:
 *  
 */
STATUS
RCVNcveval( void )
{
    int rcvn_newgeo = 1;
    int roti;
    INT tot_gradtime = 0;
    INT tot_gradtime2 = 0;

    rcvn_flag  = _rcvn_flag.fixedflag ?  ((void)(1), rcvn_flag) : 1;

    for(  roti = 0; roti < 9; roti++ )
    {
        rcvnscan_info[0].oprot[roti] = 0.0;
    }
    /* for gradient prognostic, play out gradient on physical axes */
    rcvnscan_info[0].oprot[0]=rcvnscan_info[0].oprot[4]=rcvnscan_info[0].oprot[8]=1.0;

    if (FAILURE==obloptimize(&rcvnloggrd, &phygrd, rcvnscan_info, 1, PSD_OBL,
                             0, PSD_OBL_RESTRICT, ps1obl_debug, &rcvn_newgeo,
                             cfsrmode))
    {
        epic_error(use_ermes, "%s failed in RCVNcveval.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "obloptimize"); 
        return FAILURE;
    }

    if(mkgspec_flag == MK_SPEC_MODE_GRAD_3AXES)
    {
        rcvn_flag  = _rcvn_flag.fixedflag ?  ((void)(1), rcvn_flag) : 1;  /* disable gradient prognostic and using Imaging plane */
        for (roti = 0; roti < 9; roti++)
        {
            rcvnscan_info[0].oprot[roti] = scan_info[PSslice_num].oprot[roti]; /* use Rxed slice rot */
        }
        rcvnloggrd = loggrd;
    }
    /* for grad prognostic test only for non-derated case */
    else if((PSsr_derate_factor < 2.0) && (PSamp_derate_factor < 2.0) && !(isSVSystem()))
    {
        rcvn_flag  = _rcvn_flag.fixedflag ?  ((void)(3), rcvn_flag) : 3;  /* new waveform for grad prognostic, using Axial plane */
    }

    /* derate SR for quiet PSC */ 
    sr_derate(&rcvnloggrd, PSsr_derate_factor, PSamp_derate_factor);

    /* MRIhc47602/MRIhc47515/GEHmr03545 : Killer gradient before Receiver noise sequence */

    if ( FAILURE==amppwgrad( area_gxkrcvn, rcvnloggrd.tx_xyz, 0.0, 0.0, rcvnloggrd.xrt,
                             MIN_PLATEAU_TIME, _a_gxkrcvn.fixedflag ? (_temp110_a_gxkrcvn=a_gxkrcvn,&_temp110_a_gxkrcvn) : &a_gxkrcvn, _pw_gxkrcvna.fixedflag ? (_temp111_pw_gxkrcvna=pw_gxkrcvna,&_temp111_pw_gxkrcvna) : &pw_gxkrcvna,
                             _pw_gxkrcvn.fixedflag ? (_temp112_pw_gxkrcvn=pw_gxkrcvn,&_temp112_pw_gxkrcvn) : &pw_gxkrcvn, _pw_gxkrcvnd.fixedflag ? (_temp113_pw_gxkrcvnd=pw_gxkrcvnd,&_temp113_pw_gxkrcvnd) : &pw_gxkrcvnd ) )
    {
        epic_error(use_ermes, "Support routine %s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgrad:gxkrcvn");
        return FAILURE;
    }

    if ( FAILURE==amppwgrad( area_gykrcvn, rcvnloggrd.ty_xyz, 0.0, 0.0, rcvnloggrd.yrt,
                             MIN_PLATEAU_TIME, _a_gykrcvn.fixedflag ? (_temp114_a_gykrcvn=a_gykrcvn,&_temp114_a_gykrcvn) : &a_gykrcvn, _pw_gykrcvna.fixedflag ? (_temp115_pw_gykrcvna=pw_gykrcvna,&_temp115_pw_gykrcvna) : &pw_gykrcvna,
                             _pw_gykrcvn.fixedflag ? (_temp116_pw_gykrcvn=pw_gykrcvn,&_temp116_pw_gykrcvn) : &pw_gykrcvn, _pw_gykrcvnd.fixedflag ? (_temp117_pw_gykrcvnd=pw_gykrcvnd,&_temp117_pw_gykrcvnd) : &pw_gykrcvnd ) )
    {
        epic_error(use_ermes, "Support routine %s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgrad:gykrcvn");
        return FAILURE;
    }

    if ( FAILURE==amppwgrad( area_gzkrcvn, rcvnloggrd.tz_xyz, 0.0, 0.0, rcvnloggrd.zrt,
                             MIN_PLATEAU_TIME, _a_gzkrcvn.fixedflag ? (_temp118_a_gzkrcvn=a_gzkrcvn,&_temp118_a_gzkrcvn) : &a_gzkrcvn, _pw_gzkrcvna.fixedflag ? (_temp119_pw_gzkrcvna=pw_gzkrcvna,&_temp119_pw_gzkrcvna) : &pw_gzkrcvna,
                             _pw_gzkrcvn.fixedflag ? (_temp120_pw_gzkrcvn=pw_gzkrcvn,&_temp120_pw_gzkrcvn) : &pw_gzkrcvn, _pw_gzkrcvnd.fixedflag ? (_temp121_pw_gzkrcvnd=pw_gzkrcvnd,&_temp121_pw_gzkrcvnd) : &pw_gzkrcvnd ) )
    {
        epic_error(use_ermes, "Support routine %s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgrad:gzkrcvn");
        return FAILURE;
    }

    if( 3 == rcvn_flag )
    {
        /* X Grad -- +12 ms, -4ms */
        pw_gxkrcvn  = _pw_gxkrcvn.fixedflag ?    ((void)(RUP_GRD(12000-2*pw_gxkrcvna)), pw_gxkrcvn) : RUP_GRD(12000-2*pw_gxkrcvna);
        a_gxk2rcvn  = _a_gxk2rcvn.fixedflag ?  ((void)(-a_gxkrcvn), a_gxk2rcvn) : -a_gxkrcvn;
        pw_gxk2rcvna  = _pw_gxk2rcvna.fixedflag ?  ((void)(pw_gxkrcvna), pw_gxk2rcvna) : pw_gxkrcvna;
        pw_gxk2rcvnd  = _pw_gxk2rcvnd.fixedflag ?  ((void)(pw_gxk2rcvna), pw_gxk2rcvnd) : pw_gxk2rcvna;
        pw_gxk2rcvn  = _pw_gxk2rcvn.fixedflag ?    ((void)(RUP_GRD(4000-2*pw_gxk2rcvna)), pw_gxk2rcvn) : RUP_GRD(4000-2*pw_gxk2rcvna);
        if(pw_gxkrcvn <= 0)
        {
            pw_gxkrcvn  = _pw_gxkrcvn.fixedflag ?  ((void)(4), pw_gxkrcvn) : 4;
        }
        if(pw_gxk2rcvn <= 0)
        {
            pw_gxk2rcvn  = _pw_gxk2rcvn.fixedflag ?  ((void)(4), pw_gxk2rcvn) : 4;
        }

        /* Y Grad -- +8 ms, -12ms  */
        pw_gykrcvn  = _pw_gykrcvn.fixedflag ?    ((void)(RUP_GRD(8000-2*pw_gykrcvna)), pw_gykrcvn) : RUP_GRD(8000-2*pw_gykrcvna);
        a_gyk2rcvn  = _a_gyk2rcvn.fixedflag ?  ((void)(-a_gykrcvn), a_gyk2rcvn) : -a_gykrcvn;
        pw_gyk2rcvna  = _pw_gyk2rcvna.fixedflag ?  ((void)(pw_gykrcvna), pw_gyk2rcvna) : pw_gykrcvna;
        pw_gyk2rcvnd  = _pw_gyk2rcvnd.fixedflag ?  ((void)(pw_gyk2rcvna), pw_gyk2rcvnd) : pw_gyk2rcvna;
        pw_gyk2rcvn  = _pw_gyk2rcvn.fixedflag ?    ((void)(RUP_GRD(12000-2*pw_gyk2rcvna)), pw_gyk2rcvn) : RUP_GRD(12000-2*pw_gyk2rcvna);
        if(pw_gykrcvn <= 0)
        {
            pw_gykrcvn  = _pw_gykrcvn.fixedflag ?  ((void)(4), pw_gykrcvn) : 4;
        }
        if(pw_gyk2rcvn <= 0)
        {
            pw_gyk2rcvn  = _pw_gyk2rcvn.fixedflag ?  ((void)(4), pw_gyk2rcvn) : 4;
        }

        /* Z Grad -- +4 ms, -12ms */
        pw_gzkrcvn  = _pw_gzkrcvn.fixedflag ?    ((void)(RUP_GRD(4000-2*pw_gzkrcvna)), pw_gzkrcvn) : RUP_GRD(4000-2*pw_gzkrcvna);
        a_gzk2rcvn  = _a_gzk2rcvn.fixedflag ?  ((void)(-a_gzkrcvn), a_gzk2rcvn) : -a_gzkrcvn;
        pw_gzk2rcvna  = _pw_gzk2rcvna.fixedflag ?  ((void)(pw_gzkrcvna), pw_gzk2rcvna) : pw_gzkrcvna;
        pw_gzk2rcvnd  = _pw_gzk2rcvnd.fixedflag ?  ((void)(pw_gzk2rcvna), pw_gzk2rcvnd) : pw_gzk2rcvna;
        pw_gzk2rcvn  = _pw_gzk2rcvn.fixedflag ?    ((void)(RUP_GRD(12000-2*pw_gzk2rcvna)), pw_gzk2rcvn) : RUP_GRD(12000-2*pw_gzk2rcvna);
        if(pw_gzkrcvn <= 0)
        {
            pw_gzkrcvn  = _pw_gzkrcvn.fixedflag ?  ((void)(4), pw_gzkrcvn) : 4;
        }
        if(pw_gzk2rcvn <= 0)
        {
            pw_gzk2rcvn  = _pw_gzk2rcvn.fixedflag ?  ((void)(4), pw_gzk2rcvn) : 4;
        }

        tot_gradtime2 = IMax(3, pw_gxk2rcvna+pw_gxk2rcvn+pw_gxk2rcvnd, 
                             pw_gyk2rcvna+pw_gyk2rcvn+pw_gyk2rcvnd, pw_gzk2rcvna+pw_gzk2rcvn+pw_gzk2rcvnd);
    }
    else
    {
        a_gxk2rcvn  = _a_gxk2rcvn.fixedflag ?  ((void)(0.0), a_gxk2rcvn) : 0.0;
        a_gyk2rcvn  = _a_gyk2rcvn.fixedflag ?  ((void)(0.0), a_gyk2rcvn) : 0.0;
        a_gzk2rcvn  = _a_gzk2rcvn.fixedflag ?  ((void)(0.0), a_gzk2rcvn) : 0.0;
        tot_gradtime2 = 0;
    }

    tot_gradtime = pw_gykrcvna+pw_gykrcvn+pw_gykrcvnd+tot_gradtime2;

    if ( (rcvn_flag == 1) || (rcvn_flag == 3) )
    {
        pre_rcvn_tr  = _pre_rcvn_tr.fixedflag ?    ((void)(IMax(2,20000,RUP_GRD(tot_gradtime+1000))), pre_rcvn_tr) : IMax(2,20000,RUP_GRD(tot_gradtime+1000));
    }
    else if(rcvn_flag == 2)  /* extra wait before rcvn */
    {
        pre_rcvn_tr  = _pre_rcvn_tr.fixedflag ?  ((void)(1000000), pre_rcvn_tr) : 1000000;
    }

    if (existcv(oprbw))
    {
        echo1bwrcvn  = _echo1bwrcvn.fixedflag ?  ((void)(exist(oprbw)), echo1bwrcvn) : exist(oprbw);
    }

    echo1bwrcvn  = _echo1bwrcvn.fixedflag ?     ((void)(FMax(2,echo1bwrcvn,(float)RCVN_MIN_BW)), echo1bwrcvn) : FMax(2,echo1bwrcvn,(float)RCVN_MIN_BW);

    echo1bwrcvn  = _echo1bwrcvn.fixedflag ?     ((void)(FMin(2,echo1bwrcvn,(float)RCVN_MAX_BW)), echo1bwrcvn) : FMin(2,echo1bwrcvn,(float)RCVN_MAX_BW);

    if ( FAILURE==calcfilter( &echo1rcvn, echo1bwrcvn, rcvn_xres, OVERWRITE_NONE) ) 
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "calcfilter for echo1rcvn");
        return FAILURE;
    }

    /* RCVN acq duration needed for attenuator setting */
    rcvn_tdaq = echo1rcvn.tdaq;

    /* Add 20ms dead time to prevent runtime errors */
    rcvn_tr  = _rcvn_tr.fixedflag ?       ((void)(IMax(2,rcvn_tdaq+20000,(int)RCVN_MIN_TR)), rcvn_tr) : IMax(2,rcvn_tdaq+20000,(int)RCVN_MIN_TR);

    /* To make sure RCVN loops enough to acquire 4K points */
    rcvn_loops  = _rcvn_loops.fixedflag ?       ((void)(IMax(2,2*(int)(4096/rcvn_xres),1)), rcvn_loops) : IMax(2,2*(int)(4096/rcvn_xres),1);

    return SUCCESS;
}

/*
 *  AScveval
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
AScveval( void )
{
    /* DV26: Baseline used for Autoshim noise level thresholding */
    asbaseline  = _asbaseline.fixedflag ?  ((void)(8), asbaseline) : 8;
    /* REDFLAG : Making the same as 1.0T and 1.5T (3T/4T) */
    if ((fastprescan == 1) &&
        ((cffield == B0_10000) || (cffield == B0_15000) ||
         (cffield == B0_30000) || (cffield == B0_40000) || (cffield == B0_70000)))
    {
        as_dda  = _as_dda.fixedflag ?  ((void)(0), as_dda) : 0;
        echo1bwas  = _echo1bwas.fixedflag ?  ((void)(62.5), echo1bwas) : 62.5;
        asxres  = _asxres.fixedflag ?  ((void)(128), asxres) : 128;
        asyres  = _asyres.fixedflag ?   ((void)(64), asyres) : 64;
        /* asres=128 and asyres=64 for all T fields */
    }
    else
    {
        as_dda  = _as_dda.fixedflag ?  ((void)(4), as_dda) : 4;
        echo1bwas  = _echo1bwas.fixedflag ?  ((void)(15.625), echo1bwas) : 15.625;
        asxres  = _asxres.fixedflag ?  ((void)(256), asxres) : 256;
        asyres  = _asyres.fixedflag ?  ((void)(128), asyres) : 128;
        te_as  = _te_as.fixedflag ?  ((void)(9000), te_as) : 9000;
        if (cffield == B0_15000)
        {
            tr_as  = _tr_as.fixedflag ?  ((void)(25000), tr_as) : 25000;
        }
        else if (cffield == B0_10000)
        {
            tr_as  = _tr_as.fixedflag ?  ((void)(30000), tr_as) : 30000;
        }
        else if (cffield == B0_2000) /* profile 05/22/95 NM */
        {
            tr_as  = _tr_as.fixedflag ?  ((void)(40000), tr_as) : 40000; /* Profile 09/29/95 NM */
        }
        else if (cffield == B0_3500) /* MFO,Hino, Feb/02/00 MM */
        {
            tr_as  = _tr_as.fixedflag ?  ((void)(40000), tr_as) : 40000;
        }
        else if (cffield == B0_5000)
        {
            tr_as  = _tr_as.fixedflag ?  ((void)(35000), tr_as) : 35000;
        }
        else if (cffield == B0_70000)
        {
            /* REDFLAG : Using same value as 1.5T. */
            tr_as  = _tr_as.fixedflag ?  ((void)(25000), tr_as) : 25000;
            DEBUG_7_0(SD_PSD_SUPPORT,__FILE__,__LINE__);
        }
        else if (cffield == B0_40000)
        {
            /* REDFLAG : Using same value as 1.5T. */
            tr_as  = _tr_as.fixedflag ?  ((void)(25000), tr_as) : 25000;
            DEBUG_4_0(SD_PSD_SUPPORT,__FILE__,__LINE__);
        }
        else if (cffield == B0_30000)
        {
            /* REDFLAG : Using same value as 1.5T. */
            tr_as  = _tr_as.fixedflag ?  ((void)(25000), tr_as) : 25000;
            DEBUG_3_0(SD_PSD_SUPPORT,__FILE__,__LINE__);
        }
        else if (cffield == B0_7000)
        {
            tr_as  = _tr_as.fixedflag ?  ((void)(32000), tr_as) : 32000;
            DEBUG_0_7(SD_PSD_SUPPORT,__FILE__,__LINE__);
        }
        else 
        {
            SDL_PrintFStrengthWarning(SD_PSD_SUPPORT,cffield,__FILE__,__LINE__);
        }
    }

    /* MRIge21914 - moved deltf to @cv */

    /* Call the SDL function to compute fat-water separation. */
    deltf  = _deltf.fixedflag ?    ((void)(SDL_GetChemicalShift(cffield)), deltf) : SDL_GetChemicalShift(cffield);
    /* In phase delta TE will be used in MFO. Hino, Feb/02/00 MM */

    /* dixon time shift.  put it on grad boundary. */
    dix_timeas  = _dix_timeas.fixedflag ?   ((void)(RUP_GRD((int)(1000000/deltf))), dix_timeas) : RUP_GRD((int)(1000000/deltf));
    pw_sdixon2  = _pw_sdixon2.fixedflag ?    ((void)(GRAD_UPDATE_TIME+dix_timeas), pw_sdixon2) : GRAD_UPDATE_TIME+dix_timeas;

    /********************************************************/
    /*   Z Board                                            */
    /*   Slice Selection                                    */
    /********************************************************/
    if (FAILURE==ampslice(_a_gzrf1as.fixedflag ? (_temp122_a_gzrf1as=a_gzrf1as,&_temp122_a_gzrf1as) : &a_gzrf1as, bw_rf1as, asslthick, gscale_rf1as, TYPDEF))
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "ampslice for gzrf1as.");

        return FAILURE;
    }

    if (FAILURE==optramp(_pw_gzrf1asa.fixedflag ? (_temp123_pw_gzrf1asa=pw_gzrf1asa,&_temp123_pw_gzrf1asa) : &pw_gzrf1asa, a_gzrf1as, asloggrd.tz_xyz, asloggrd.zrt, TYPDEF))
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "optramp for gzrf1asa.");
        return FAILURE;
    }
    pw_gzrf1asd  = _pw_gzrf1asd.fixedflag ?  ((void)(pw_gzrf1asa), pw_gzrf1asd) : pw_gzrf1asa;

    /******************************************/
    /*   Calc area needed for z rephaser      */
    /******************************************/
    area_gz1as  = _area_gz1as.fixedflag ?     ((void)((off90as+pw_rf1as/2.0+pw_gzrf1asd/2.0)*a_gzrf1as), area_gz1as) : (off90as+pw_rf1as/2.0+pw_gzrf1asd/2.0)*a_gzrf1as;

    /* availible time for rephaser */
    avail_pwgz1as  = _avail_pwgz1as.fixedflag ?  ((void)(1000000), avail_pwgz1as) : 1000000;

    if ( FAILURE==amppwgz1(_a_gz1as.fixedflag ? (_temp124_a_gz1as=a_gz1as,&_temp124_a_gz1as) : &a_gz1as, _pw_gz1as.fixedflag ? (_temp125_pw_gz1as=pw_gz1as,&_temp125_pw_gz1as) : &pw_gz1as, _pw_gz1asa.fixedflag ? (_temp126_pw_gz1asa=pw_gz1asa,&_temp126_pw_gz1asa) : &pw_gz1asa, _pw_gz1asd.fixedflag ? (_temp127_pw_gz1asd=pw_gz1asd,&_temp127_pw_gz1asd) : &pw_gz1asd,
                           area_gz1as, avail_pwgz1as, MIN_PLATEAU_TIME,
                           asloggrd.zrt, asloggrd.tz_xyz) )
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgz1 for gz1as.");
        return FAILURE;
    }

    /*****************************************************************/
    /*  X Board - readout and dephaser                               */
    /*****************************************************************/

    if ( FAILURE==calcfilter( &echo1as_filt, echo1bwas, asxres, OVERWRITE_NONE) ) 
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "calcfilter for echo1as_filt");

        return FAILURE;
    }

    if ( FAILURE==ampfov(_a_gxwas.fixedflag ? (_temp128_a_gxwas=a_gxwas,&_temp128_a_gxwas) : &a_gxwas, echo1as_filt.bw, asfov) )
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "ampfov for gxwas.");
        return FAILURE;
    }

    if (FAILURE==optramp(_pw_gxwasa.fixedflag ? (_temp129_pw_gxwasa=pw_gxwasa,&_temp129_pw_gxwasa) : &pw_gxwasa, a_gxwas, asloggrd.tx_xyz, asloggrd.xrt, TYPDEF)) 
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "optramp for pw_gxwasa.");
        return FAILURE;
    }

    pw_gxwasd  = _pw_gxwasd.fixedflag ?  ((void)(pw_gxwasa), pw_gxwasd) : pw_gxwasa;
    pw_gxwas  = _pw_gxwas.fixedflag ?  ((void)(echo1as_filt.tdaq), pw_gxwas) : echo1as_filt.tdaq;

    avail_pwgx1as  = _avail_pwgx1as.fixedflag ?  ((void)(1000000), avail_pwgx1as) : 1000000;

    area_readrampas  = _area_readrampas.fixedflag ?  ((void)(0.5*pw_gxwasa*a_gxwas), area_readrampas) : 0.5*pw_gxwasa*a_gxwas;
    area_gxwas  = _area_gxwas.fixedflag ?  ((void)(pw_gxwas*a_gxwas), area_gxwas) : pw_gxwas*a_gxwas;

    if ( FAILURE==amppwgx1(_a_gx1as.fixedflag ? (_temp130_a_gx1as=a_gx1as,&_temp130_a_gx1as) : &a_gx1as, _pw_gx1as.fixedflag ? (_temp131_pw_gx1as=pw_gx1as,&_temp131_pw_gx1as) : &pw_gx1as, _pw_gx1asa.fixedflag ? (_temp132_pw_gx1asa=pw_gx1asa,&_temp132_pw_gx1asa) : &pw_gx1asa, _pw_gx1asd.fixedflag ? (_temp133_pw_gx1asd=pw_gx1asd,&_temp133_pw_gx1asd) : &pw_gx1asd,
                           (int)TYPGRAD, area_gxwas, area_readrampas,
                           avail_pwgx1as, 1.0, MIN_PLATEAU_TIME,
                           asloggrd.xrt, asloggrd.tx_xyz) )
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgx1 for gx1as.");
        return FAILURE;
    }

    /***************************************************************/
    /*   Y Board - Dephaser and Killer                             */
    /*                                                             */
    /*   Calculate Y Phase encode amp and pw.                      */
    /*                                                             */
    /***************************************************************/

    /* Scale the waveform amps for the phase encodes 
     * so each phase instruction jump is an integer step */
    if ( FAILURE==endview((int)(asyres), _endview_iampas.fixedflag ? (_temp134_endview_iampas=endview_iampas,&_temp134_endview_iampas) : &endview_iampas) )
    {
        epic_error(use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "endview:autoshim");
        return FAILURE;
    } 
  
    endview_scaleas  = _endview_scaleas.fixedflag ?   ((void)((float)max_pg_iamp/(float)endview_iampas), endview_scaleas) : (float)max_pg_iamp/(float)endview_iampas;

    if ( FAILURE==amppwtpe(_a_gy1asa.fixedflag ? (_temp135_a_gy1asa=a_gy1asa,&_temp135_a_gy1asa) : &a_gy1asa, _a_gy1asb.fixedflag ? (_temp136_a_gy1asb=a_gy1asb,&_temp136_a_gy1asb) : &a_gy1asb, _pw_gy1as.fixedflag ? (_temp137_pw_gy1as=pw_gy1as,&_temp137_pw_gy1as) : &pw_gy1as, _pw_gy1asa.fixedflag ? (_temp138_pw_gy1asa=pw_gy1asa,&_temp138_pw_gy1asa) : &pw_gy1asa, _pw_gy1asd.fixedflag ? (_temp139_pw_gy1asd=pw_gy1asd,&_temp139_pw_gy1asd) : &pw_gy1asd,
                           asloggrd.ty_xyz/endview_scaleas,asloggrd.yrt,
                           (0.5 * (FLOAT)(asyres-1))/(asfov * 0.1) * 1.0e6/ GAM) ) 
    {
        epic_error(use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwtpe:autoshim");
        return FAILURE;
    }

    /* phase rewinders */
    a_gy1ras  = _a_gy1ras.fixedflag ?  ((void)(a_gy1as), a_gy1ras) : a_gy1as;
    a_gy1rasa  = _a_gy1rasa.fixedflag ?  ((void)(a_gy1asa), a_gy1rasa) : a_gy1asa;
    a_gy1rasb  = _a_gy1rasb.fixedflag ?  ((void)(a_gy1asb), a_gy1rasb) : a_gy1asb;
    pw_gy1ras  = _pw_gy1ras.fixedflag ?  ((void)(pw_gy1as), pw_gy1ras) : pw_gy1as;
    pw_gy1rasa  = _pw_gy1rasa.fixedflag ?  ((void)(pw_gy1asa), pw_gy1rasa) : pw_gy1asa;
    pw_gy1rasd  = _pw_gy1rasd.fixedflag ?  ((void)(pw_gy1asd), pw_gy1rasd) : pw_gy1asd;

    if(1==fastprescan) 
    {

        te_as  = _te_as.fixedflag ?           
                                  
                               ((void)(RUP_GRD(pw_rf1as/2+off90as+pw_gzrf1asd+pw_gz1asa+pw_gz1as+pw_gz1asd+pw_gy1asa+pw_gy1as+pw_gy1asd+pw_gx1asa+pw_gx1as+pw_gx1asd+pw_gxwasa+pw_gxwas/2)), te_as) : RUP_GRD(pw_rf1as/2+off90as+pw_gzrf1asd+pw_gz1asa+pw_gz1as+pw_gz1asd+pw_gy1asa+pw_gy1as+pw_gy1asd+pw_gx1asa+pw_gx1as+pw_gx1asd+pw_gxwasa+pw_gxwas/2);

        tr_as  = _tr_as.fixedflag ?           
                                  
                             ((void)(RUP_GRD(te_as+dix_timeas+pw_gzrf1as/2+pw_gzrf1asa+td0as+tleadas-rfupa+pw_gxwas/2+pw_gxwasd+pw_gzkasa+pw_gzkas+pw_gzkasd+1000)), tr_as) : RUP_GRD(te_as+dix_timeas+pw_gzrf1as/2+pw_gzrf1asa+td0as+tleadas-rfupa+pw_gxwas/2+pw_gxwasd+pw_gzkasa+pw_gzkas+pw_gzkasd+1000);
    }

    return SUCCESS;
}   /* end AScveval() */


/*
 *  CFHfilter
 *  
 *  Type: Private Function
 *  
 *  Description: Separate function for CFH for inclusion in 
 *               in Spectroscopy volume localized CFH
 *  
 */
STATUS
CFHfilter( int xres )
{
    CFHxres  = _CFHxres.fixedflag ?  ((void)(xres), CFHxres) : xres;

    if(cffield <= B0_5000) 
    {
        echo1bwcfh  = _echo1bwcfh.fixedflag ?  ((void)(0.25), echo1bwcfh) : 0.25;
    }
    else if (cffield == B0_70000)
    {
        echo1bwcfh  = _echo1bwcfh.fixedflag ?  ((void)(2.0), echo1bwcfh) : 2.0;
    }
    else if (cffield >= B0_30000) 
    {
        echo1bwcfh  = _echo1bwcfh.fixedflag ?  ((void)(1.0), echo1bwcfh) : 1.0;
    }
    else 
    {
        echo1bwcfh  = _echo1bwcfh.fixedflag ?  ((void)(0.50), echo1bwcfh) : 0.50;
    }

    if ( FAILURE==calcfilter( &echo1cfh, echo1bwcfh, CFHxres, OVERWRITE_NONE) ) 
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "calcfilter for echo1cfh_filt");
        return FAILURE;
    }

    cfh_tdaq = echo1cfh.tdaq;

    return SUCCESS;
}

/*
 *  CFHcveval
 *  
 *  Type: Private Function
 *  
 *  Description:
 *  
 */
STATUS
CFHcveval( FLOAT opthickPS )
{
    LONG bw_rf0cfh;
    LONG bw_rf1cfh;

    GRAD_PULSE psd_cfhrightcrush;
    GRAD_PULSE psd_cfhleftcrush;

    FLOAT area_gz1cfh;
    a_gyrf3cfh  = _a_gyrf3cfh.fixedflag ?  ((void)(0.0), a_gyrf3cfh) : 0.0;/*For MRIhc11621 */
    /* For presscfh MRIhc08321 */
    if( presscfh == PRESSCFH_SLICE && PSfield_strength > B0_5000 && 
        cfh_newmode && exist(oppscvquant)>= 1 ) 
    {
        cvoverride(presscfh_ctrl, PRESSCFH_SLICE, PSD_FIX_ON, PSD_EXIST_ON);
        presscfh_slthick  = _presscfh_slthick.fixedflag ?  ((void)(opthickPS), presscfh_slthick) : opthickPS;
        presscfh_fov_ratio  = _presscfh_fov_ratio.fixedflag ?  ((void)(0.8), presscfh_fov_ratio) : 0.8;
        presscfh_pfov_ratio  = _presscfh_pfov_ratio.fixedflag ?  ((void)(0.8), presscfh_pfov_ratio) : 0.8;
        presscfh_slab_ratio  = _presscfh_slab_ratio.fixedflag ?  ((void)(0.5), presscfh_slab_ratio) : 0.5;
    } 
    else if(presscfh == PRESSCFH_SLAB && PSfield_strength > B0_5000 &&
            cfh_newmode && exist(oppscvquant)>= 1 ) 
    {
        cvoverride(presscfh_ctrl, PRESSCFH_SLAB, PSD_FIX_ON, PSD_EXIST_ON);
        presscfh_fov_ratio  = _presscfh_fov_ratio.fixedflag ?  ((void)(0.8), presscfh_fov_ratio) : 0.8;
        presscfh_pfov_ratio  = _presscfh_pfov_ratio.fixedflag ?  ((void)(0.8), presscfh_pfov_ratio) : 0.8;
        presscfh_slab_ratio  = _presscfh_slab_ratio.fixedflag ?  ((void)(0.75), presscfh_slab_ratio) : 0.75;
    }
    else if( presscfh == PRESSCFH_SHIMVOL && PSfield_strength > B0_5000 &&
             cfh_newmode && exist(oppscvquant) >= 1 ) 
    {
        cvoverride(presscfh_ctrl, PRESSCFH_SHIMVOL, PSD_FIX_ON, PSD_EXIST_ON); 
        presscfh_fov_ratio  = _presscfh_fov_ratio.fixedflag ?  ((void)(0.5), presscfh_fov_ratio) : 0.5;
        presscfh_pfov_ratio  = _presscfh_pfov_ratio.fixedflag ?  ((void)(0.5), presscfh_pfov_ratio) : 0.5;
        presscfh_slab_ratio  = _presscfh_slab_ratio.fixedflag ?  ((void)(0.5), presscfh_slab_ratio) : 0.5;
    }
    else if( presscfh == PRESSCFH_SHIMVOL_SLICE && PSfield_strength > B0_5000 &&
             cfh_newmode && exist(oppscvquant) >= 1 ) 
    {
        cvoverride(presscfh_ctrl, PRESSCFH_SHIMVOL_SLICE, PSD_FIX_ON, PSD_EXIST_ON); 
        presscfh_fov_ratio  = _presscfh_fov_ratio.fixedflag ?  ((void)(1.0), presscfh_fov_ratio) : 1.0;
        presscfh_pfov_ratio  = _presscfh_pfov_ratio.fixedflag ?  ((void)(1.0), presscfh_pfov_ratio) : 1.0;
        presscfh_slab_ratio  = _presscfh_slab_ratio.fixedflag ?  ((void)(1.0), presscfh_slab_ratio) : 1.0;
    }
    else
    { 
        cvoverride(presscfh_ctrl, PRESSCFH_NONE, PSD_FIX_ON, PSD_EXIST_ON); 
    }
    
    if(presscfh_debug) 
    {
        printf("\n CFHcveval : presscfh = %d,presscfh_ctrl = %d,presscfh_override = %d\n",presscfh,presscfh_ctrl,presscfh_override);
        fflush(stdout);
    }

    wg_cfh_rf3  = _wg_cfh_rf3.fixedflag ?            ((void)(((presscfh_ctrl!=PRESSCFH_SHIMVOL_SLICE)||(debug_shimvol_slice==0))?ZGRAD:XGRAD), wg_cfh_rf3) : ((presscfh_ctrl!=PRESSCFH_SHIMVOL_SLICE)||(debug_shimvol_slice==0))?ZGRAD:XGRAD;
    wg_cfh_rf4  = _wg_cfh_rf4.fixedflag ?            ((void)(((presscfh_ctrl!=PRESSCFH_SHIMVOL_SLICE)||(debug_shimvol_slice==0))?ZGRAD:YGRAD), wg_cfh_rf4) : ((presscfh_ctrl!=PRESSCFH_SHIMVOL_SLICE)||(debug_shimvol_slice==0))?ZGRAD:YGRAD;

    /* REDFLAG : Making the same as 1.0T and 1.5T (3T/4T) */
    if ((fastprescan == 1) &&
        ((cffield == B0_10000) || (cffield == B0_15000) || 
         (cffield == B0_30000) || (cffield == B0_40000) || (cffield == B0_70000)))
    {
        cfh_dda  = _cfh_dda.fixedflag ?  ((void)(0), cfh_dda) : 0;
        cfh_nex  = _cfh_nex.fixedflag ?  ((void)(1), cfh_nex) : 1;
    }
    else
    {
        cfh_dda  = _cfh_dda.fixedflag ?  ((void)(4), cfh_dda) : 4;
        cfh_nex  = _cfh_nex.fixedflag ?  ((void)(2), cfh_nex) : 2;
    }

    if(cffield == B0_15000) 
    {
        cfh_ti  = _cfh_ti.fixedflag ?  ((void)(CFHTI_1HT), cfh_ti) : CFHTI_1HT;
        eff_cfh_te  = _eff_cfh_te.fixedflag ?  ((void)(CFHTE_1HT), eff_cfh_te) : CFHTE_1HT;
    }
    else if (cffield == B0_70000)
    {
        cfh_ti  = _cfh_ti.fixedflag ?  ((void)(CFHTI_7T), cfh_ti) : CFHTI_7T;
        eff_cfh_te  = _eff_cfh_te.fixedflag ?  ((void)(CFHTE_7T), eff_cfh_te) : CFHTE_7T;
    }
    else if(cffield >= B0_30000) 
    {
        cfh_ti  = _cfh_ti.fixedflag ?  ((void)(CFHTI_3T), cfh_ti) : CFHTI_3T;
        eff_cfh_te  = _eff_cfh_te.fixedflag ?  ((void)(CFHTE_3T), eff_cfh_te) : CFHTE_3T;
    }

    CFHfilter(256);

    /* Initialize some grad structures 
       so we can use the psdsupport routine amppwlcrsh */
    psd_cfhleftcrush.attack = _pw_gzrf2lcfha.fixedflag ? (_temp140_pw_gzrf2lcfha=pw_gzrf2lcfha,&_temp140_pw_gzrf2lcfha) : &pw_gzrf2lcfha;
    psd_cfhleftcrush.decay = _pw_gzrf2lcfhd.fixedflag ? (_temp141_pw_gzrf2lcfhd=pw_gzrf2lcfhd,&_temp141_pw_gzrf2lcfhd) : &pw_gzrf2lcfhd;
    psd_cfhleftcrush.pw = _pw_gzrf2lcfh.fixedflag ? (_temp142_pw_gzrf2lcfh=pw_gzrf2lcfh,&_temp142_pw_gzrf2lcfh) : &pw_gzrf2lcfh;
    psd_cfhleftcrush.amp = _a_gzrf2lcfh.fixedflag ? (_temp143_a_gzrf2lcfh=a_gzrf2lcfh,&_temp143_a_gzrf2lcfh) : &a_gzrf2lcfh;
 
    psd_cfhrightcrush.attack = _pw_gzrf2rcfha.fixedflag ? (_temp144_pw_gzrf2rcfha=pw_gzrf2rcfha,&_temp144_pw_gzrf2rcfha) : &pw_gzrf2rcfha;
    psd_cfhrightcrush.decay = _pw_gzrf2rcfhd.fixedflag ? (_temp145_pw_gzrf2rcfhd=pw_gzrf2rcfhd,&_temp145_pw_gzrf2rcfhd) : &pw_gzrf2rcfhd;
    psd_cfhrightcrush.pw = _pw_gzrf2rcfh.fixedflag ? (_temp146_pw_gzrf2rcfh=pw_gzrf2rcfh,&_temp146_pw_gzrf2rcfh) : &pw_gzrf2rcfh;
    psd_cfhrightcrush.amp = _a_gzrf2rcfh.fixedflag ? (_temp147_a_gzrf2rcfh=a_gzrf2rcfh,&_temp147_a_gzrf2rcfh) : &a_gzrf2rcfh;

    if( presscfh_ctrl != PRESSCFH_NONE && cfh_steam_flag == PSD_ON )
    {
        psd_cfhrightcrush.attack = _pw_gzrf3rcfha.fixedflag ? (_temp148_pw_gzrf3rcfha=pw_gzrf3rcfha,&_temp148_pw_gzrf3rcfha) : &pw_gzrf3rcfha;
        psd_cfhrightcrush.decay = _pw_gzrf3rcfhd.fixedflag ? (_temp149_pw_gzrf3rcfhd=pw_gzrf3rcfhd,&_temp149_pw_gzrf3rcfhd) : &pw_gzrf3rcfhd;
        psd_cfhrightcrush.pw = _pw_gzrf3rcfh.fixedflag ? (_temp150_pw_gzrf3rcfh=pw_gzrf3rcfh,&_temp150_pw_gzrf3rcfh) : &pw_gzrf3rcfh;
        psd_cfhrightcrush.amp = _a_gzrf3rcfh.fixedflag ? (_temp151_a_gzrf3rcfh=a_gzrf3rcfh,&_temp151_a_gzrf3rcfh) : &a_gzrf3rcfh;
    }

    if( presscfh_ctrl != PRESSCFH_NONE && cfh_steam_flag == PSD_ON )
    {
        setuprfpulse(RF1_CFH_SLOT, _pw_rf1cfh.fixedflag ? (_temp152_pw_rf1cfh=pw_rf1cfh,&_temp152_pw_rf1cfh) : &pw_rf1cfh, _a_rf1cfh.fixedflag ? (_temp153_a_rf1cfh=a_rf1cfh,&_temp153_a_rf1cfh) : &a_rf1cfh, SAR_ABS_SINC3, SAR_PSINC3,
                     SAR_ASINC3, SAR_DTYCYC_SINC3, SAR_MAXPW_SINC3, 1,
                     MAX_B1_SINC3_90, MAX_INT_B1_SQ_SINC3_90,
                     MAX_RMS_B1_SINC3_90, 90.0, _flip_rf1cfh.fixedflag ? (_temp154_flip_rf1cfh=flip_rf1cfh,&_temp154_flip_rf1cfh) : &flip_rf1cfh, 3200.0,
                     3750, PSD_CFH_ON, 0,
                     0, 0, _res_rf1cfh.fixedflag ? (_temp155_res_rf1cfh=res_rf1cfh,&_temp155_res_rf1cfh) : &res_rf1cfh, 0, _wg_rf1cfh.fixedflag ? (_temp156_wg_rf1cfh=wg_rf1cfh,&_temp156_wg_rf1cfh) : &wg_rf1cfh, 1, rfpulse);

        setuprfpulse(RF2_CFH_SLOT, _pw_rf2cfh.fixedflag ? (_temp157_pw_rf2cfh=pw_rf2cfh,&_temp157_pw_rf2cfh) : &pw_rf2cfh, _a_rf2cfh.fixedflag ? (_temp158_a_rf2cfh=a_rf2cfh,&_temp158_a_rf2cfh) : &a_rf2cfh, SAR_ABS_SINC3, SAR_PSINC3,
                     SAR_ASINC3, SAR_DTYCYC_SINC3, SAR_MAXPW_SINC3, 1,
                     MAX_B1_SINC3_90, MAX_INT_B1_SQ_SINC3_90,
                     MAX_RMS_B1_SINC3_90, 90.0, _flip_rf2cfh.fixedflag ? (_temp159_flip_rf2cfh=flip_rf2cfh,&_temp159_flip_rf2cfh) : &flip_rf2cfh, 3200.0,
                     3750, PSD_CFH_ON, 0,
                     0, 0, _res_rf2cfh.fixedflag ? (_temp160_res_rf2cfh=res_rf2cfh,&_temp160_res_rf2cfh) : &res_rf2cfh, 0, _wg_rf2cfh.fixedflag ? (_temp161_wg_rf2cfh=wg_rf2cfh,&_temp161_wg_rf2cfh) : &wg_rf2cfh, 1, rfpulse);

        setuprfpulse(RF3_CFH_SLOT, _pw_rf3cfh.fixedflag ? (_temp162_pw_rf3cfh=pw_rf3cfh,&_temp162_pw_rf3cfh) : &pw_rf3cfh, _a_rf3cfh.fixedflag ? (_temp163_a_rf3cfh=a_rf3cfh,&_temp163_a_rf3cfh) : &a_rf3cfh, SAR_ABS_SINC3, SAR_PSINC3,
                     SAR_ASINC3, SAR_DTYCYC_SINC3, SAR_MAXPW_SINC3, 1,
                     MAX_B1_SINC3_90, MAX_INT_B1_SQ_SINC3_90,
                     MAX_RMS_B1_SINC3_90, 90.0, _flip_rf3cfh.fixedflag ? (_temp164_flip_rf3cfh=flip_rf3cfh,&_temp164_flip_rf3cfh) : &flip_rf3cfh, 3200.0,
                     3750, PSD_CFH_ON, 0,
                     0, 0, _res_rf3cfh.fixedflag ? (_temp165_res_rf3cfh=res_rf3cfh,&_temp165_res_rf3cfh) : &res_rf3cfh, 0, _wg_rf3cfh.fixedflag ? (_temp166_wg_rf3cfh=wg_rf3cfh,&_temp166_wg_rf3cfh) : &wg_rf3cfh, 1, rfpulse);

        setuprfpulse(RF4_CFH_SLOT, _pw_rf4cfh.fixedflag ? (_temp167_pw_rf4cfh=pw_rf4cfh,&_temp167_pw_rf4cfh) : &pw_rf4cfh, _a_rf4cfh.fixedflag ? (_temp168_a_rf4cfh=a_rf4cfh,&_temp168_a_rf4cfh) : &a_rf4cfh, SAR_ABS_SINC3, SAR_PSINC3,
                     SAR_ASINC3, SAR_DTYCYC_SINC3, SAR_MAXPW_SINC3, 1,
                     MAX_B1_SINC3_90, MAX_INT_B1_SQ_SINC3_90,
                     MAX_RMS_B1_SINC3_90, 90.0, _flip_rf4cfh.fixedflag ? (_temp169_flip_rf4cfh=flip_rf4cfh,&_temp169_flip_rf4cfh) : &flip_rf4cfh, 3200.0,
                     3750, PSD_CFH_ON, 0,
                     0, 0, _res_rf4cfh.fixedflag ? (_temp170_res_rf4cfh=res_rf4cfh,&_temp170_res_rf4cfh) : &res_rf4cfh, 0, _wg_rf4cfh.fixedflag ? (_temp171_wg_rf4cfh=wg_rf4cfh,&_temp171_wg_rf4cfh) : &wg_rf4cfh, 1, rfpulse);

        a_rf0cfh  = _a_rf0cfh.fixedflag ?  ((void)(1), a_rf0cfh) : 1;
        a_rf1cfh  = _a_rf1cfh.fixedflag ?  ((void)(0.5464), a_rf1cfh) : 0.5464;
        a_rf2cfh  = _a_rf2cfh.fixedflag ?  ((void)(0.5464), a_rf2cfh) : 0.5464;
        a_rf3cfh  = _a_rf3cfh.fixedflag ?  ((void)(0.5464), a_rf3cfh) : 0.5464; 
        a_rf4cfh  = _a_rf4cfh.fixedflag ?  ((void)(0.5464), a_rf4cfh) : 0.5464; 

        flip_rf1cfh  = _flip_rf1cfh.fixedflag ?  ((void)(60), flip_rf1cfh) : 60;
        flip_rf2cfh  = _flip_rf2cfh.fixedflag ?  ((void)(60), flip_rf2cfh) : 60;
        flip_rf3cfh  = _flip_rf3cfh.fixedflag ?  ((void)(60), flip_rf3cfh) : 60; 
        flip_rf4cfh  = _flip_rf4cfh.fixedflag ?  ((void)(60), flip_rf4cfh) : 60; 

        cyc_rf1cfh  = _cyc_rf1cfh.fixedflag ?  ((void)(3), cyc_rf1cfh) : 3;
        cyc_rf2cfh  = _cyc_rf2cfh.fixedflag ?  ((void)(3), cyc_rf2cfh) : 3;
        cyc_rf3cfh  = _cyc_rf3cfh.fixedflag ?  ((void)(3), cyc_rf3cfh) : 3; 
        cyc_rf4cfh  = _cyc_rf4cfh.fixedflag ?  ((void)(3), cyc_rf4cfh) : 3; 
    }
    else
    {
        setuprfpulse(RF1_CFH_SLOT, _pw_rf1cfh.fixedflag ? (_temp172_pw_rf1cfh=pw_rf1cfh,&_temp172_pw_rf1cfh) : &pw_rf1cfh, _a_rf1cfh.fixedflag ? (_temp173_a_rf1cfh=a_rf1cfh,&_temp173_a_rf1cfh) : &a_rf1cfh, SAR_ABS_SINC1, SAR_PSINC1,
                     SAR_ASINC1, SAR_DTYCYC_SINC1, SAR_MAXPW_SINC1, 1,
                     MAX_B1_SINC1_90, MAX_INT_B1_SQ_SINC1_90,
                     MAX_RMS_B1_SINC1_90, 90.0, _flip_rf1cfh.fixedflag ? (_temp174_flip_rf1cfh=flip_rf1cfh,&_temp174_flip_rf1cfh) : &flip_rf1cfh, 3200.0,
                     1250, PSD_CFH_ON, 0,
                     0, 0, _res_rf1cfh.fixedflag ? (_temp175_res_rf1cfh=res_rf1cfh,&_temp175_res_rf1cfh) : &res_rf1cfh, 0, _wg_rf1cfh.fixedflag ? (_temp176_wg_rf1cfh=wg_rf1cfh,&_temp176_wg_rf1cfh) : &wg_rf1cfh, 1, rfpulse);

        setuprfpulse(RF2_CFH_SLOT, _pw_rf2cfh.fixedflag ? (_temp177_pw_rf2cfh=pw_rf2cfh,&_temp177_pw_rf2cfh) : &pw_rf2cfh, _a_rf2cfh.fixedflag ? (_temp178_a_rf2cfh=a_rf2cfh,&_temp178_a_rf2cfh) : &a_rf2cfh, SAR_ABS_SINC1, SAR_PSINC1,
                     SAR_ASINC1, SAR_DTYCYC_SINC1, SAR_MAXPW_SINC1, 1,
                     MAX_B1_SINC1_90, MAX_INT_B1_SQ_SINC1_90,
                     MAX_RMS_B1_SINC1_90, 90.0, _flip_rf2cfh.fixedflag ? (_temp179_flip_rf2cfh=flip_rf2cfh,&_temp179_flip_rf2cfh) : &flip_rf2cfh, 3200.0,
                     1250, PSD_CFH_ON, 0,
                     0, 0, _res_rf2cfh.fixedflag ? (_temp180_res_rf2cfh=res_rf2cfh,&_temp180_res_rf2cfh) : &res_rf2cfh, 0, _wg_rf2cfh.fixedflag ? (_temp181_wg_rf2cfh=wg_rf2cfh,&_temp181_wg_rf2cfh) : &wg_rf2cfh, 1, rfpulse);

        setuprfpulse(RF3_CFH_SLOT, _pw_rf3cfh.fixedflag ? (_temp182_pw_rf3cfh=pw_rf3cfh,&_temp182_pw_rf3cfh) : &pw_rf3cfh, _a_rf3cfh.fixedflag ? (_temp183_a_rf3cfh=a_rf3cfh,&_temp183_a_rf3cfh) : &a_rf3cfh, SAR_ABS_SINC1, SAR_PSINC1,
                     SAR_ASINC1, SAR_DTYCYC_SINC1, SAR_MAXPW_SINC1, 1,
                     MAX_B1_SINC1_90, MAX_INT_B1_SQ_SINC1_90,
                     MAX_RMS_B1_SINC1_90, 90.0, _flip_rf3cfh.fixedflag ? (_temp184_flip_rf3cfh=flip_rf3cfh,&_temp184_flip_rf3cfh) : &flip_rf3cfh, 3200.0,
                     1250, PSD_CFH_ON, 0,
                     0, 0, _res_rf3cfh.fixedflag ? (_temp185_res_rf3cfh=res_rf3cfh,&_temp185_res_rf3cfh) : &res_rf3cfh, 0, _wg_rf3cfh.fixedflag ? (_temp186_wg_rf3cfh=wg_rf3cfh,&_temp186_wg_rf3cfh) : &wg_rf3cfh, 1, rfpulse);

        setuprfpulse(RF4_CFH_SLOT, _pw_rf4cfh.fixedflag ? (_temp187_pw_rf4cfh=pw_rf4cfh,&_temp187_pw_rf4cfh) : &pw_rf4cfh, _a_rf4cfh.fixedflag ? (_temp188_a_rf4cfh=a_rf4cfh,&_temp188_a_rf4cfh) : &a_rf4cfh, SAR_ABS_SINC1, SAR_PSINC1,
                     SAR_ASINC1, SAR_DTYCYC_SINC1, SAR_MAXPW_SINC1, 1,
                     MAX_B1_SINC1_90, MAX_INT_B1_SQ_SINC1_90,
                     MAX_RMS_B1_SINC1_90, 90.0, _flip_rf4cfh.fixedflag ? (_temp189_flip_rf4cfh=flip_rf4cfh,&_temp189_flip_rf4cfh) : &flip_rf4cfh, 3200.0,
                     1250, PSD_CFH_ON, 0,
                     0, 0, _res_rf4cfh.fixedflag ? (_temp190_res_rf4cfh=res_rf4cfh,&_temp190_res_rf4cfh) : &res_rf4cfh, 0, _wg_rf4cfh.fixedflag ? (_temp191_wg_rf4cfh=wg_rf4cfh,&_temp191_wg_rf4cfh) : &wg_rf4cfh, 1, rfpulse);

        a_rf0cfh  = _a_rf0cfh.fixedflag ?  ((void)(0.61), a_rf0cfh) : 0.61;
        a_rf1cfh  = _a_rf1cfh.fixedflag ?  ((void)(0.5), a_rf1cfh) : 0.5;
        a_rf2cfh  = _a_rf2cfh.fixedflag ?  ((void)(1.0), a_rf2cfh) : 1.0;
        a_rf3cfh  = _a_rf3cfh.fixedflag ?  ((void)(1.0), a_rf3cfh) : 1.0; 
        a_rf4cfh  = _a_rf4cfh.fixedflag ?  ((void)(1.0), a_rf4cfh) : 1.0; 

        flip_rf1cfh  = _flip_rf1cfh.fixedflag ?  ((void)(90), flip_rf1cfh) : 90;
        flip_rf2cfh  = _flip_rf2cfh.fixedflag ?  ((void)(180), flip_rf2cfh) : 180;
        flip_rf3cfh  = _flip_rf3cfh.fixedflag ?  ((void)(180), flip_rf3cfh) : 180; 
        flip_rf4cfh  = _flip_rf4cfh.fixedflag ?  ((void)(180), flip_rf4cfh) : 180; 

        cyc_rf1cfh  = _cyc_rf1cfh.fixedflag ?  ((void)(1), cyc_rf1cfh) : 1;
        cyc_rf2cfh  = _cyc_rf2cfh.fixedflag ?  ((void)(1), cyc_rf2cfh) : 1;
        cyc_rf3cfh  = _cyc_rf3cfh.fixedflag ?  ((void)(1), cyc_rf3cfh) : 1; 
        cyc_rf4cfh  = _cyc_rf4cfh.fixedflag ?  ((void)(1), cyc_rf4cfh) : 1; 

    }

    if( presscfh_ctrl == PRESSCFH_SLICE || presscfh_ctrl == PRESSCFH_SLAB ) 
    {
        /* it is assumed: 
         * (a) cubicle local shim volume 
         */

        FLOAT av;
        FLOAT dxv, dyv, dzv, dxs, dys, dzs, dxs0, dys0, dzs0; 
        FLOAT Dz=0.0;
        FLOAT al2=0.0;
        FLOAT al=0.0;
        FLOAT dxl=0.0;
        FLOAT dyl=0.0;
        FLOAT dzl=0.0;
        FLOAT rs[9], rv[9], rstrv[9];
        INT ii, vidx;
       
        for( vidx = 0; vidx < exist(oppscvquant); vidx ++ )
        {
            av = (psc_info[vidx].oppsclenx)/2.0;
            dxv = psc_info[vidx].oppscrloc;
            dyv = psc_info[vidx].oppscphasoff;
            dzv = psc_info[vidx].oppsctloc;

            dxs = scan_info[PSslice_num].oprloc    + scan_info[PSslice_num].oprloc_shift;
            dys = scan_info[PSslice_num].opphasoff + scan_info[PSslice_num].opphasoff_shift;
            dzs = scan_info[PSslice_num].optloc    + scan_info[PSslice_num].optloc_shift;

            for( ii = 0; ii < 9; ii++ )
            {
                rs[ii] = scan_info[PSslice_num].oprot[ii];
                rv[ii] = psc_info[vidx].oppscrot[ii];
            }

            for( ii = 0; ii < 9; ii++ )
            {
                int ir, ic;
                ir = ii/ 3;
                ic = ii % 3;
                rstrv[ii] = rs[3*0+ir]*rv[3*0+ic] 
                    + rs[3*1+ir]*rv[3*1+ic] 
                    + rs[3*2+ir]*rv[3*2+ic]; 
            }

            if( presscfh_debug )
            {
                printf("rot for shim volume %d\n", vidx);
                printf("%8.2f %8.2f %8.2f\n", rv[0], rv[3], rv[6]);
                printf("%8.2f %8.2f %8.2f\n", rv[1], rv[4], rv[7]);
                printf("%8.2f %8.2f %8.2f\n", rv[2], rv[5], rv[8]);
                printf("rot for slice\n");
                printf("%8.2f %8.2f %8.2f\n", rs[0], rs[3], rs[6]);
                printf("%8.2f %8.2f %8.2f\n", rs[1], rs[4], rs[7]);
                printf("%8.2f %8.2f %8.2f\n", rs[2], rs[5], rs[8]);
            }

            dxs0 = rstrv[0]*dxv + rstrv[1]*dyv + rstrv[2]*dzv;
            dys0 = rstrv[3]*dxv + rstrv[4]*dyv + rstrv[5]*dzv;
            dzs0 = rstrv[6]*dxv + rstrv[7]*dyv + rstrv[8]*dzv;

            if( presscfh == PRESSCFH_SLICE ) 
            {
                presscfh_slthick  = _presscfh_slthick.fixedflag ?  ((void)(opthickPS), presscfh_slthick) : opthickPS;
                if( fabs(dzs0 - dzs) >= av )
                {
                    presscfh_outrange  = _presscfh_outrange.fixedflag ?  ((void)(1), presscfh_outrange) : 1;
                } else {
                    presscfh_outrange  = _presscfh_outrange.fixedflag ?  ((void)(0), presscfh_outrange) : 0;
                }
            } 
            else 
            {   /* presscfh == PRESSCFH_SLAB */
                FLOAT dzss, dzse, dzs0s, dzs0e;
                FLOAT dz1, dz2;
                dzss = scan_info[0].optloc + scan_info[0].optloc_shift;
                dzse = scan_info[opslquant*opvquant-1].optloc + scan_info[opslquant*opvquant-1].optloc_shift;
                dzs0s = dzs0 - av/2;
                dzs0e = dzs0 + av/2;

                /* find dz1 and dz2 */
                if( dzs0e - dzs0s < 0 ) 
                {
                    FLOAT temp;
                    temp = dzs0e;
                    dzs0e = dzs0s;
                    dzs0s = temp;
                }
                if( dzse - dzss < 0 ) 
                {
                    FLOAT temp;
                    temp = dzse;
                    dzse = dzss;
                    dzss = temp;
                }

                dz1 = dzs0s;
                dz2 = dzs0e;

                if( dzss > dz1 ) 
                { 
                    dz1 = dzss;
                }
                if( dzse < dz2 ) 
                {
                    dz2 = dzse;
                }

                if( dzss >= dz2 || dzse <= dz1 ) 
                {
                    presscfh_outrange  = _presscfh_outrange.fixedflag ?  ((void)(1), presscfh_outrange) : 1;
                }
                else
                {
                    dzs = dz1 + (dz2-dz1)/2;   
                    presscfh_slthick  = _presscfh_slthick.fixedflag ?  ((void)(presscfh_slab_ratio*(dz2-dz1)), presscfh_slthick) : presscfh_slab_ratio*(dz2-dz1);
                    if( presscfh_slthick < opthickPS ) 
                    {
                        presscfh_slthick  = _presscfh_slthick.fixedflag ?  ((void)(opthickPS), presscfh_slthick) : opthickPS;
                    }
                    presscfh_outrange  = _presscfh_outrange.fixedflag ?  ((void)(0), presscfh_outrange) : 0;
                }         
            }

            if( presscfh_outrange == 0 ) 
            {
                Dz = dzs0 - dzs;
                al2 = av*av - Dz*Dz;
                if( al2 > 0 ) 
                {
                    al = sqrt(al2);
                } else {
                    al = 0;
                }
            }

            if( al >= presscfh_minfov_ratio*av ) 
            {
                dxl = dxs0;
                dyl = dys0;
                dzl = dzs;

                presscfh_fov  = _presscfh_fov.fixedflag ?  ((void)(presscfh_fov_ratio*al*2.0), presscfh_fov) : presscfh_fov_ratio*al*2.0;
                presscfh_pfov  = _presscfh_pfov.fixedflag ?  ((void)(presscfh_pfov_ratio*al*2.0), presscfh_pfov) : presscfh_pfov_ratio*al*2.0;

                presscfh_info[vidx].oppsctloc = dzl;
                presscfh_info[vidx].oppscrloc = dxl;
                presscfh_info[vidx].oppscphasoff = dyl;
                for( ii = 0; ii < 9; ii++ ) 
                {
                    presscfh_info[vidx].oppscrot[ii] = scan_info[PSslice_num].oprot[ii]; 
                }
                presscfh_info[vidx].oppsclenx = (INT)(presscfh_fov_ratio*al*2.0);
                presscfh_info[vidx].oppscleny = (INT)(presscfh_pfov_ratio*al*2.0);
                presscfh_info[vidx].oppsclenz = (INT)presscfh_slthick;
            } 
            else 
            {
                presscfh_outrange  = _presscfh_outrange.fixedflag ?  ((void)(1), presscfh_outrange) : 1;
            }

            if( presscfh_debug ) 
            {
                printf("av, dxv, dyv, dzv: %8.2f, %8.2f, %8.2f, %8.2f\n", av, dxv, dyv, dzv);    
                printf("dxs, dys, dzs: %8.2f, %8.2f, %8.2f\n", dxs, dys, dzs);    
                printf("al, dxl, dyl, dzl: %8.2f, %8.2f, %8.2f, %8.2f\n", al, dxl, dyl, dzl);    
                printf("presscfh_slthick: %8.2f\n", presscfh_slthick);    
                printf("outrange: %d\n", presscfh_outrange);    
            }

            if( presscfh_outrange == 1 ) 
            {
                cvoverride(presscfh_ctrl, PRESSCFH_NONE, PSD_FIX_ON, PSD_EXIST_ON); 
                if(presscfh_debug) 
                {
                    printf("\nCFHcveval : THIS TURNS OUT TO BE PRESSCFH_NONE,but was initially %d\n",presscfh);
                    fflush(stdout);
                }
                break;
            }
        }
    } 

    if( (presscfh_ctrl == PRESSCFH_SHIMVOL ) || (presscfh_ctrl == PRESSCFH_SHIMVOL_SLICE ) )
    {
        INT vidx = 0;
        for( vidx = 0; vidx < exist(oppscvquant); vidx ++ )
        {
            presscfh_fov  = _presscfh_fov.fixedflag ?    ((void)(presscfh_fov_ratio*psc_info[vidx].oppsclenx), presscfh_fov) : presscfh_fov_ratio*psc_info[vidx].oppsclenx;
            presscfh_pfov  = _presscfh_pfov.fixedflag ?    ((void)(presscfh_pfov_ratio*psc_info[vidx].oppscleny), presscfh_pfov) : presscfh_pfov_ratio*psc_info[vidx].oppscleny;
            presscfh_slthick  = _presscfh_slthick.fixedflag ?    ((void)(presscfh_slab_ratio*psc_info[vidx].oppsclenz), presscfh_slthick) : presscfh_slab_ratio*psc_info[vidx].oppsclenz;

            /* if shim vol info hasn't sent to PSD yet */
            if(presscfh_slthick <= 0.0 || presscfh_fov <= 0.0 || presscfh_pfov <=0.0)
            {
                presscfh_slthick  = _presscfh_slthick.fixedflag ?  ((void)(opthickPS), presscfh_slthick) : opthickPS; 
                presscfh_fov  = _presscfh_fov.fixedflag ?  ((void)(100.0), presscfh_fov) : 100.0; 
                presscfh_pfov  = _presscfh_pfov.fixedflag ?  ((void)(presscfh_fov), presscfh_pfov) : presscfh_fov; 
            }

            presscfh_info[vidx].oppsclenx = (INT)(presscfh_fov);
            presscfh_info[vidx].oppscleny = (INT)(presscfh_pfov);
            presscfh_info[vidx].oppsclenz = (INT)(presscfh_slthick);

            if( presscfh_debug ) 
            {
                printf(": SHIM VOLUME %d; presscfh= %d; presscfh_fov=%8.2f, presscfh_slthick=%8.2f, opthickPS=%8.2f \n",
                       vidx, presscfh_ctrl, presscfh_fov, presscfh_slthick, opthickPS);
                fflush(stdout);
            }
        }
    }

    if( presscfh_ctrl != PRESSCFH_NONE ) 
    {
        INT vidx = 0;
        for( vidx = 0; vidx < exist(oppscvquant); vidx ++ )
        {
            if( presscfh_fov < presscfh_info[vidx].oppsclenx )
            {
                presscfh_fov  = _presscfh_fov.fixedflag ?  ((void)(presscfh_info[vidx].oppsclenx), presscfh_fov) : presscfh_info[vidx].oppsclenx;
            }
            if( presscfh_pfov < presscfh_info[vidx].oppscleny )
            {
                presscfh_pfov  = _presscfh_pfov.fixedflag ?  ((void)(presscfh_info[vidx].oppscleny), presscfh_pfov) : presscfh_info[vidx].oppscleny;
            }
            if( presscfh_slthick < presscfh_info[vidx].oppsclenz )
            {
                presscfh_slthick  = _presscfh_slthick.fixedflag ?  ((void)(presscfh_info[vidx].oppsclenz), presscfh_slthick) : presscfh_info[vidx].oppsclenz;
            }

            if( presscfh_ctrl == PRESSCFH_SHIMVOL_SLICE )
            {
                if( presscfh_slice < opthickPS )
                {
                    presscfh_slice  = _presscfh_slice.fixedflag ?  ((void)(opthickPS), presscfh_slice) : opthickPS;
                }
            }
        }

        presscfh_ir_slthick  = _presscfh_ir_slthick.fixedflag ?  ((void)(presscfh_slthick), presscfh_ir_slthick) : presscfh_slthick;

        rfpulse[RF3_CFH_SLOT].num = 1;
        rfpulse[RF3_CFH_SLOT].activity = PSD_CFH_ON;

        if(presscfh_ctrl == PRESSCFH_SHIMVOL_SLICE )
        {
            presscfh_slice  = _presscfh_slice.fixedflag ?  ((void)(opthickPS), presscfh_slice) : opthickPS;

            rfpulse[RF4_CFH_SLOT].num = 1;
            rfpulse[RF4_CFH_SLOT].activity = PSD_CFH_ON;
        }
        else
        {
            rfpulse[RF4_CFH_SLOT].num = 0; 
            rfpulse[RF4_CFH_SLOT].activity = PSD_PULSE_OFF;
        }
    }
    else
    {
        rfpulse[RF3_CFH_SLOT].num = 0;
        rfpulse[RF3_CFH_SLOT].activity = PSD_PULSE_OFF;

        rfpulse[RF4_CFH_SLOT].num = 0; 
        rfpulse[RF4_CFH_SLOT].activity = PSD_PULSE_OFF;
    }

    /* If inversion recovery image mode, Calcs for the Inversion pulse */
    if (PSD_ON == PSir)
    {
        res_rf0cfh  = _res_rf0cfh.fixedflag ?  ((void)(RES_SH_ADIABATIC), res_rf0cfh) : RES_SH_ADIABATIC;  /* Adiabatic pulse */
        /* MRIge90312 -- use 1.5sec TR for IR cfh */
        cfh_tr  = _cfh_tr.fixedflag ?  ((void)(1500000), cfh_tr) : 1500000;
        gscale_rf0cfh  = _gscale_rf0cfh.fixedflag ?  ((void)(0.87), gscale_rf0cfh) : 0.87; /* Changed from .65 to .87 for adiabatic pulse */

        pw_gzrf0cfh    = _pw_gzrf0cfh.fixedflag ?  ((void)(pw_rf0cfh), pw_gzrf0cfh) : pw_rf0cfh;

        /* Y Killer CVs */ /* YMSmr09211  04/26/2006 YI */
        if(amppwgrad(cfhir_killer_area, cfhloggrd.ty_yz, 0.0, 0.0, cfhloggrd.yrt,
                     MIN_PLATEAU_TIME, _a_gyrf0kcfh.fixedflag ? (_temp192_a_gyrf0kcfh=a_gyrf0kcfh,&_temp192_a_gyrf0kcfh) : &a_gyrf0kcfh, _pw_gyrf0kcfha.fixedflag ? (_temp193_pw_gyrf0kcfha=pw_gyrf0kcfha,&_temp193_pw_gyrf0kcfha) : &pw_gyrf0kcfha, _pw_gyrf0kcfh.fixedflag ? (_temp194_pw_gyrf0kcfh=pw_gyrf0kcfh,&_temp194_pw_gyrf0kcfh) : &pw_gyrf0kcfh, _pw_gyrf0kcfhd.fixedflag ? (_temp195_pw_gyrf0kcfhd=pw_gyrf0kcfhd,&_temp195_pw_gyrf0kcfhd) : &pw_gyrf0kcfhd) == FAILURE) 
        {
            epic_error(use_ermes, "%s failed in PScveval.", EM_PSD_SUPPORT_FAILURE,
                       EE_ARGS(1), STRING_ARG, "amppwgrad:gyrf0kcfh"); 
            return FAILURE;
        }

        rfpulse[RF0_CFH_SLOT].num = 1;
        rfpulse[RF0_CFH_SLOT].activity = PSD_CFH_ON;
        bw_rf0cfh = (LONG)(5.12*cyc_rf0cfh/((FLOAT)pw_rf0cfh/(FLOAT)1000000)); /* adiabatic pulse */
 
        if(ampslice(_a_gzrf0cfh.fixedflag ? (_temp196_a_gzrf0cfh=a_gzrf0cfh,&_temp196_a_gzrf0cfh) : &a_gzrf0cfh, bw_rf0cfh, ((presscfh_ctrl == PRESSCFH_NONE) ? opthickPS : presscfh_ir_slthick),
                    gscale_rf0cfh, TYPDEF) == FAILURE) 
        {
            epic_error(use_ermes, "%s failed for gzrf0cfh.",EM_PSD_SUPPORT_FAILURE, 
                       EE_ARGS(1), STRING_ARG, "ampslice");
            return FAILURE;
        }
        /* Non Selective IR */
        if( (presscfh_ctrl != PRESSCFH_NONE) && presscfh_ir_noselect ) 
        {
            a_gzrf0cfh  = _a_gzrf0cfh.fixedflag ?  ((void)(0), a_gzrf0cfh) : 0;
        }
        /* YMSmr09211  04/26/2006 YI */
        if(optramp(_pw_gzrf0cfha.fixedflag ? (_temp197_pw_gzrf0cfha=pw_gzrf0cfha,&_temp197_pw_gzrf0cfha) : &pw_gzrf0cfha,a_gzrf0cfh, cfhloggrd.tz, cfhloggrd.zrt, TYPDEF)==FAILURE) 
        {
            epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                       STRING_ARG, "optramp for gzrf0cfha.");
            return FAILURE;
        }
        pw_gzrf0cfhd  = _pw_gzrf0cfhd.fixedflag ?  ((void)(pw_gzrf0cfha), pw_gzrf0cfhd) : pw_gzrf0cfha;
    } else {
        cfh_tr  = _cfh_tr.fixedflag ?  ((void)(398000), cfh_tr) : 398000;
        rfpulse[RF0_CFH_SLOT].num = 0;
        rfpulse[RF0_CFH_SLOT].activity = PSD_PULSE_OFF;
    }

    /* Calculations for the 90 pulse */
    pw_gzrf1cfh  = _pw_gzrf1cfh.fixedflag ?  ((void)(pw_rf1cfh), pw_gzrf1cfh) : pw_rf1cfh;
    bw_rf1cfh = (LONG)(rfpulse[RF1_CFH_SLOT].nom_bw*rfpulse[RF1_CFH_SLOT].nom_pw/(float)pw_rf1cfh);
       
    if (ampslice(_a_gzrf1cfh.fixedflag ? (_temp198_a_gzrf1cfh=a_gzrf1cfh,&_temp198_a_gzrf1cfh) : &a_gzrf1cfh, bw_rf1cfh, ( (presscfh_ctrl == PRESSCFH_NONE) ? opthickPS : presscfh_slthick),
                 gscale_rf1cfh, TYPDEF) == FAILURE) 
    {
        epic_error(use_ermes, "%s failed for gzrf1cfh.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "ampslice");
        return FAILURE;
    }

    /* YMSmr09211  04/26/2006 YI */
    if (optramp(_pw_gzrf1cfha.fixedflag ? (_temp199_pw_gzrf1cfha=pw_gzrf1cfha,&_temp199_pw_gzrf1cfha) : &pw_gzrf1cfha, a_gzrf1cfh, cfhloggrd.tz, cfhloggrd.zrt, TYPDEF) == FAILURE) 
    {
        epic_error(use_ermes, "%s failed for gzrf1cfh.", 
                   EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "optramp");
        return FAILURE;
    }

    pw_gzrf1cfhd  = _pw_gzrf1cfhd.fixedflag ?  ((void)(pw_gzrf1cfha), pw_gzrf1cfhd) : pw_gzrf1cfha;

    /* Calculations for the 180 pulse */
    /* Have to rely on the PSD to keep these up to date - can't tell from
       here whether or not the PSD is a mempoid. */
    pw_gxrf2cfh  = _pw_gxrf2cfh.fixedflag ?  ((void)(pw_rf2cfh), pw_gxrf2cfh) : pw_rf2cfh;
    pw_gyrf2cfh  = _pw_gyrf2cfh.fixedflag ?  ((void)(pw_rf2cfh), pw_gyrf2cfh) : pw_rf2cfh;
    pw_gyrf3cfh  = _pw_gyrf3cfh.fixedflag ?  ((void)(pw_rf3cfh), pw_gyrf3cfh) : pw_rf3cfh; /* for presscfh */
    pw_gzrf4cfh  = _pw_gzrf4cfh.fixedflag ?  ((void)(pw_rf4cfh), pw_gzrf4cfh) : pw_rf4cfh; /* for presscfh-slice */ 

    /* Find amplitudes for the FOV selective traps */
    if (opcoax==1) 
    {
        /* If coaxial through isocenter */
        cfh_fov  = _cfh_fov.fixedflag ?    ((void)(FMin(2,40.0,opfov/10.0)), cfh_fov) : FMin(2,40.0,opfov/10.0);
    } else {
        /* Otherwise open it up */
        cfh_fov  = _cfh_fov.fixedflag ?  ((void)(40.0), cfh_fov) : 40.0;
    }

    if(cfh_newmode) 
    {   /*override with new mode*/
        float cfh_new_fov = opspf ? (opphasefov*opfov/10.0) : (opfov/10.0);

        cfh_fov  = _cfh_fov.fixedflag ?    ((void)(FMin(2,40.0,cfh_new_fov)), cfh_fov) : FMin(2,40.0,cfh_new_fov);
        /* For non-coaxials (multi angle), center cfh_rf2freq and up the
           excitation region to 40 cm to cover lots of ground */
        cfh_fov  = _cfh_fov.fixedflag ?        ((void)((opcoax==0)?40.0:FMax(2,(float)FOV_MIN,cfh_fov)), cfh_fov) : (opcoax==0)?40.0:FMax(2,(float)FOV_MIN,cfh_fov);
    }

    if( presscfh_ctrl != PRESSCFH_NONE ) 
    {
        /* X FOV Selective */ /* YMSmr09211  04/26/2006 YI */
        a_gxrf2cfh  = _a_gxrf2cfh.fixedflag ?  ((void)(4*cyc_rf2cfh/(GAM*(float)pw_rf2cfh/(float)(1000000)*presscfh_fov/10.0)), a_gxrf2cfh) : 4*cyc_rf2cfh/(GAM*(float)pw_rf2cfh/(float)(1000000)*presscfh_fov/10.0);
        if (optramp(_pw_gxrf2cfha.fixedflag ? (_temp200_pw_gxrf2cfha=pw_gxrf2cfha,&_temp200_pw_gxrf2cfha) : &pw_gxrf2cfha, a_gxrf2cfh, cfhloggrd.tx, cfhloggrd.xrt, TYPDEF) == FAILURE) 
        {
            epic_error(use_ermes, "%s failed for gxrf2cfh.", EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                       STRING_ARG, "optramp for gxrf2cfh"); 
            return FAILURE;
        }
        pw_gxrf2cfha  = _pw_gxrf2cfha.fixedflag ?   ((void)(IMax(2,(int)(2*GRAD_UPDATE_TIME),pw_gxrf2cfha)), pw_gxrf2cfha) : IMax(2,(int)(2*GRAD_UPDATE_TIME),pw_gxrf2cfha);
        pw_gxrf2cfhd  = _pw_gxrf2cfhd.fixedflag ?  ((void)(pw_gxrf2cfha), pw_gxrf2cfhd) : pw_gxrf2cfha;
        target_cfh_crusher  = _target_cfh_crusher.fixedflag ?  ((void)(cfhloggrd.tz_xz), target_cfh_crusher) : cfhloggrd.tz_xz; /* YMSmr09211  04/26/2006 YI */

        /* Y FOV Selective */ /* YMSmr09211  04/26/2006 YI */
        a_gyrf3cfh  = _a_gyrf3cfh.fixedflag ?  ((void)(4*cyc_rf3cfh/(GAM*(float)pw_rf3cfh/(float)(1000000)*presscfh_pfov/10.0)), a_gyrf3cfh) : 4*cyc_rf3cfh/(GAM*(float)pw_rf3cfh/(float)(1000000)*presscfh_pfov/10.0);
        if (optramp(_pw_gyrf3cfha.fixedflag ? (_temp201_pw_gyrf3cfha=pw_gyrf3cfha,&_temp201_pw_gyrf3cfha) : &pw_gyrf3cfha, a_gyrf3cfh, cfhloggrd.ty, cfhloggrd.yrt, TYPDEF) == FAILURE) 
        {
            epic_error(use_ermes, "%s failed for gyrf3cfh.", EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                       STRING_ARG, "optramp for gyrf3cfh");
            return FAILURE;
        }
        pw_gyrf3cfha  = _pw_gyrf3cfha.fixedflag ?   ((void)(IMax(2,(int)(2*GRAD_UPDATE_TIME),pw_gyrf3cfha)), pw_gyrf3cfha) : IMax(2,(int)(2*GRAD_UPDATE_TIME),pw_gyrf3cfha);
        pw_gyrf3cfhd  = _pw_gyrf3cfhd.fixedflag ?  ((void)(pw_gyrf3cfha), pw_gyrf3cfhd) : pw_gyrf3cfha;
        target_cfh_crusher2  = _target_cfh_crusher2.fixedflag ?  ((void)(cfhloggrd.tz_yz), target_cfh_crusher2) : cfhloggrd.tz_yz; /* YMSmr09211  04/26/2006 YI */

        if( presscfh_ctrl == PRESSCFH_SHIMVOL_SLICE )
        {
            /* Z SLICE Selective */
            a_gzrf4cfh  = _a_gzrf4cfh.fixedflag ?  ((void)(4*cyc_rf4cfh/(GAM*(float)pw_rf4cfh/(float)(1000000)*presscfh_slice/10.0)), a_gzrf4cfh) : 4*cyc_rf4cfh/(GAM*(float)pw_rf4cfh/(float)(1000000)*presscfh_slice/10.0);
            if (optramp(_pw_gzrf4cfha.fixedflag ? (_temp202_pw_gzrf4cfha=pw_gzrf4cfha,&_temp202_pw_gzrf4cfha) : &pw_gzrf4cfha, a_gzrf4cfh, loggrd.tz, loggrd.zrt, TYPDEF) == FAILURE) 
            {
                epic_error(use_ermes, "%s failed for gzrf4cfh.", EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                           STRING_ARG, "optramp for gzrf4cfh");
                return FAILURE;
            }
            pw_gzrf4cfha  = _pw_gzrf4cfha.fixedflag ?   ((void)(IMax(2,(int)(2*GRAD_UPDATE_TIME),pw_gzrf4cfha)), pw_gzrf4cfha) : IMax(2,(int)(2*GRAD_UPDATE_TIME),pw_gzrf4cfha);
            pw_gzrf4cfhd  = _pw_gzrf4cfhd.fixedflag ?  ((void)(pw_gzrf4cfha), pw_gzrf4cfhd) : pw_gzrf4cfha;
        }

        if( cfh_steam_flag != PSD_ON )
        {
            /* Z CRUSHER CVs */ /* YMSmr09211  04/26/2006 YI */
            if (amppwgrad(cfh_crusher_area, target_cfh_crusher, 0.0, 0.0, cfhloggrd.zrt,
                          MIN_PLATEAU_TIME, _a_gzrf2rcfh.fixedflag ? (_temp203_a_gzrf2rcfh=a_gzrf2rcfh,&_temp203_a_gzrf2rcfh) : &a_gzrf2rcfh, _pw_gzrf2rcfha.fixedflag ? (_temp204_pw_gzrf2rcfha=pw_gzrf2rcfha,&_temp204_pw_gzrf2rcfha) : &pw_gzrf2rcfha,
                          _pw_gzrf2rcfh.fixedflag ? (_temp205_pw_gzrf2rcfh=pw_gzrf2rcfh,&_temp205_pw_gzrf2rcfh) : &pw_gzrf2rcfh, _pw_gzrf2rcfhd.fixedflag ? (_temp206_pw_gzrf2rcfhd=pw_gzrf2rcfhd,&_temp206_pw_gzrf2rcfhd) : &pw_gzrf2rcfhd) == FAILURE) 
            {
                epic_error(use_ermes, "%s failed in PScveval.",
                           EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                           STRING_ARG, "amppwgrad:gzrf2rcfh"); 
                return FAILURE;
            }
            pw_gzrf2lcfha  = _pw_gzrf2lcfha.fixedflag ?  ((void)(pw_gzrf2rcfha), pw_gzrf2lcfha) : pw_gzrf2rcfha;
            pw_gzrf2lcfhd  = _pw_gzrf2lcfhd.fixedflag ?  ((void)(pw_gzrf2rcfhd), pw_gzrf2lcfhd) : pw_gzrf2rcfhd;
        }
        else
        {
            if (amppwgrad(cfh_crusher_area, target_cfh_crusher2, 0.0, 0.0, cfhloggrd.zrt,
                          MIN_PLATEAU_TIME, _a_gzrf3rcfh.fixedflag ? (_temp207_a_gzrf3rcfh=a_gzrf3rcfh,&_temp207_a_gzrf3rcfh) : &a_gzrf3rcfh, _pw_gzrf3rcfha.fixedflag ? (_temp208_pw_gzrf3rcfha=pw_gzrf3rcfha,&_temp208_pw_gzrf3rcfha) : &pw_gzrf3rcfha,
                          _pw_gzrf3rcfh.fixedflag ? (_temp209_pw_gzrf3rcfh=pw_gzrf3rcfh,&_temp209_pw_gzrf3rcfh) : &pw_gzrf3rcfh, _pw_gzrf3rcfhd.fixedflag ? (_temp210_pw_gzrf3rcfhd=pw_gzrf3rcfhd,&_temp210_pw_gzrf3rcfhd) : &pw_gzrf3rcfhd) == FAILURE) 
            {
                epic_error(use_ermes, "%s failed in PScveval.",
                           EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                           STRING_ARG, "amppwgrad:gzrf3rcfh"); 
                return FAILURE;
            }
            pw_gzrf2lcfha  = _pw_gzrf2lcfha.fixedflag ?  ((void)(pw_gzrf3rcfha), pw_gzrf2lcfha) : pw_gzrf3rcfha;
            pw_gzrf2lcfhd  = _pw_gzrf2lcfhd.fixedflag ?  ((void)(pw_gzrf3rcfhd), pw_gzrf2lcfhd) : pw_gzrf3rcfhd;
        }

        if( cfh_steam_flag != PSD_ON )
        {
            /* Z CRUSHER CVs */ /* YMSmr09211  04/26/2006 YI */
            if (amppwgrad(cfh_crusher_area, target_cfh_crusher2, 0.0, 0.0, cfhloggrd.zrt,
                          MIN_PLATEAU_TIME, _a_gzrf3rcfh.fixedflag ? (_temp211_a_gzrf3rcfh=a_gzrf3rcfh,&_temp211_a_gzrf3rcfh) : &a_gzrf3rcfh, _pw_gzrf3rcfha.fixedflag ? (_temp212_pw_gzrf3rcfha=pw_gzrf3rcfha,&_temp212_pw_gzrf3rcfha) : &pw_gzrf3rcfha,
                          _pw_gzrf3rcfh.fixedflag ? (_temp213_pw_gzrf3rcfh=pw_gzrf3rcfh,&_temp213_pw_gzrf3rcfh) : &pw_gzrf3rcfh, _pw_gzrf3rcfhd.fixedflag ? (_temp214_pw_gzrf3rcfhd=pw_gzrf3rcfhd,&_temp214_pw_gzrf3rcfhd) : &pw_gzrf3rcfhd) == FAILURE) 
            {
                epic_error(use_ermes, "%s failed in PScveval.", EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                           STRING_ARG, "amppwgrad:gzrf3rcfh"); 
                return FAILURE;
            }

            /* Z CRUSHER CVs */ /* YMSmr09211  04/26/2006 YI */
            if (amppwgrad(cfh_crusher_area, target_cfh_crusher2, 0.0, 0.0, cfhloggrd.zrt,
                          MIN_PLATEAU_TIME, _a_gzrf3lcfh.fixedflag ? (_temp215_a_gzrf3lcfh=a_gzrf3lcfh,&_temp215_a_gzrf3lcfh) : &a_gzrf3lcfh, _pw_gzrf3lcfha.fixedflag ? (_temp216_pw_gzrf3lcfha=pw_gzrf3lcfha,&_temp216_pw_gzrf3lcfha) : &pw_gzrf3lcfha,
                          _pw_gzrf3lcfh.fixedflag ? (_temp217_pw_gzrf3lcfh=pw_gzrf3lcfh,&_temp217_pw_gzrf3lcfh) : &pw_gzrf3lcfh, _pw_gzrf3lcfhd.fixedflag ? (_temp218_pw_gzrf3lcfhd=pw_gzrf3lcfhd,&_temp218_pw_gzrf3lcfhd) : &pw_gzrf3lcfhd) == FAILURE) 
            {
                epic_error(use_ermes, "%s failed in PScveval.", EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                           STRING_ARG, "amppwgrad:gzrf3lcfh"); 
                return FAILURE;
            }

            if( presscfh_ctrl == PRESSCFH_SHIMVOL_SLICE )
            {
                /* Z CRUSHER CVs */ /* YMSmr09211  04/26/2006 YI */
                if (amppwgrad(cfh_crusher_area, target_cfh_crusher2, 0.0, 0.0, cfhloggrd.zrt,
                              MIN_PLATEAU_TIME, _a_gzrf4rcfh.fixedflag ? (_temp219_a_gzrf4rcfh=a_gzrf4rcfh,&_temp219_a_gzrf4rcfh) : &a_gzrf4rcfh, _pw_gzrf4rcfha.fixedflag ? (_temp220_pw_gzrf4rcfha=pw_gzrf4rcfha,&_temp220_pw_gzrf4rcfha) : &pw_gzrf4rcfha,
                              _pw_gzrf4rcfh.fixedflag ? (_temp221_pw_gzrf4rcfh=pw_gzrf4rcfh,&_temp221_pw_gzrf4rcfh) : &pw_gzrf4rcfh, _pw_gzrf4rcfhd.fixedflag ? (_temp222_pw_gzrf4rcfhd=pw_gzrf4rcfhd,&_temp222_pw_gzrf4rcfhd) : &pw_gzrf4rcfhd) == FAILURE) 
                {
                    epic_error(use_ermes, "%s failed in PScveval.", EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                              STRING_ARG, "amppwgrad:gzrf4rcfh"); 
                    return FAILURE;
                }

                /* Z CRUSHER CVs */ /* YMSmr09211  04/26/2006 YI */
                if (amppwgrad(cfh_crusher_area, target_cfh_crusher2, 0.0, 0.0, cfhloggrd.zrt,
                              MIN_PLATEAU_TIME, _a_gzrf4lcfh.fixedflag ? (_temp223_a_gzrf4lcfh=a_gzrf4lcfh,&_temp223_a_gzrf4lcfh) : &a_gzrf4lcfh, _pw_gzrf4lcfha.fixedflag ? (_temp224_pw_gzrf4lcfha=pw_gzrf4lcfha,&_temp224_pw_gzrf4lcfha) : &pw_gzrf4lcfha,
                              _pw_gzrf4lcfh.fixedflag ? (_temp225_pw_gzrf4lcfh=pw_gzrf4lcfh,&_temp225_pw_gzrf4lcfh) : &pw_gzrf4lcfh, _pw_gzrf4lcfhd.fixedflag ? (_temp226_pw_gzrf4lcfhd=pw_gzrf4lcfhd,&_temp226_pw_gzrf4lcfhd) : &pw_gzrf4lcfhd) == FAILURE) 
                {
                    epic_error(use_ermes, "%s failed in PScveval.", EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                               STRING_ARG, "amppwgrad:gzrf4lcfh"); 
                    return FAILURE;
                }
            }
        }
        else
        {
            if (amppwgrad(cfh_crusher_area, target_cfh_crusher, 0.0, 0.0, cfhloggrd.zrt,
                          MIN_PLATEAU_TIME, _a_gzrf2rcfh.fixedflag ? (_temp227_a_gzrf2rcfh=a_gzrf2rcfh,&_temp227_a_gzrf2rcfh) : &a_gzrf2rcfh, _pw_gzrf2rcfha.fixedflag ? (_temp228_pw_gzrf2rcfha=pw_gzrf2rcfha,&_temp228_pw_gzrf2rcfha) : &pw_gzrf2rcfha,
                          _pw_gzrf2rcfh.fixedflag ? (_temp229_pw_gzrf2rcfh=pw_gzrf2rcfh,&_temp229_pw_gzrf2rcfh) : &pw_gzrf2rcfh, _pw_gzrf2rcfhd.fixedflag ? (_temp230_pw_gzrf2rcfhd=pw_gzrf2rcfhd,&_temp230_pw_gzrf2rcfhd) : &pw_gzrf2rcfhd) == FAILURE) 
            {
                epic_error(use_ermes, "%s failed in PScveval.", EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                           STRING_ARG, "amppwgrad:gzrf2rcfh"); 
                return FAILURE;
            }

            if (amppwgrad(cfh_crusher_area, target_cfh_crusher2, 0.0, 0.0, cfhloggrd.zrt,
                          MIN_PLATEAU_TIME, _a_gzrf3lcfh.fixedflag ? (_temp231_a_gzrf3lcfh=a_gzrf3lcfh,&_temp231_a_gzrf3lcfh) : &a_gzrf3lcfh, _pw_gzrf3lcfha.fixedflag ? (_temp232_pw_gzrf3lcfha=pw_gzrf3lcfha,&_temp232_pw_gzrf3lcfha) : &pw_gzrf3lcfha,
                          _pw_gzrf3lcfh.fixedflag ? (_temp233_pw_gzrf3lcfh=pw_gzrf3lcfh,&_temp233_pw_gzrf3lcfh) : &pw_gzrf3lcfh, _pw_gzrf3lcfhd.fixedflag ? (_temp234_pw_gzrf3lcfhd=pw_gzrf3lcfhd,&_temp234_pw_gzrf3lcfhd) : &pw_gzrf3lcfhd) == FAILURE) 
            {
                epic_error(use_ermes, "%s failed in PScveval.", EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                           STRING_ARG, "amppwgrad:gzrf3lcfh"); 
                return FAILURE;
            }
        }
    } else {
        if (opspf == 0) 
        {
            /* X FOV Selective */ /* YMSmr09211  04/26/2006 YI */
            a_gxrf2cfh  = _a_gxrf2cfh.fixedflag ?  ((void)(4*cyc_rf2cfh/(GAM*(float)pw_rf2cfh/(float)(1000000)*cfh_fov)), a_gxrf2cfh) : 4*cyc_rf2cfh/(GAM*(float)pw_rf2cfh/(float)(1000000)*cfh_fov);
            if (optramp(_pw_gxrf2cfha.fixedflag ? (_temp235_pw_gxrf2cfha=pw_gxrf2cfha,&_temp235_pw_gxrf2cfha) : &pw_gxrf2cfha, a_gxrf2cfh, cfhloggrd.tx, cfhloggrd.xrt, TYPDEF) == FAILURE) 
            {
                epic_error(use_ermes, "%s failed for gxrf2cfh.", 
                           EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                           STRING_ARG, "optramp for gxrf2cfh");
                return FAILURE;
            }
            pw_gxrf2cfha  = _pw_gxrf2cfha.fixedflag ?   ((void)(IMax(2,(int)(2*GRAD_UPDATE_TIME),pw_gxrf2cfha)), pw_gxrf2cfha) : IMax(2,(int)(2*GRAD_UPDATE_TIME),pw_gxrf2cfha);
            pw_gxrf2cfhd  = _pw_gxrf2cfhd.fixedflag ?  ((void)(pw_gxrf2cfha), pw_gxrf2cfhd) : pw_gxrf2cfha;
            target_cfh_crusher  = _target_cfh_crusher.fixedflag ?  ((void)(cfhloggrd.tz_xz), target_cfh_crusher) : cfhloggrd.tz_xz; /* YMSmr09211  04/26/2006 YI */
        } 
        else 
        {
            /* Y FOV Selective */ /* YMSmr09211  04/26/2006 YI */
            a_gyrf2cfh  = _a_gyrf2cfh.fixedflag ?  ((void)(4*cyc_rf2cfh/(GAM*(float)pw_rf2cfh/(float)(1000000)*cfh_fov)), a_gyrf2cfh) : 4*cyc_rf2cfh/(GAM*(float)pw_rf2cfh/(float)(1000000)*cfh_fov);
            if (optramp(_pw_gyrf2cfha.fixedflag ? (_temp236_pw_gyrf2cfha=pw_gyrf2cfha,&_temp236_pw_gyrf2cfha) : &pw_gyrf2cfha, a_gyrf2cfh, cfhloggrd.ty, cfhloggrd.yrt, TYPDEF) == FAILURE) 
            {
                epic_error(use_ermes, "%s failed for gyrf2cfh.", EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                           STRING_ARG, "optramp for gyrf2cfh");
                return FAILURE;
            }
            pw_gyrf2cfha  = _pw_gyrf2cfha.fixedflag ?   ((void)(IMax(2,(int)(2*GRAD_UPDATE_TIME),pw_gyrf2cfha)), pw_gyrf2cfha) : IMax(2,(int)(2*GRAD_UPDATE_TIME),pw_gyrf2cfha);
            pw_gyrf2cfhd  = _pw_gyrf2cfhd.fixedflag ?  ((void)(pw_gyrf2cfha), pw_gyrf2cfhd) : pw_gyrf2cfha;
            target_cfh_crusher  = _target_cfh_crusher.fixedflag ?  ((void)(cfhloggrd.tz_yz), target_cfh_crusher) : cfhloggrd.tz_yz; /* YMSmr09211  04/26/2006 YI */
        }

        /* Z CRUSHER CVs */ /* YMSmr09211  04/26/2006 YI */
        if (amppwgrad(cfh_crusher_area, target_cfh_crusher, 0.0, 0.0, cfhloggrd.zrt,
                      MIN_PLATEAU_TIME, _a_gzrf2rcfh.fixedflag ? (_temp237_a_gzrf2rcfh=a_gzrf2rcfh,&_temp237_a_gzrf2rcfh) : &a_gzrf2rcfh, _pw_gzrf2rcfha.fixedflag ? (_temp238_pw_gzrf2rcfha=pw_gzrf2rcfha,&_temp238_pw_gzrf2rcfha) : &pw_gzrf2rcfha,
                      _pw_gzrf2rcfh.fixedflag ? (_temp239_pw_gzrf2rcfh=pw_gzrf2rcfh,&_temp239_pw_gzrf2rcfh) : &pw_gzrf2rcfh, _pw_gzrf2rcfhd.fixedflag ? (_temp240_pw_gzrf2rcfhd=pw_gzrf2rcfhd,&_temp240_pw_gzrf2rcfhd) : &pw_gzrf2rcfhd) == FAILURE) 
        {
            epic_error(use_ermes, "%s failed in PScveval.",
                       EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                       STRING_ARG, "amppwgrad:gzrf2rcfh"); 
            return FAILURE;
        }

        pw_gzrf2lcfha  = _pw_gzrf2lcfha.fixedflag ?  ((void)(pw_gzrf2rcfha), pw_gzrf2lcfha) : pw_gzrf2rcfha;
        pw_gzrf2lcfhd  = _pw_gzrf2lcfhd.fixedflag ?  ((void)(pw_gzrf2rcfhd), pw_gzrf2lcfhd) : pw_gzrf2rcfhd;
    }

    area_gz1cfh = (PSoff90 + pw_rf1cfh/2.0 + pw_gzrf1cfhd/2.0)*a_gzrf1cfh;
    /* YMSmr09211  04/26/2006 YI */
    if (amppwlcrsh(&psd_cfhleftcrush, &psd_cfhrightcrush,
                   area_gz1cfh, (float)0, cfhloggrd.tz_xz, 
                   MIN_PLATEAU_TIME, cfhloggrd.zrt, _dummy_pw.fixedflag ? (_temp241_dummy_pw=dummy_pw,&_temp241_dummy_pw) : &dummy_pw) == FAILURE) 
    {
        epic_error(use_ermes, "%s failed in cfh.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwlcrsh for gzrf2lcfh");
        return FAILURE;
    }

    if( presscfh_ctrl != PRESSCFH_NONE && cfh_steam_flag == PSD_ON )
    {
        FLOAT area_g1 = (pw_gxrf2cfh + pw_gxrf2cfha)*a_gxrf2cfh/2.0; 
        if (amppwgrad(area_g1, cfhloggrd.tx, 0.0, 0.0, cfhloggrd.xrt,
                      MIN_PLATEAU_TIME, _a_gx1cfh.fixedflag ? (_temp242_a_gx1cfh=a_gx1cfh,&_temp242_a_gx1cfh) : &a_gx1cfh, _pw_gx1cfha.fixedflag ? (_temp243_pw_gx1cfha=pw_gx1cfha,&_temp243_pw_gx1cfha) : &pw_gx1cfha,
                      _pw_gx1cfh.fixedflag ? (_temp244_pw_gx1cfh=pw_gx1cfh,&_temp244_pw_gx1cfh) : &pw_gx1cfh, _pw_gx1cfhd.fixedflag ? (_temp245_pw_gx1cfhd=pw_gx1cfhd,&_temp245_pw_gx1cfhd) : &pw_gx1cfhd) == FAILURE) 
        {
            epic_error(use_ermes, "%s failed in PScveval.",
                       EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                       STRING_ARG, "amppwgrad:gx1cfh"); 
            return FAILURE;
        }

        area_g1 = (pw_gyrf3cfh + pw_gyrf3cfhd)*a_gyrf3cfh/2.0; 
        if (amppwgrad(area_g1, cfhloggrd.ty, 0.0, 0.0, cfhloggrd.yrt,
                      MIN_PLATEAU_TIME, _a_gy1cfh.fixedflag ? (_temp246_a_gy1cfh=a_gy1cfh,&_temp246_a_gy1cfh) : &a_gy1cfh, _pw_gy1cfha.fixedflag ? (_temp247_pw_gy1cfha=pw_gy1cfha,&_temp247_pw_gy1cfha) : &pw_gy1cfha,
                      _pw_gy1cfh.fixedflag ? (_temp248_pw_gy1cfh=pw_gy1cfh,&_temp248_pw_gy1cfh) : &pw_gy1cfh, _pw_gy1cfhd.fixedflag ? (_temp249_pw_gy1cfhd=pw_gy1cfhd,&_temp249_pw_gy1cfhd) : &pw_gy1cfhd) == FAILURE) 
        {
            epic_error(use_ermes, "%s failed in PScveval.",
                       EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                       STRING_ARG, "amppwgrad:gy1cfh"); 
            return FAILURE;
        }
    }

    /* Find Params for killer pulse */ /* YMSmr09211  04/26/2006 YI */
    area_gykcfh  = _area_gykcfh.fixedflag ?  ((void)(amp_killer*pw_killer), area_gykcfh) : amp_killer*pw_killer;
    if (amppwgrad(area_gykcfh, cfhloggrd.ty, 0.0, 0.0, cfhloggrd.yrt,
                  MIN_PLATEAU_TIME, _a_gykcfh.fixedflag ? (_temp250_a_gykcfh=a_gykcfh,&_temp250_a_gykcfh) : &a_gykcfh, _pw_gykcfha.fixedflag ? (_temp251_pw_gykcfha=pw_gykcfha,&_temp251_pw_gykcfha) : &pw_gykcfha,
                  _pw_gykcfh.fixedflag ? (_temp252_pw_gykcfh=pw_gykcfh,&_temp252_pw_gykcfh) : &pw_gykcfh, _pw_gykcfhd.fixedflag ? (_temp253_pw_gykcfhd=pw_gykcfhd,&_temp253_pw_gykcfhd) : &pw_gykcfhd) == FAILURE) 
    {
        epic_error(use_ermes, "%s failed in cfh.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgrad:gykcfh");
        return FAILURE;
    }
    return SUCCESS;
}

/*
 *  PScveval
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
PScveval( void )
{
    STATUS ps_status;
    FLOAT opthickPS;
    INT i,j; /* YMSmr09211  04/26/2006 YI */
    INT num_cfhlocs;

    /*********************************************************************
     * Generic SECTION
     *********************************************************************/
   
    /* Set the modes for presscfh */
    set_presscfh_mode();

    /* YMSmr09211  04/26/2006 YI */
    if( ( presscfh_ctrl == PRESSCFH_SHIMVOL ) || ( presscfh_ctrl == PRESSCFH_SHIMVOL_SLICE ) )
    {
        num_cfhlocs = exist(oppscvquant);
        for (i=0; i< num_cfhlocs; i++)
        {
            for (j=0; j<9; j++)
            {
                cfh_info[i].oprot[j] = psc_info[i].oppscrot[j];
            }
        }
    }
    else
    {
        num_cfhlocs = IMax(2, 1, exist(oppscvquant));
        for (i=0; i< num_cfhlocs; i++)
        {
            for (j=0; j<9; j++)
            {
                cfh_info[i].oprot[j] = scan_info[PSslice_num].oprot[j];
            }
        }
    }

    cfh_newgeo  = _cfh_newgeo.fixedflag ?  ((void)(1), cfh_newgeo) : 1;
    if (obloptimize(&cfhloggrd, &phygrd, cfh_info, num_cfhlocs,
                    PSD_OBL, 0, obl_method, cfhobl_debug, _cfh_newgeo.fixedflag ? (_temp254_cfh_newgeo=cfh_newgeo,&_temp254_cfh_newgeo) : &cfh_newgeo, cfsrmode)==FAILURE)
    {
        epic_error(use_ermes,"%s failed in %s",
                   EM_PSD_FUNCTION_FAILURE,EE_ARGS(2),STRING_ARG,"obloptimize",STRING_ARG,"PScveval()");
        return FAILURE; 

    }

    /* derate SR for quiet PSC */ 
    sr_derate(&cfhloggrd, PSsr_derate_factor, PSamp_derate_factor);

    if (opimode == PSD_3D)  
    {
        opthickPS = 10.0;
    } 
    else 
    {
            opthickPS = (exist(opslthick) < 3.5) ? 3.5 : exist(opslthick);
        }

    /***********************************************************************
     * MPS1/APS1 SECTION
     ***********************************************************************/

    if ( SUCCESS != (ps_status = PS1cveval( &opthickPS )) ) {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "PS1cveval");
        return ps_status;
    }

    /***********************************************************************
     * CFL SECTION
     ***********************************************************************/

    if ( SUCCESS != (ps_status = CFLcveval( opthickPS )) ) {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "CFLcveval");
        return ps_status;
    }

    /***********************************************************************
     * RCVN SECTION
     ***********************************************************************/

    if ( SUCCESS != (ps_status = RCVNcveval( )) ) {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "RCVNcveval");
        return ps_status;
    }

    /***********************************************************************
     * CFH SECTION
     ***********************************************************************/

    if ( SUCCESS != (ps_status = CFHcveval( opthickPS )) ) {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "CFHcveval");
        return ps_status;
    }

    /***********************************************************************
     * Programmable Prescan SECTION
     ***********************************************************************/

    /* Check for valid Optprescan entry points */
    if(pimrsapsflg) {
        int ipi;
        char strmrs[16] = "pimrsaps1";

        for (ipi = 0; ipi < PSC_MAX_CONTROL_ARRAY; ipi++) 
        {
            switch(*pimrs[ipi]) 
            {
            case MRSAPS_OFF: case MRSAPS_CFL: case MRSAPS_TG:
            case MRSAPS_CFH: case MRSAPS_TR: case MRSAPS_FSEPS:
            case MRSAPS_AWS: case MRSAPS_AVS: case MRSAPS_XTG:
            case MRSAPS_AS: case MRSAPS_FTG: case MRSAPS_RCVN:
            case MRSAPS_XTG_SPINE:
            case MRSAPS_RFSHIM: case MRSAPS_DYNTG:
            case MRSAPS_CAL: case MRSAPS_AUTOCOIL:
                break;
            default:
                sprintf(strmrs, "pimrsaps%d", ipi + 1);
                epic_error(use_ermes, "%s is out of range.",
                           EM_PSD_CV_OUT_OF_RANGE, EE_ARGS(1),
                           STRING_ARG, strmrs);
                return FAILURE;
            }
        }
    } /* end pimrsapsflg check */

    return SUCCESS;
}   /* end PScveval() */


/*
 *  FTGcveval
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
FTGcveval( void )
{
    LONG bw_rf1ftg;
    LONG bw_rf2ftg;
    LONG bw_rf3ftg;
    FLOAT area_g1ftg;
    FLOAT area_g2ftg;
    FLOAT area_g2bftg;
    FLOAT area_g3ftg;
    FLOAT area_postgxw1ftg;
    FLOAT area_gxw1ftg;
    FLOAT area_gx1ftg;
    FLOAT area_gx2ftg;
    INT ftg_xrt;
    FLOAT ftg_tx;
    FLOAT ftg_tx_xz;
    FLOAT ftg_tz_xz;
    FLOAT ftg_tx_xyz;
    INT FTGtau1check1, FTGtau1check2, FTGtau1check3,
        FTGtau1check4, FTGtau1check5, FTGtau1check6, temp_FTGtau1;

    /* HCSDM00161809: for calculation of minimum FTGtau1 */
    FTGtau1  = _FTGtau1.fixedflag ?    ((void)(8192), FTGtau1) : 8192;
    FTGtau1check1   = FTGtau1;
    FTGtau1check2   = FTGtau1;
    FTGtau1check3   = FTGtau1;
    FTGtau1check4   = FTGtau1;
    FTGtau1check5   = FTGtau1;
    FTGtau1check6   = FTGtau1;
    temp_FTGtau1    = FTGtau1;
    
    ftg_xrt = (TGspf ? ps1loggrd.yrt : ps1loggrd.xrt);
    ftg_tx = (TGspf ? ps1loggrd.ty : ps1loggrd.tx);
    ftg_tx_xz = (TGspf ? ps1loggrd.ty_yz : ps1loggrd.tx_xz);
    ftg_tz_xz = (TGspf ? ps1loggrd.tz_yz : ps1loggrd.tz_xz);
    ftg_tx_xyz = (TGspf ? ps1loggrd.ty_xyz : ps1loggrd.tx_xyz);

    FTGfov  = _FTGfov.fixedflag ?  ((void)(cfsystemmaxfov), FTGfov) : cfsystemmaxfov;

    FTGopslthickz1  = _FTGopslthickz1.fixedflag ?  ((void)(4*FTGslthk), FTGopslthickz1) : 4*FTGslthk;
    FTGopslthickz2  = _FTGopslthickz2.fixedflag ?  ((void)(4*FTGslthk), FTGopslthickz2) : 4*FTGslthk;
    FTGopslthickz3  = _FTGopslthickz3.fixedflag ?  ((void)(FTGslthk), FTGopslthickz3) : FTGslthk;
    gscale_rf1ftg   = _gscale_rf1ftg.fixedflag ?  ((void)(0.90909), gscale_rf1ftg) : 0.90909;
    gscale_rf2ftg   = _gscale_rf2ftg.fixedflag ?  ((void)(gscale_rf1ftg), gscale_rf2ftg) : gscale_rf1ftg;
    gscale_rf3ftg   = _gscale_rf3ftg.fixedflag ?  ((void)(gscale_rf1ftg), gscale_rf3ftg) : gscale_rf1ftg;
    pw_gzrf1ftg  = _pw_gzrf1ftg.fixedflag ?  ((void)(pw_rf1ftg), pw_gzrf1ftg) : pw_rf1ftg;
    pw_gzrf2ftg  = _pw_gzrf2ftg.fixedflag ?  ((void)(pw_rf2ftg), pw_gzrf2ftg) : pw_rf2ftg;
    pw_gzrf3ftg  = _pw_gzrf3ftg.fixedflag ?  ((void)(pw_rf3ftg), pw_gzrf3ftg) : pw_rf3ftg;

    /* 12/07/94 YI temporary change to avoid internal error with Vectra SGC coil */
    if( cfgradcoil == GCOIL_VECTRA )
    {
        FTGopslthickz3  = _FTGopslthickz3.fixedflag ?  ((void)(7), FTGopslthickz3) : 7;
    }
    
    bw_rf1ftg = (LONG)(4 * cyc_rf1ftg/ ((FLOAT)pw_rf1ftg/ (FLOAT)1000000));

    if( !existcv(FTGtau2) )
    {
        FTGtau2  = _FTGtau2.fixedflag ?  ((void)((int)(exist(FTGtau1)*exist(FTGau))), FTGtau2) : (int)(exist(FTGtau1)*exist(FTGau));
    }

    if( ampslice(_a_gzrf1ftg.fixedflag ? (_temp255_a_gzrf1ftg=a_gzrf1ftg,&_temp255_a_gzrf1ftg) : &a_gzrf1ftg, bw_rf1ftg, FTGopslthickz1, gscale_rf1ftg, TYPDEF)
        == FAILURE )
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "ampslice for gzrf1ftg.");
        return FAILURE;
    }
    
    bw_rf2ftg = (LONG)(4 * cyc_rf2ftg/ ((FLOAT)pw_rf2ftg/ (FLOAT)1000000));
 
    if( ampslice(_a_gzrf2ftg.fixedflag ? (_temp256_a_gzrf2ftg=a_gzrf2ftg,&_temp256_a_gzrf2ftg) : &a_gzrf2ftg, bw_rf2ftg, FTGopslthickz2, gscale_rf2ftg, TYPDEF)
        == FAILURE )
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "ampslice for gzrf2ftg.");
        return FAILURE;
    }
    
 
    bw_rf3ftg = (LONG)(4 * cyc_rf3ftg/ ((FLOAT)pw_rf3ftg/ (FLOAT)1000000));
 
    if( ampslice(_a_gzrf3ftg.fixedflag ? (_temp257_a_gzrf3ftg=a_gzrf3ftg,&_temp257_a_gzrf3ftg) : &a_gzrf3ftg, bw_rf3ftg, FTGopslthickz3, gscale_rf3ftg, TYPDEF)
        == FAILURE ) {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "ampslice for gzrf3ftg.");
        return FAILURE;
    }
    if( optramp(_pw_gzrf1ftga.fixedflag ? (_temp258_pw_gzrf1ftga=pw_gzrf1ftga,&_temp258_pw_gzrf1ftga) : &pw_gzrf1ftga, a_gzrf1ftg, ps1loggrd.tz, ps1loggrd.zrt, TYPDEF)
        == FAILURE ) {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "optramp for gzrf1ftga.");
        return FAILURE;
    }    
    
    pw_gzrf1ftgd  = _pw_gzrf1ftgd.fixedflag ?  ((void)(pw_gzrf1ftga), pw_gzrf1ftgd) : pw_gzrf1ftga;

    if (optramp(_pw_gzrf2ftga.fixedflag ? (_temp259_pw_gzrf2ftga=pw_gzrf2ftga,&_temp259_pw_gzrf2ftga) : &pw_gzrf2ftga, a_gzrf2ftg, ps1loggrd.tz, ps1loggrd.zrt, TYPDEF)
        == FAILURE) {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "optramp for gzrf2ftga.");
        return FAILURE;
    }    
    
    pw_gzrf2ftgd  = _pw_gzrf2ftgd.fixedflag ?  ((void)(pw_gzrf2ftga), pw_gzrf2ftgd) : pw_gzrf2ftga;
 
 
    /* Find Params for first zgrad refocusing pulse */
    area_g1ftg = ( a_gzrf1ftg *.5* ( pw_gzrf1ftg + pw_gzrf1ftgd)
                   + a_gzrf2ftg *.5 * (pw_gzrf2ftga + pw_gzrf2ftg) );
    if( amppwgz1(_a_gz1ftg.fixedflag ? (_temp260_a_gz1ftg=a_gz1ftg,&_temp260_a_gz1ftg) : &a_gz1ftg, _pw_gz1ftg.fixedflag ? (_temp261_pw_gz1ftg=pw_gz1ftg,&_temp261_pw_gz1ftg) : &pw_gz1ftg, _pw_gz1ftga.fixedflag ? (_temp262_pw_gz1ftga=pw_gz1ftga,&_temp262_pw_gz1ftga) : &pw_gz1ftga, _pw_gz1ftgd.fixedflag ? (_temp263_pw_gz1ftgd=pw_gz1ftgd,&_temp263_pw_gz1ftgd) : &pw_gz1ftgd,
                 area_g1ftg, (INT)1000000, MIN_PLATEAU_TIME,
                 ps1loggrd.zrt, ps1loggrd.tz) == FAILURE ) {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgz1 for gz1ftg.");
        return FAILURE;
    }
    

    /* Find Params for refocusing pulse gz2ftg */
    area_g2ftg =  a_gzrf2ftg *.5* ( pw_gzrf2ftg + pw_gzrf2ftgd);
    if( amppwgz1(_a_gz2ftg.fixedflag ? (_temp264_a_gz2ftg=a_gz2ftg,&_temp264_a_gz2ftg) : &a_gz2ftg, _pw_gz2ftg.fixedflag ? (_temp265_pw_gz2ftg=pw_gz2ftg,&_temp265_pw_gz2ftg) : &pw_gz2ftg, _pw_gz2ftga.fixedflag ? (_temp266_pw_gz2ftga=pw_gz2ftga,&_temp266_pw_gz2ftga) : &pw_gz2ftga, _pw_gz2ftgd.fixedflag ? (_temp267_pw_gz2ftgd=pw_gz2ftgd,&_temp267_pw_gz2ftgd) : &pw_gz2ftgd,
                 area_g2ftg, (INT)1000000, MIN_PLATEAU_TIME,
                 ps1loggrd.zrt, ftg_tz_xz) == FAILURE ) {
	epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgz1 for gz2ftg.");
	return FAILURE;
    }
 
    /* Find Params for refocusing pulse gz2btg */

    /* MRIge56170  AF  10/13/99 */
    if( optramp(_pw_gzrf3ftga.fixedflag ? (_temp268_pw_gzrf3ftga=pw_gzrf3ftga,&_temp268_pw_gzrf3ftga) : &pw_gzrf3ftga, a_gzrf3ftg, ps1loggrd.tz, ps1loggrd.zrt, TYPDEF)
        == FAILURE ) {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "optramp for gzrf3ftga.");
        return FAILURE;
    }

    area_g2bftg =  a_gzrf3ftg * .5 *(pw_gzrf3ftga + pw_gzrf3ftg);
    if( amppwgz1(_a_gz2bftg.fixedflag ? (_temp269_a_gz2bftg=a_gz2bftg,&_temp269_a_gz2bftg) : &a_gz2bftg, _pw_gz2bftg.fixedflag ? (_temp270_pw_gz2bftg=pw_gz2bftg,&_temp270_pw_gz2bftg) : &pw_gz2bftg, _pw_gz2bftga.fixedflag ? (_temp271_pw_gz2bftga=pw_gz2bftga,&_temp271_pw_gz2bftga) : &pw_gz2bftga, _pw_gz2bftgd.fixedflag ? (_temp272_pw_gz2bftgd=pw_gz2bftgd,&_temp272_pw_gz2bftgd) : &pw_gz2bftgd,
                 area_g2bftg, (INT)1000000, MIN_PLATEAU_TIME,
                 ps1loggrd.zrt, ps1loggrd.tz) == FAILURE ) {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, ":amppwgz1 for gz2bftg.");
        return FAILURE;
    }
    
    pw_gzrf3ftgd  = _pw_gzrf3ftgd.fixedflag ?  ((void)(pw_gzrf3ftga), pw_gzrf3ftgd) : pw_gzrf3ftga;
 
    /* Find Params for refocusing pulse */
    area_g3ftg =  a_gzrf3ftg *.5* ( pw_gzrf3ftg + pw_gzrf3ftgd);
    if( amppwgz1(_a_gz3ftg.fixedflag ? (_temp273_a_gz3ftg=a_gz3ftg,&_temp273_a_gz3ftg) : &a_gz3ftg, _pw_gz3ftg.fixedflag ? (_temp274_pw_gz3ftg=pw_gz3ftg,&_temp274_pw_gz3ftg) : &pw_gz3ftg, _pw_gz3ftga.fixedflag ? (_temp275_pw_gz3ftga=pw_gz3ftga,&_temp275_pw_gz3ftga) : &pw_gz3ftga, _pw_gz3ftgd.fixedflag ? (_temp276_pw_gz3ftgd=pw_gz3ftgd,&_temp276_pw_gz3ftgd) : &pw_gz3ftgd,
                 area_g3ftg, (INT)1000000, MIN_PLATEAU_TIME,
                 ps1loggrd.zrt, ftg_tz_xz) == FAILURE )
    {

        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgz1 for gz3ftg.");
        return FAILURE;
    }
    
    if( calcfilter( &echo1ftg_filt, FTGecho1bw, FTGxres, OVERWRITE_NONE)
        == FAILURE ) {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1),STRING_ARG,"calcfilter for echo1ftg_filt");
        return FAILURE;
    }

    if( ampfov(_a_gxw1ftg.fixedflag ? (_temp277_a_gxw1ftg=a_gxw1ftg,&_temp277_a_gxw1ftg) : &a_gxw1ftg, echo1ftg_filt.bw, FTGfov) == FAILURE )
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "ampfov for gxw1ftg.");
        return FAILURE;
 
    }
 
    pw_gxw1ftg  = _pw_gxw1ftg.fixedflag ?  ((void)(RUP_GRD((int)(echo1ftg_filt.tdaq)/4)), pw_gxw1ftg) : RUP_GRD((int)(echo1ftg_filt.tdaq)/4);

    area_gxw1ftg = 2.0*a_gxw1ftg*(float)(pw_gxw1ftg);
 
    if( amppwgx1(_a_gx1ftg.fixedflag ? (_temp278_a_gx1ftg=a_gx1ftg,&_temp278_a_gx1ftg) : &a_gx1ftg, _pw_gx1ftg.fixedflag ? (_temp279_pw_gx1ftg=pw_gx1ftg,&_temp279_pw_gx1ftg) : &pw_gx1ftg, _pw_gx1ftga.fixedflag ? (_temp280_pw_gx1ftga=pw_gx1ftga,&_temp280_pw_gx1ftga) : &pw_gx1ftga, _pw_gx1ftgd.fixedflag ? (_temp281_pw_gx1ftgd=pw_gx1ftgd,&_temp281_pw_gx1ftgd) : &pw_gx1ftgd,
                 TYPSPIN, area_gxw1ftg, .0,
                 (int)1000000, 1.0, MIN_PLATEAU_TIME,
                 ftg_xrt, ftg_tx_xz) == FAILURE )
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgx1 for gx1ftg.");
        return FAILURE;
    }
    
    if( amppwgx1(_a_gx2test.fixedflag ? (_temp282_a_gx2test=a_gx2test,&_temp282_a_gx2test) : &a_gx2test, _pw_gx2test.fixedflag ? (_temp283_pw_gx2test=pw_gx2test,&_temp283_pw_gx2test) : &pw_gx2test, _pw_gx2testa.fixedflag ? (_temp284_pw_gx2testa=pw_gx2testa,&_temp284_pw_gx2testa) : &pw_gx2testa, _pw_gx2testd.fixedflag ? (_temp285_pw_gx2testd=pw_gx2testd,&_temp285_pw_gx2testd) : &pw_gx2testd,
                 TYPSPIN, area_gxw1ftg, .0,
                 (int)1000000, 1.0, MIN_PLATEAU_TIME,
                 ftg_xrt, ftg_tx_xz) == FAILURE )
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgx1 for gx1ftg.");

        return FAILURE;
    }
    
 
    area_gxw1ftg = a_gxw1ftg*(float)(pw_gxw1ftg);
    if( amppwgx1(_a_gx1bftg.fixedflag ? (_temp286_a_gx1bftg=a_gx1bftg,&_temp286_a_gx1bftg) : &a_gx1bftg, _pw_gx1bftg.fixedflag ? (_temp287_pw_gx1bftg=pw_gx1bftg,&_temp287_pw_gx1bftg) : &pw_gx1bftg, _pw_gx1bftga.fixedflag ? (_temp288_pw_gx1bftga=pw_gx1bftga,&_temp288_pw_gx1bftga) : &pw_gx1bftga, _pw_gx1bftgd.fixedflag ? (_temp289_pw_gx1bftgd=pw_gx1bftgd,&_temp289_pw_gx1bftgd) : &pw_gx1bftgd,
                 TYPSPIN, area_gxw1ftg, .0,
                 (int)1000000, 1.0, MIN_PLATEAU_TIME,
                 ftg_xrt, ftg_tx_xyz) == FAILURE )
    {
        epic_error(use_ermes, "%s call failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgx1:gx1btg");
    }

    if( optramp(_pw_gxw1ftga.fixedflag ? (_temp290_pw_gxw1ftga=pw_gxw1ftga,&_temp290_pw_gxw1ftga) : &pw_gxw1ftga, a_gxw1ftg, ftg_tx,
                ftg_xrt, TYPDEF) == FAILURE )
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "optramp for gxw1ftga.");
        return FAILURE;
    }    
    
    pw_gxw1ftgd  = _pw_gxw1ftgd.fixedflag ?  ((void)(pw_gxw1ftga), pw_gxw1ftgd) : pw_gxw1ftga;
 
    area_postgxw1ftg = ( 3.0 * a_gxw1ftg * (float)(pw_gxw1ftg)
                         - 0.5 * a_gxw1ftg * (pw_gxw1ftga + pw_gxw1ftgd) );
    if( amppwgx1(_a_postgxw1ftg.fixedflag ? (_temp291_a_postgxw1ftg=a_postgxw1ftg,&_temp291_a_postgxw1ftg) : &a_postgxw1ftg, _pw_postgxw1ftg.fixedflag ? (_temp292_pw_postgxw1ftg=pw_postgxw1ftg,&_temp292_pw_postgxw1ftg) : &pw_postgxw1ftg, _pw_postgxw1ftga.fixedflag ? (_temp293_pw_postgxw1ftga=pw_postgxw1ftga,&_temp293_pw_postgxw1ftga) : &pw_postgxw1ftga,
                 _pw_postgxw1ftgd.fixedflag ? (_temp294_pw_postgxw1ftgd=pw_postgxw1ftgd,&_temp294_pw_postgxw1ftgd) : &pw_postgxw1ftgd, TYPSPIN, area_postgxw1ftg, .0,
                 (int)1000000, 1.0, MIN_PLATEAU_TIME,
                 ftg_xrt, ftg_tx) == FAILURE )
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgx1 for postgxw1ftg.");
        return FAILURE;
    }
    
    if( ampfov(_a_gxw2ftg.fixedflag ? (_temp295_a_gxw2ftg=a_gxw2ftg,&_temp295_a_gxw2ftg) : &a_gxw2ftg, echo1ftg_filt.bw, FTGfov) == FAILURE )
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "ampfov for gxw2ftg.");
        return FAILURE;
    }
    
    pw_gxw2ftg  = _pw_gxw2ftg.fixedflag ?  ((void)(RUP_GRD((int)(4.0*(float)pw_gxw1ftg))), pw_gxw2ftg) : RUP_GRD((int)(4.0*(float)pw_gxw1ftg));
    if( optramp(_pw_gxw2ftga.fixedflag ? (_temp296_pw_gxw2ftga=pw_gxw2ftga,&_temp296_pw_gxw2ftga) : &pw_gxw2ftga, a_gxw2ftg, ftg_tx,
                ftg_xrt, TYPDEF) == FAILURE )
    { 
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "optramp for gxw2ftga.");
 
        return FAILURE;
    }
    
    pw_gxw2ftgd  = _pw_gxw2ftgd.fixedflag ?  ((void)(pw_gxw2ftga), pw_gxw2ftgd) : pw_gxw2ftga;
 
    /* We want S1 to refocus tau1 ms after rf3.  The gx2tg refocusing
       pulse accomplishes this.  gxw2tg pulse can't start before the
       end of the gz3tg refocussing pulse (why bother collecting
       corrupt data? ). */
    area_gx1ftg = a_gx1ftg * (0.5 * (float)(pw_gx1ftga + pw_gx1ftgd) + pw_gx1ftg);
 
    pw_gxw2ftgleft  = _pw_gxw2ftgleft.fixedflag ?  ((void)(RUP_GRD(echo1ftg_filt.tdaq/8)), pw_gxw2ftgleft) : RUP_GRD(echo1ftg_filt.tdaq/8);   /* 1/8th of readout window to left of S1 */

    area_gx2ftg = area_gx1ftg - a_gxw2ftg * (float)(pw_gxw2ftga/ 2 + pw_gxw2ftgleft);
 
    if( amppwgrad(area_gx2ftg, ftg_tx_xz,
                  0.0, 0.0, ftg_xrt,
                  MIN_PLATEAU_TIME, _a_gx2ftg.fixedflag ? (_temp297_a_gx2ftg=a_gx2ftg,&_temp297_a_gx2ftg) : &a_gx2ftg, _pw_gx2ftga.fixedflag ? (_temp298_pw_gx2ftga=pw_gx2ftga,&_temp298_pw_gx2ftga) : &pw_gx2ftga,
                  _pw_gx2ftg.fixedflag ? (_temp299_pw_gx2ftg=pw_gx2ftg,&_temp299_pw_gx2ftg) : &pw_gx2ftg, _pw_gx2ftgd.fixedflag ? (_temp300_pw_gx2ftgd=pw_gx2ftgd,&_temp300_pw_gx2ftgd) : &pw_gx2ftgd) == FAILURE ) {
        epic_error(use_ermes, "%s failed in fasttg.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgrad:gx2ftg");
        return FAILURE;
    }
   
    if( (pw_rf3ftg/2+pw_gx2ftga+pw_gx2ftg+pw_gx2ftgd+pw_gxw2ftga+pw_gxw2ftgleft
         > FTGtau1) || (pw_rf3ftg/2+pw_gzrf3ftgd+pw_gz3ftga+pw_gz3ftg+pw_gz3ftgd+pw_gxw2ftga+pw_gxw2ftgleft > FTGtau1) )
    {
        /* return FAILURE; */
    }
    
    /* HCSDM00161809: calculate minimum FTGtau1 */
    FTGtau1check1 = RUP_GRD(pw_rf1ftg/2+pw_gx1ftga+pw_gx1ftg+pw_gx1ftgd+pw_rf2ftg/2);
    FTGtau1check2 = RUP_GRD(pw_rf1ftg/2+pw_gzrf1ftgd+pw_gz1ftga+pw_gz1ftg+pw_gz1ftgd+pw_gzrf2ftga+pw_rf2ftg/2);
    FTGtau1check3 = RUP_GRD(pw_rf2ftg/2+pw_gx1bftga+pw_gx1bftg+pw_gx1bftgd+pw_gxw1ftga+pw_gxw1ftg/2);
    FTGtau1check4 = RUP_GRD(pw_rf2ftg/2+pw_gzrf2ftgd+pw_gz2ftga+pw_gz2ftg+pw_gz2ftgd+pw_gxw1ftga+pw_gxw1ftg/2);
    FTGtau1check5 = RUP_GRD(pw_rf3ftg/2+pw_gx2ftga+pw_gx2ftg+pw_gx2ftgd+pw_gxw2ftga+pw_gxw2ftgleft);
    FTGtau1check6 = RUP_GRD(pw_rf3ftg/2+pw_gzrf3ftgd+pw_gz3ftga+pw_gz3ftg+pw_gz3ftgd+pw_gxw2ftga+pw_gxw2ftgleft);

    temp_FTGtau1 = IMax(7, FTGtau1, FTGtau1check1, FTGtau1check2, FTGtau1check3, FTGtau1check4, FTGtau1check5, FTGtau1check6);

    cvoverride(FTGtau1, temp_FTGtau1, PSD_FIX_OFF, PSD_EXIST_ON);

    if( !existcv(FTGtau2) )
    {
        FTGtau2  = _FTGtau2.fixedflag ?  ((void)((int)(exist(FTGtau1)*exist(FTGau))), FTGtau2) : (int)(exist(FTGtau1)*exist(FTGau));
    }

    flip_rf1ftg  = _flip_rf1ftg.fixedflag ?   ((void)(90.0), flip_rf1ftg) : 90.0;
    flip_rf2ftg  = _flip_rf2ftg.fixedflag ?  ((void)(180.0), flip_rf2ftg) : 180.0;
    flip_rf3ftg  = _flip_rf3ftg.fixedflag ?  ((void)(180.0), flip_rf3ftg) : 180.0;
    
    strcpy(entry_point_table[L_FTG].epname, "fasttg");
 
    return SUCCESS;
}   /* end FTGcveval() */


/*
 *  XTGcveval
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
XTGcveval( void )
{
    LONG bw_rf1xtg;
    LONG bw_rf2xtg;
    FLOAT area_g1xtg;
    FLOAT area_gxw1xtg;
    INT ta_180, tb_180;
    FLOAT area_gxw1rampxtg;
    INT xtg_xrt, xtg_yrt;
    FLOAT xtg_tx;
    FLOAT xtg_tx_xyz, xtg_ty_xyz, xtg_tz_xyz;
    FLOAT xtg_temp_float;
    INT XTGspf;
    INT timeBeforeFermi; /* Time before Off resonance Fermi pulse */

    XTGspf = (TGspf && (PSD_OFF == local_tg));
    XTGfov  = _XTGfov.fixedflag ?    ((void)(FMin(2,480.0,cfsystemmaxfov)), XTGfov) : FMin(2,480.0,cfsystemmaxfov);

    if(0 == getAps1Mod())
    {
        XTGfov  = _XTGfov.fixedflag ?    ((void)(FMin(2,opfov,XTGfov)), XTGfov) : FMin(2,opfov,XTGfov);
        XTGfov  = _XTGfov.fixedflag ?    ((void)(FMax(2,XTGfov,MINFOV_TG)), XTGfov) : FMax(2,XTGfov,MINFOV_TG);
    }

    xtg_xrt = (XTGspf ? ps1loggrd.yrt : ps1loggrd.xrt);
    xtg_yrt = (XTGspf ? ps1loggrd.xrt : ps1loggrd.yrt);
    xtg_tx = (XTGspf ? ps1loggrd.ty : ps1loggrd.tx);
    xtg_tz_xyz = ps1loggrd.tz_xyz;
    xtg_tx_xyz = (XTGspf ? ps1loggrd.ty_xyz : ps1loggrd.tx_xyz);
    xtg_ty_xyz = (XTGspf ? ps1loggrd.tx_xyz : ps1loggrd.ty_xyz);

    gscale_rf1xtg   = _gscale_rf1xtg.fixedflag ?  ((void)(0.90909), gscale_rf1xtg) : 0.90909;
    gscale_rf2xtg   = _gscale_rf2xtg.fixedflag ?  ((void)(gscale_rf1xtg), gscale_rf2xtg) : gscale_rf1xtg;

    pw_gzrf2xtg  = _pw_gzrf2xtg.fixedflag ?  ((void)(pw_rf2xtg), pw_gzrf2xtg) : pw_rf2xtg;

    XTGecho1bw  = _XTGecho1bw.fixedflag ?  ((void)(15.625), XTGecho1bw) : 15.625;

    bw_rf1xtg = (LONG)(4 * cyc_rf1xtg/ ((FLOAT)pw_rf1xtg/ (FLOAT)1000000));

    if(PSD_ON == local_tg)
    {
        pw_gyrf1xtg  = _pw_gyrf1xtg.fixedflag ?  ((void)(pw_rf1xtg), pw_gyrf1xtg) : pw_rf1xtg;
        XTGfov  = _XTGfov.fixedflag ?  ((void)(TGopslthickx), XTGfov) : TGopslthickx;

        if( ampslice(_a_gyrf1xtg.fixedflag ? (_temp301_a_gyrf1xtg=a_gyrf1xtg,&_temp301_a_gyrf1xtg) : &a_gyrf1xtg, bw_rf1xtg, TGopslthicky, gscale_rf1xtg, TYPDEF)
            == FAILURE )
        {
            epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                       EE_ARGS(1), STRING_ARG, "ampslice for gyrf1xtg.");
            return FAILURE;
        }

        if( optramp(_pw_gyrf1xtga.fixedflag ? (_temp302_pw_gyrf1xtga=pw_gyrf1xtga,&_temp302_pw_gyrf1xtga) : &pw_gyrf1xtga, a_gyrf1xtg, ps1loggrd.ty, ps1loggrd.yrt, TYPDEF)
            == FAILURE )
        {
            epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                       EE_ARGS(1), STRING_ARG, "optramp for gyrf1xtga.");
            return FAILURE;
        }    

        pw_gyrf1xtgd  = _pw_gyrf1xtgd.fixedflag ?  ((void)(pw_gyrf1xtga), pw_gyrf1xtgd) : pw_gyrf1xtga;

    }
    else
    {
        pw_gzrf1xtg  = _pw_gzrf1xtg.fixedflag ?  ((void)(pw_rf1xtg), pw_gzrf1xtg) : pw_rf1xtg;

        if( ampslice(_a_gzrf1xtg.fixedflag ? (_temp303_a_gzrf1xtg=a_gzrf1xtg,&_temp303_a_gzrf1xtg) : &a_gzrf1xtg, bw_rf1xtg, TGopslthick, gscale_rf1xtg, TYPDEF)
        == FAILURE )
        {
            epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "ampslice for gzrf1xtg.");
            return FAILURE;
        }

        if( optramp(_pw_gzrf1xtga.fixedflag ? (_temp304_pw_gzrf1xtga=pw_gzrf1xtga,&_temp304_pw_gzrf1xtga) : &pw_gzrf1xtga, a_gzrf1xtg, ps1loggrd.tz, ps1loggrd.zrt, TYPDEF)
            == FAILURE )
        {
            epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "optramp for gzrf1xtga.");
            return FAILURE;
        }    

        pw_gzrf1xtgd  = _pw_gzrf1xtgd.fixedflag ?  ((void)(pw_gzrf1xtga), pw_gzrf1xtgd) : pw_gzrf1xtga;

    }

    bw_rf2xtg = (LONG)(4 * cyc_rf2xtg/ ((FLOAT)pw_rf2xtg/ (FLOAT)1000000));

    if( ampslice(_a_gzrf2xtg.fixedflag ? (_temp305_a_gzrf2xtg=a_gzrf2xtg,&_temp305_a_gzrf2xtg) : &a_gzrf2xtg, bw_rf2xtg, TGopslthick, gscale_rf2xtg, TYPDEF)
        == FAILURE )
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "ampslice for gzrf2xtg.");
        return FAILURE;
    }

    if (optramp(_pw_gzrf2xtga.fixedflag ? (_temp306_pw_gzrf2xtga=pw_gzrf2xtga,&_temp306_pw_gzrf2xtga) : &pw_gzrf2xtga, a_gzrf2xtg, ps1loggrd.tz, ps1loggrd.zrt, TYPDEF)
        == FAILURE)
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "optramp for gzrf2xtga.");
        return FAILURE;
    }    

    pw_gzrf2xtgd  = _pw_gzrf2xtgd.fixedflag ?  ((void)(pw_gzrf2xtga), pw_gzrf2xtgd) : pw_gzrf2xtga;

    /* Z CRUSHER CVs */ 
    if(PSD_ON == local_tg)
    {
        area_g1xtg = 0.0;
    }
    else
    {
        area_g1xtg = (PSoff90 + pw_gzrf1xtg/2.0 + pw_gzrf1xtgd/2.0)*a_gzrf1xtg;
    }
    area_xtgzkiller  = _area_xtgzkiller.fixedflag ?  ((void)(amp_killer*pw_killer+area_g1xtg), area_xtgzkiller) : amp_killer*pw_killer+area_g1xtg;
    if (amppwgrad(area_xtgzkiller, xtg_tz_xyz, 0.0, 0.0, ps1loggrd.zrt,
                  MIN_PLATEAU_TIME, _a_gz2xtg.fixedflag ? (_temp307_a_gz2xtg=a_gz2xtg,&_temp307_a_gz2xtg) : &a_gz2xtg, _pw_gz2xtga.fixedflag ? (_temp308_pw_gz2xtga=pw_gz2xtga,&_temp308_pw_gz2xtga) : &pw_gz2xtga,
                  _pw_gz2xtg.fixedflag ? (_temp309_pw_gz2xtg=pw_gz2xtg,&_temp309_pw_gz2xtg) : &pw_gz2xtg, _pw_gz2xtgd.fixedflag ? (_temp310_pw_gz2xtgd=pw_gz2xtgd,&_temp310_pw_gz2xtgd) : &pw_gz2xtgd) == FAILURE)
    {
        epic_error(use_ermes, "%s failed in XTGcveval.",
                   EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                   STRING_ARG, "amppwgrad: gz2xtg"); 
        return FAILURE;
    }

    if (amppwgrad((area_xtgzkiller-area_g1xtg), xtg_tz_xyz, 0.0, 0.0, ps1loggrd.zrt,
                  MIN_PLATEAU_TIME, _a_gz1xtg.fixedflag ? (_temp311_a_gz1xtg=a_gz1xtg,&_temp311_a_gz1xtg) : &a_gz1xtg, _pw_gz1xtga.fixedflag ? (_temp312_pw_gz1xtga=pw_gz1xtga,&_temp312_pw_gz1xtga) : &pw_gz1xtga,
                  _pw_gz1xtg.fixedflag ? (_temp313_pw_gz1xtg=pw_gz1xtg,&_temp313_pw_gz1xtg) : &pw_gz1xtg, _pw_gz1xtgd.fixedflag ? (_temp314_pw_gz1xtgd=pw_gz1xtgd,&_temp314_pw_gz1xtgd) : &pw_gz1xtgd) == FAILURE) 
    {
        epic_error(use_ermes, "%s failed in XTGcveval.",
                   EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                   STRING_ARG, "amppwgrad: gz1xtg"); 
        return FAILURE;
    }

    /* use 16kHz, 256 xres */
    if( calcfilter( &echo1xtg_filt, XTGecho1bw, XTGxres, OVERWRITE_NONE)
        == FAILURE )
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1),STRING_ARG,"calcfilter for echo1xtg_filt");
        return FAILURE;
    }
    
    if (ampfov(&xtg_temp_float, echo1xtg_filt.bw, xtg_tx) == FAILURE)
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "xtg ampfov");
        return FAILURE;
    }

    xtg_temp_float = ceil(xtg_temp_float/ 10.0) * 10.0;
    if( xtg_temp_float > XTGfov )
    {
        XTGfov  = _XTGfov.fixedflag ?  ((void)(xtg_temp_float), XTGfov) : xtg_temp_float;
    }

    if( ampfov(_a_gxw1xtg.fixedflag ? (_temp315_a_gxw1xtg=a_gxw1xtg,&_temp315_a_gxw1xtg) : &a_gxw1xtg, echo1xtg_filt.bw, XTGfov) == FAILURE )
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "ampfov for gxw1xtg.");
        return FAILURE;        
    }

    if( optramp(_pw_gxw1xtga.fixedflag ? (_temp316_pw_gxw1xtga=pw_gxw1xtga,&_temp316_pw_gxw1xtga) : &pw_gxw1xtga, a_gxw1xtg, xtg_tx,
                xtg_xrt, TYPDEF) == FAILURE )
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "optramp for gxw1xtga.");
        return FAILURE;
    }    

    pw_gxw1xtgd  = _pw_gxw1xtgd.fixedflag ?  ((void)(pw_gxw1xtga), pw_gxw1xtgd) : pw_gxw1xtga;
    
    pw_gxw1xtg  = _pw_gxw1xtg.fixedflag ?  ((void)(RUP_GRD((int)(echo1xtg_filt.tdaq))), pw_gxw1xtg) : RUP_GRD((int)(echo1xtg_filt.tdaq));
    
    area_gxw1xtg = a_gxw1xtg*(float)(pw_gxw1xtg);
    area_gxw1rampxtg = 0.5*a_gxw1xtg*(float)(pw_gxw1xtga);
    
    if( amppwgx1(_a_gx1bxtg.fixedflag ? (_temp317_a_gx1bxtg=a_gx1bxtg,&_temp317_a_gx1bxtg) : &a_gx1bxtg, _pw_gx1bxtg.fixedflag ? (_temp318_pw_gx1bxtg=pw_gx1bxtg,&_temp318_pw_gx1bxtg) : &pw_gx1bxtg, _pw_gx1bxtga.fixedflag ? (_temp319_pw_gx1bxtga=pw_gx1bxtga,&_temp319_pw_gx1bxtga) : &pw_gx1bxtga, _pw_gx1bxtgd.fixedflag ? (_temp320_pw_gx1bxtgd=pw_gx1bxtgd,&_temp320_pw_gx1bxtgd) : &pw_gx1bxtgd,
                 TYPSPIN, area_gxw1xtg, area_gxw1rampxtg,
                 1000000, 1.0, MIN_PLATEAU_TIME, xtg_xrt, xtg_tx_xyz) == FAILURE )
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgx1 for gx1bxtg.");
        return FAILURE;
    }
    a_gx1bxtg  = _a_gx1bxtg.fixedflag ?  ((void)(-a_gx1bxtg), a_gx1bxtg) : -a_gx1bxtg;

    /* Find Params for killer pulse */
    if(PSD_ON == local_tg)
    {
        area_g1xtg = (PSoff90 + pw_gyrf1xtg/2.0 + pw_gyrf1xtgd/2.0)*a_gyrf1xtg;
    }
    else
    {
        area_g1xtg = 0.0;
    }
    area_xtgykiller  = _area_xtgykiller.fixedflag ?  ((void)(amp_killer*pw_killer), area_xtgykiller) : amp_killer*pw_killer;
    if (amppwgrad(area_xtgykiller-area_g1xtg, xtg_ty_xyz, 0.0, 0.0, xtg_yrt,
                  MIN_PLATEAU_TIME, _a_gykxtgl.fixedflag ? (_temp321_a_gykxtgl=a_gykxtgl,&_temp321_a_gykxtgl) : &a_gykxtgl, _pw_gykxtgla.fixedflag ? (_temp322_pw_gykxtgla=pw_gykxtgla,&_temp322_pw_gykxtgla) : &pw_gykxtgla,
                  _pw_gykxtgl.fixedflag ? (_temp323_pw_gykxtgl=pw_gykxtgl,&_temp323_pw_gykxtgl) : &pw_gykxtgl, _pw_gykxtgld.fixedflag ? (_temp324_pw_gykxtgld=pw_gykxtgld,&_temp324_pw_gykxtgld) : &pw_gykxtgld) == FAILURE) {
        epic_error(use_ermes, "%s failed in xtg.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgrad:gykxtgl");
        return FAILURE;
    }
    
    if (amppwgrad(area_xtgykiller, xtg_ty_xyz, 0.0, 0.0, xtg_yrt,
                  MIN_PLATEAU_TIME, _a_gykxtgr.fixedflag ? (_temp325_a_gykxtgr=a_gykxtgr,&_temp325_a_gykxtgr) : &a_gykxtgr, _pw_gykxtgra.fixedflag ? (_temp326_pw_gykxtgra=pw_gykxtgra,&_temp326_pw_gykxtgra) : &pw_gykxtgra,
                  _pw_gykxtgr.fixedflag ? (_temp327_pw_gykxtgr=pw_gykxtgr,&_temp327_pw_gykxtgr) : &pw_gykxtgr, _pw_gykxtgrd.fixedflag ? (_temp328_pw_gykxtgrd=pw_gykxtgrd,&_temp328_pw_gykxtgrd) : &pw_gykxtgrd) == FAILURE) {
        epic_error(use_ermes, "%s failed in xtg.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgrad:gykxtgr");
        return FAILURE;
    }
    flip_rf1xtg  = _flip_rf1xtg.fixedflag ?   ((void)(90.0), flip_rf1xtg) : 90.0;
    flip_rf2xtg  = _flip_rf2xtg.fixedflag ?  ((void)(180.0), flip_rf2xtg) : 180.0;
 
    /* XTGtau1 */
    /* 1. Compute ta_180 */
    /*    Compute timeBeforeFermi as time after RF1 and before FermiL, accouting for min_ssp */
    if(PSD_ON == local_tg)
    {
        if ( XTG_minimizeYKillerGap == PSD_ON )
        {
            /* GyRF1d */
            timeBeforeFermi = IMax( 2, min_ssp, pw_gyrf1xtgd );
        }
        else
        {
            /* GyRF1d + YKillerL */
            timeBeforeFermi = IMax( 2, min_ssp, pw_gyrf1xtgd + pw_gykxtgla+pw_gykxtgl+pw_gykxtgld );  
        }
    }
    else
    {
        if ( XTG_minimizeYKillerGap == PSD_ON )
        {
            /* GzRF1d */
            timeBeforeFermi = IMax(2, min_ssp, pw_gzrf1xtgd);
        }
        else
        {
            /* MAX(GzRF1d,YKillerL), since YKillerL can be applied during GzRF1d) */
            timeBeforeFermi = IMax(2, min_ssp, IMax(2, pw_gzrf1xtgd, pw_gykxtgla+pw_gykxtgl+pw_gykxtgld));
        }
    }
    if ( XTG_minimizeYKillerGap == PSD_ON )
    {
        /* ta_180 = HALF(RF1) + timeBeforeFermiL + FermiL + MAX(ZDephaser,YKillerL) + HALF(GzRF2) */
        ta_180 = pw_rf1xtg/2 + timeBeforeFermi + pw_rf3xtg + IMax(2, pw_gz1xtga+pw_gz1xtg+pw_gz1xtgd + pw_gzrf2xtga, pw_gykxtgla+pw_gykxtgl+pw_gykxtgld) + pw_gzrf2xtg/2;
    }
    else
    {
        /* ta_180 = HALF(RF1) + timeBeforeFermiL(including YKillerL) + FermiL + ZDephaser + HALF(GzRF2) */
         ta_180 = pw_rf1xtg/2 + timeBeforeFermi + pw_rf3xtg + pw_gz1xtga + pw_gz1xtg+pw_gz1xtgd+pw_gzrf2xtga+pw_gzrf2xtg/2;
    }

    /* 2. Compute tb_180 */
    /*    Compute timeBeforeFermi as time after RF2 and before FermiR, accouting for min_ssp */  
    if ( XTG_minimizeYKillerGap == PSD_ON )
    {
        /* MAX(ZRephaser,YKillerR), since YKillerR can be applied during ZRephaser */
        timeBeforeFermi = IMax(2, min_ssp, IMax(2, pw_gzrf2xtgd + pw_gz2xtga+pw_gz2xtg+pw_gz2xtgd, pw_gykxtgra+pw_gykxtgr+pw_gykxtgrd));
        /* tb_180 = HALF(GzRF2) + timeBeforeFermi(including ZRephaser and YKillerR) + FermiR + XReadoutDephaser + HALFeadoutWindow) */ 
        tb_180 = pw_gzrf2xtg/2 + timeBeforeFermi + pw_rf4xtg + pw_gx1bxtga+pw_gx1bxtg+pw_gx1bxtgd + pw_gxw1xtga+pw_gxw1xtg/2;
    }
    else
    {
        /* MAX of XReadoutDephaser and YKillerR */
        timeBeforeFermi = IMax(2, min_ssp, pw_gzrf2xtgd + pw_gz2xtga+pw_gz2xtg+pw_gz2xtgd);
        /* tb_180 = HALF(GzRF2) + timeBeforeFermi(including ZRephaser) + FermiR + MAX(YKillerR,XReadoutDephaser) + HALF(ReadoutWindow) */ 
        tb_180 = pw_gzrf2xtg/2 + timeBeforeFermi + pw_rf4xtg + IMax(2, pw_gx1bxtga+pw_gx1bxtg+pw_gx1bxtgd, pw_gykxtgra+pw_gykxtgr+pw_gykxtgrd) + pw_gxw1xtga+pw_gxw1xtg/2;
    }   

    /* 3. Compute XTGtau1 based on ta_180 and tb180 */
    XTGtau1  = _XTGtau1.fixedflag ?    ((void)(RUP_GRD(IMax(2,ta_180,tb_180))), XTGtau1) : RUP_GRD(IMax(2,ta_180,tb_180)); 
    
    strcpy(entry_point_table[L_XTG].epname, "expresstg");
 
    return SUCCESS;
}   /* end XTGcveval() */

/* 
 *  RScveval
 *  Description:
 *  CV eval for RFShim 
 *  
 *  Type: Public Function
 *  
 *  
 */
STATUS
RScveval( void )
{
    INT temp_time, temp_time2;
    FLOAT area_gz1rs, area_gx1rs;
    FLOAT area_gxkbsrs, area_gxkrs;
    FLOAT area_gzkbsrs, area_gzkrs;
    FLOAT area_gx2rs;
    FLOAT temp_float;
    LONG bw_rf1rs;

    echo1bwrs  = _echo1bwrs.fixedflag ?  ((void)(31.25), echo1bwrs) : 31.25;
    rfshim_baseline  = _rfshim_baseline.fixedflag ?  ((void)(0), rfshim_baseline) : 0;
    rfshim_xres  = _rfshim_xres.fixedflag ?  ((void)(64), rfshim_xres) : 64;
    rfshim_yres  = _rfshim_yres.fixedflag ?  ((void)(64), rfshim_yres) : 64;
    rfshim_slthick  = _rfshim_slthick.fixedflag ?    ((void)(FMax(2,exist(opslthick),10.0)), rfshim_slthick) : FMax(2,exist(opslthick),10.0);  /* limit min slthick to 10mm */

    if( (PSD_ON == rsaxial_flag) )
    {
        rfshim_fov  = _rfshim_fov.fixedflag ?  ((void)(460), rfshim_fov) : 460;
        if(isCategoryMatchForAnatomy(opanatomy, ATTRIBUTE_CATEGORY_HEAD))
        {
            rfshim_fov  = _rfshim_fov.fixedflag ?  ((void)(280), rfshim_fov) : 280;  /* 28 cm FOV for head scans */
        }

    }

    if(exist(opdrivemode) == 3)
    {
        B1Cal_mode  = _B1Cal_mode.fixedflag ?  ((void)(PSD_ON), B1Cal_mode) : PSD_ON;
    }
    else
    {
        B1Cal_mode  = _B1Cal_mode.fixedflag ?  ((void)(PSD_OFF), B1Cal_mode) : PSD_OFF;
    }

    flip_rfbrs  = _flip_rfbrs.fixedflag ?  ((void)(180), flip_rfbrs) : 180;  /* I/Q DD cal needs to double flip */
    flip_rf1rs  = _flip_rf1rs.fixedflag ?  ((void)(10), flip_rf1rs) : 10;
    rfshim_flipangle  = _rfshim_flipangle.fixedflag ?  ((void)(flip_rf1rs), rfshim_flipangle) : flip_rf1rs;

    rfshim_slquant  = _rfshim_slquant.fixedflag ?  ((void)(1), rfshim_slquant) : 1;
    rfshim_slquant  = _rfshim_slquant.fixedflag ?    ((void)(IMin(2,RFSHIM_SLQ,rfshim_slquant)), rfshim_slquant) : IMin(2,RFSHIM_SLQ,rfshim_slquant);

    pw_rf1rs  = _pw_rf1rs.fixedflag ?  ((void)(RUP_GRD(pw_rf1rs)), pw_rf1rs) : RUP_GRD(pw_rf1rs);

    switch (rf1rs_type)
    {
        case B1RF1_SINC:
            bw_rf1rs = (LONG)(4*cyc_rf1rs/((float)pw_rf1rs/(float)1000000));
            rs_iso_delay   = _rs_iso_delay.fixedflag ?      
 ((void)(RUP_GRD(pw_rf1rs/2.0+(float)rs_off90*pw_rf1rs/rfpulse[RF1_RFSHIM_SLOT].nom_pw)), rs_iso_delay) : RUP_GRD(pw_rf1rs/2.0+(float)rs_off90*pw_rf1rs/rfpulse[RF1_RFSHIM_SLOT].nom_pw);
            break;
        case B1RF1_TBW:
        default:
            bw_rf1rs = (LONG)(rfpulse[RF1_RFSHIM_SLOT].nom_bw*rfpulse[RF1_RFSHIM_SLOT].nom_pw/pw_rf1rs);
            rs_iso_delay  = _rs_iso_delay.fixedflag ?  
                                          ((void)(RUP_GRD((int)((float)rfpulse[RF1_RFSHIM_SLOT].isodelay*pw_rf1rs/rfpulse[RF1_RFSHIM_SLOT].nom_pw))), rs_iso_delay) : RUP_GRD((int)((float)rfpulse[RF1_RFSHIM_SLOT].isodelay*pw_rf1rs/rfpulse[RF1_RFSHIM_SLOT].nom_pw));
            break;
    }


    /********************************************************/
    /*   Z Board                                            */
    /*   Slice Selection                                    */
    /********************************************************/
    pw_gzrf1rs  = _pw_gzrf1rs.fixedflag ?  ((void)(pw_rf1rs), pw_gzrf1rs) : pw_rf1rs;

    if (FAILURE==ampslice(_a_gzrf1rs.fixedflag ? (_temp329_a_gzrf1rs=a_gzrf1rs,&_temp329_a_gzrf1rs) : &a_gzrf1rs, bw_rf1rs, rfshim_slthick, gscale_rf1rs, TYPDEF))
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "ampslice for gzrf1rs.");

        return FAILURE;
    }

    if (FAILURE==optramp(_pw_gzrf1rsa.fixedflag ? (_temp330_pw_gzrf1rsa=pw_gzrf1rsa,&_temp330_pw_gzrf1rsa) : &pw_gzrf1rsa, a_gzrf1rs, rsloggrd.tz_xyz, rsloggrd.zrt, TYPDEF))
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "optramp for gzrf1rsa.");
        return FAILURE;
    }
    pw_gzrf1rsd  = _pw_gzrf1rsd.fixedflag ?  ((void)(pw_gzrf1rsa), pw_gzrf1rsd) : pw_gzrf1rsa;

    /* Z BLS killer */
    area_gzkbsrs = 1.0E6*3.0*10.0/GAM/exist(rfshim_slthick);

    if (FAILURE==amppwgrad(area_gzkbsrs, rsloggrd.tz_xyz, 0.0, 0.0, rsloggrd.zrt,
                           MIN_PLATEAU_TIME, _a_gzkbsrs.fixedflag ? (_temp331_a_gzkbsrs=a_gzkbsrs,&_temp331_a_gzkbsrs) : &a_gzkbsrs, _pw_gzkbsrsa.fixedflag ? (_temp332_pw_gzkbsrsa=pw_gzkbsrsa,&_temp332_pw_gzkbsrsa) : &pw_gzkbsrsa,
                           _pw_gzkbsrs.fixedflag ? (_temp333_pw_gzkbsrs=pw_gzkbsrs,&_temp333_pw_gzkbsrs) : &pw_gzkbsrs, _pw_gzkbsrsd.fixedflag ? (_temp334_pw_gzkbsrsd=pw_gzkbsrsd,&_temp334_pw_gzkbsrsd) : &pw_gzkbsrsd ))
    {
        epic_error(use_ermes, "%s failed in RScveval.",
                   EM_PSD_SUPPORT_FAILURE,EE_ARGS(1),
                   STRING_ARG,"amppwgrad:gzkbsrs");
        return FAILURE;
    }

    if (a_gzrf1rs>0.0)
    {
        a_gzkbsrs  = _a_gzkbsrs.fixedflag ?  ((void)(-1.0*fabsf(a_gzkbsrs)), a_gzkbsrs) : -1.0*fabsf(a_gzkbsrs);
    } else {
        a_gzkbsrs  = _a_gzkbsrs.fixedflag ?  ((void)(fabsf(a_gzkbsrs)), a_gzkbsrs) : fabsf(a_gzkbsrs);
    }

    rst_exa  = _rst_exa.fixedflag ?      ((void)(RUP_GRD(pw_gzrf1rsa+pw_gzrf1rs-rs_iso_delay)), rst_exa) : RUP_GRD(pw_gzrf1rsa+pw_gzrf1rs-rs_iso_delay);
    rst_exb  = _rst_exb.fixedflag ?  ((void)(rs_iso_delay), rst_exb) : rs_iso_delay;

    area_gz1rs = (rs_iso_delay + (pw_gzrf1rsd/ 2.0)) * a_gzrf1rs;
    if (area_gz1rs > 0.0)
    {
        area_gz1rs -= fabsf(area_gzkbsrs);
    }
    else
    {
        area_gz1rs += fabsf(area_gzkbsrs);
    }

    if (amppwgz1(_a_gz1rs.fixedflag ? (_temp335_a_gz1rs=a_gz1rs,&_temp335_a_gz1rs) : &a_gz1rs,_pw_gz1rs.fixedflag ? (_temp336_pw_gz1rs=pw_gz1rs,&_temp336_pw_gz1rs) : &pw_gz1rs,_pw_gz1rsa.fixedflag ? (_temp337_pw_gz1rsa=pw_gz1rsa,&_temp337_pw_gz1rsa) : &pw_gz1rsa,_pw_gz1rsd.fixedflag ? (_temp338_pw_gz1rsd=pw_gz1rsd,&_temp338_pw_gz1rsd) : &pw_gz1rsd,area_gz1rs,
                 (int)(1000000),MIN_PLATEAU_TIME,rsloggrd.zrt,rsloggrd.tz_xz) == FAILURE)
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgz1 for gz1rs.");
        return FAILURE;
    }

    /* Z killer */
    area_gzkrs = 980;

    if (FAILURE==amppwgrad(area_gzkrs, rsloggrd.tz_xyz, 0.0, 0.0, rsloggrd.zrt,
                           MIN_PLATEAU_TIME, _a_gzkrs.fixedflag ? (_temp339_a_gzkrs=a_gzkrs,&_temp339_a_gzkrs) : &a_gzkrs, _pw_gzkrsa.fixedflag ? (_temp340_pw_gzkrsa=pw_gzkrsa,&_temp340_pw_gzkrsa) : &pw_gzkrsa,
                           _pw_gzkrs.fixedflag ? (_temp341_pw_gzkrs=pw_gzkrs,&_temp341_pw_gzkrs) : &pw_gzkrs, _pw_gzkrsd.fixedflag ? (_temp342_pw_gzkrsd=pw_gzkrsd,&_temp342_pw_gzkrsd) : &pw_gzkrsd ))
    {
        epic_error(use_ermes, "%s failed in RScveval.",
                   EM_PSD_SUPPORT_FAILURE,EE_ARGS(1),
                   STRING_ARG,"amppwgrad:gzkrs");
        return FAILURE;
    }

    /*****************************************************************/
    /*  X Board - readout and dephaser                               */
    /*****************************************************************/

    if ( FAILURE==calcfilter( &echo1rs_filt, echo1bwrs, rfshim_xres, OVERWRITE_NONE) ) 
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "calcfilter for echo1rs_filt");

        return FAILURE;
    }

    if ( FAILURE==ampfov(&temp_float, echo1rs_filt.bw, rsloggrd.tx) )
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "ampfov");
        return FAILURE;
    }

    temp_float = ceil(temp_float/ 10.0) * 10.0;
    if( temp_float > rfshim_fov )
    {
        rfshim_fov  = _rfshim_fov.fixedflag ?  ((void)(temp_float), rfshim_fov) : temp_float;
    }

    if ( FAILURE==ampfov(_a_gxwrs.fixedflag ? (_temp343_a_gxwrs=a_gxwrs,&_temp343_a_gxwrs) : &a_gxwrs, echo1rs_filt.bw, rfshim_fov) )
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "ampfov for gxwrs.");
        return FAILURE;
    }

    if (FAILURE==optramp(_pw_gxwrsa.fixedflag ? (_temp344_pw_gxwrsa=pw_gxwrsa,&_temp344_pw_gxwrsa) : &pw_gxwrsa, a_gxwrs, rsloggrd.tx_xyz, rsloggrd.xrt, TYPDEF)) 
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "optramp for pw_gxwrsa.");
        return FAILURE;
    }

    pw_gxwrsd  = _pw_gxwrsd.fixedflag ?  ((void)(pw_gxwrsa), pw_gxwrsd) : pw_gxwrsa;
    pw_acqrs1  = _pw_acqrs1.fixedflag ?  ((void)(echo1rs_filt.tdaq), pw_acqrs1) : echo1rs_filt.tdaq;  /* one echo data */

    rd_ext_rs  = _rd_ext_rs.fixedflag ?  
                        ((void)(RUP_GRD(attenlen+tns_len+XTR_length[bd_index]+RBA_length[bd_index]+DAB_length[bd_index]+fast_xtr)), rd_ext_rs) : RUP_GRD(attenlen+tns_len+XTR_length[bd_index]+RBA_length[bd_index]+DAB_length[bd_index]+fast_xtr);

    pw_gxwrs  = _pw_gxwrs.fixedflag ?      ((void)(pw_acqrs1+e2_delay_rs+rd_ext_rs), pw_gxwrs) : pw_acqrs1+e2_delay_rs+rd_ext_rs;  /* total readout */

    /* X BLS killer */
    area_gxkbsrs = area_gzkbsrs;

    if (FAILURE==amppwgrad(area_gxkbsrs, rsloggrd.tx_xyz, 0.0, 0.0, rsloggrd.xrt,
                           MIN_PLATEAU_TIME, _a_gxkbsrs.fixedflag ? (_temp345_a_gxkbsrs=a_gxkbsrs,&_temp345_a_gxkbsrs) : &a_gxkbsrs, _pw_gxkbsrsa.fixedflag ? (_temp346_pw_gxkbsrsa=pw_gxkbsrsa,&_temp346_pw_gxkbsrsa) : &pw_gxkbsrsa,
                           _pw_gxkbsrs.fixedflag ? (_temp347_pw_gxkbsrs=pw_gxkbsrs,&_temp347_pw_gxkbsrs) : &pw_gxkbsrs, _pw_gxkbsrsd.fixedflag ? (_temp348_pw_gxkbsrsd=pw_gxkbsrsd,&_temp348_pw_gxkbsrsd) : &pw_gxkbsrsd ))
    {
        epic_error(use_ermes, "%s failed in RFcveval.",
                   EM_PSD_SUPPORT_FAILURE,EE_ARGS(1),
                   STRING_ARG,"amppwgrad:gxkbsrs");
        return FAILURE;
    }

    if (a_gxwrs>0.0)
    {
        a_gxkbsrs  = _a_gxkbsrs.fixedflag ?  ((void)(-1.0*fabsf(a_gxkbsrs)), a_gxkbsrs) : -1.0*fabsf(a_gxkbsrs);
    } else {
        a_gxkbsrs  = _a_gxkbsrs.fixedflag ?  ((void)(fabsf(a_gxkbsrs)), a_gxkbsrs) : fabsf(a_gxkbsrs);
    }

    /* combine gxkbs and gx1 */
    area_gx1rs = area_gxkbsrs - (pw_gxwrs+pw_gxwrsa)/2.0*a_gxwrs;

    if (FAILURE==amppwgrad(area_gx1rs, rsloggrd.tx_xyz, 0.0, 0.0, rsloggrd.xrt,
                           MIN_PLATEAU_TIME, _a_gx1rs.fixedflag ? (_temp349_a_gx1rs=a_gx1rs,&_temp349_a_gx1rs) : &a_gx1rs, _pw_gx1rsa.fixedflag ? (_temp350_pw_gx1rsa=pw_gx1rsa,&_temp350_pw_gx1rsa) : &pw_gx1rsa,
                           _pw_gx1rs.fixedflag ? (_temp351_pw_gx1rs=pw_gx1rs,&_temp351_pw_gx1rs) : &pw_gx1rs, _pw_gx1rsd.fixedflag ? (_temp352_pw_gx1rsd=pw_gx1rsd,&_temp352_pw_gx1rsd) : &pw_gx1rsd ))
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgx1 for gx1rs.");
        return FAILURE;
    }

    /* X Killer */
    area_gxkrs = 980;
    if (FAILURE==amppwgrad(area_gxkrs, rsloggrd.tx_xyz, 0.0, 0.0, rsloggrd.xrt,
                           MIN_PLATEAU_TIME, _a_gxkrs.fixedflag ? (_temp353_a_gxkrs=a_gxkrs,&_temp353_a_gxkrs) : &a_gxkrs, _pw_gxkrsa.fixedflag ? (_temp354_pw_gxkrsa=pw_gxkrsa,&_temp354_pw_gxkrsa) : &pw_gxkrsa,
                           _pw_gxkrs.fixedflag ? (_temp355_pw_gxkrs=pw_gxkrs,&_temp355_pw_gxkrs) : &pw_gxkrs, _pw_gxkrsd.fixedflag ? (_temp356_pw_gxkrsd=pw_gxkrsd,&_temp356_pw_gxkrsd) : &pw_gxkrsd ))
    {
        epic_error(use_ermes, "%s failed in RScveval.",
                   EM_PSD_SUPPORT_FAILURE,EE_ARGS(1),
                   STRING_ARG,"amppwgrad:gxkrs");
        return FAILURE;
    }

    if(rfshim_etl >=2)
    {
        pw_gxw2rs  = _pw_gxw2rs.fixedflag ?  ((void)(pw_gxwrs), pw_gxw2rs) : pw_gxwrs;
        pw_gxw2rsa  = _pw_gxw2rsa.fixedflag ?  ((void)(pw_gxwrsa), pw_gxw2rsa) : pw_gxwrsa;
        pw_gxw2rsd  = _pw_gxw2rsd.fixedflag ?  ((void)(pw_gxwrsd), pw_gxw2rsd) : pw_gxwrsd;
        a_gxw2rs  = _a_gxw2rs.fixedflag ?  ((void)(a_gxwrs), a_gxw2rs) : a_gxwrs;

        area_gx2rs = -(pw_gxw2rs+(pw_gxw2rsa+pw_gxw2rsd)/2.0)*a_gxw2rs;

        if (FAILURE==amppwgrad(area_gx2rs, rsloggrd.tx_xy, 0.0, 0.0, rsloggrd.xrt,
                               MIN_PLATEAU_TIME, _a_gx2rs.fixedflag ? (_temp357_a_gx2rs=a_gx2rs,&_temp357_a_gx2rs) : &a_gx2rs, _pw_gx2rsa.fixedflag ? (_temp358_pw_gx2rsa=pw_gx2rsa,&_temp358_pw_gx2rsa) : &pw_gx2rsa,
                               _pw_gx2rs.fixedflag ? (_temp359_pw_gx2rs=pw_gx2rs,&_temp359_pw_gx2rs) : &pw_gx2rs, _pw_gx2rsd.fixedflag ? (_temp360_pw_gx2rsd=pw_gx2rsd,&_temp360_pw_gx2rsd) : &pw_gx2rsd ))
        {
            epic_error(use_ermes, "%s failed in RScveval.", EM_PSD_SUPPORT_FAILURE,EE_ARGS(1),
                       STRING_ARG,"amppwgrad:gx2rs");
            return FAILURE;
        }

        rs_esp  = _rs_esp.fixedflag ?                
                                                
                                                  
                                                
                                                  ((void)(RUP_GRD(pw_gxwrs+IMax(3,(pw_gxwrsd+pw_gxw2rsa+pw_gx2rsa+pw_gx2rs+pw_gx2rsd),attenlen+tns_len+IMax(2,DABSETUP,(XTRSETLNG+XTR_length[bd_index]+DAB_length[bd_index]))+RBA_length[bd_index]+psd_grd_wait,pw_gy2rsa+pw_gy2rs+pw_gy2rsd))), rs_esp) : RUP_GRD(pw_gxwrs+IMax(3,(pw_gxwrsd+pw_gxw2rsa+pw_gx2rsa+pw_gx2rs+pw_gx2rsd),attenlen+tns_len+IMax(2,DABSETUP,(XTRSETLNG+XTR_length[bd_index]+DAB_length[bd_index]))+RBA_length[bd_index]+psd_grd_wait,pw_gy2rsa+pw_gy2rs+pw_gy2rsd));

    }

    /***************************************************************/
    /*   Y Board - Dephaser and Killer                             */
    /*                                                             */
    /*   Calculate Y Phase encode amp and pw.                      */
    /*                                                             */
    /***************************************************************/

    /* Scale the waveform amps for the phase encodes 
     * so each phase instruction jump is an integer step */
    if ( FAILURE==endview((int)(rfshim_yres), _endview_iamprs.fixedflag ? (_temp361_endview_iamprs=endview_iamprs,&_temp361_endview_iamprs) : &endview_iamprs) )
    {
        epic_error(use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "endview:RFShim B1 map");
        return FAILURE;
    } 
  
    endview_scalers  = _endview_scalers.fixedflag ?   ((void)((float)max_pg_iamp/(float)endview_iamprs), endview_scalers) : (float)max_pg_iamp/(float)endview_iamprs;

    if ( FAILURE==amppwtpe(_a_gy1rsa.fixedflag ? (_temp362_a_gy1rsa=a_gy1rsa,&_temp362_a_gy1rsa) : &a_gy1rsa, _a_gy1rsb.fixedflag ? (_temp363_a_gy1rsb=a_gy1rsb,&_temp363_a_gy1rsb) : &a_gy1rsb, _pw_gy1rs.fixedflag ? (_temp364_pw_gy1rs=pw_gy1rs,&_temp364_pw_gy1rs) : &pw_gy1rs, _pw_gy1rsa.fixedflag ? (_temp365_pw_gy1rsa=pw_gy1rsa,&_temp365_pw_gy1rsa) : &pw_gy1rsa, _pw_gy1rsd.fixedflag ? (_temp366_pw_gy1rsd=pw_gy1rsd,&_temp366_pw_gy1rsd) : &pw_gy1rsd,
                           rsloggrd.ty_xyz/endview_scalers,rsloggrd.yrt,
                           (0.5 * (FLOAT)(rfshim_yres-1))/(rfshim_fov * 0.1) * 1.0e6/ GAM) ) 
    {
        epic_error(use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwtpe:RFShim B1 map");
        return FAILURE;
    }

    /* phase rewinders */
    a_gy1rrs  = _a_gy1rrs.fixedflag ?  ((void)(a_gy1rs), a_gy1rrs) : a_gy1rs;
    a_gy1rrsa  = _a_gy1rrsa.fixedflag ?  ((void)(a_gy1rsa), a_gy1rrsa) : a_gy1rsa;
    a_gy1rrsb  = _a_gy1rrsb.fixedflag ?  ((void)(a_gy1rsb), a_gy1rrsb) : a_gy1rsb;
    pw_gy1rrs  = _pw_gy1rrs.fixedflag ?  ((void)(pw_gy1rs), pw_gy1rrs) : pw_gy1rs;
    pw_gy1rrsa  = _pw_gy1rrsa.fixedflag ?  ((void)(pw_gy1rsa), pw_gy1rrsa) : pw_gy1rsa;
    pw_gy1rrsd  = _pw_gy1rrsd.fixedflag ?  ((void)(pw_gy1rsd), pw_gy1rrsd) : pw_gy1rsd;

    a_gy2rs  = _a_gy2rs.fixedflag ?  ((void)(a_gy1rs), a_gy2rs) : a_gy1rs;
    a_gy2rsa  = _a_gy2rsa.fixedflag ?  ((void)(a_gy1rsa), a_gy2rsa) : a_gy1rsa;
    a_gy2rsb  = _a_gy2rsb.fixedflag ?  ((void)(a_gy1rsb), a_gy2rsb) : a_gy1rsb;
    pw_gy2rs  = _pw_gy2rs.fixedflag ?  ((void)(pw_gy1rs), pw_gy2rs) : pw_gy1rs;
    pw_gy2rsa  = _pw_gy2rsa.fixedflag ?  ((void)(pw_gy1rsa), pw_gy2rsa) : pw_gy1rsa;
    pw_gy2rsd  = _pw_gy2rsd.fixedflag ?  ((void)(pw_gy1rsd), pw_gy2rsd) : pw_gy1rsd;


    td0rs  = _td0rs.fixedflag ?      ((void)(RUP_GRD((int)(GRAD_UPDATE_TIME+tleadrs+minimumPreRfSspTime()))), td0rs) : RUP_GRD((int)(GRAD_UPDATE_TIME+tleadrs+minimumPreRfSspTime()));

    temp_time = IMax(2, pw_gzrf1rsd + pw_gz1rsa + pw_gz1rs + pw_gz1rsd, pw_gxkbsrsa + pw_gxkbsrs + pw_gxkbsrsd);
    temp_time2 = IMax(3, pw_gx1rsa + pw_gx1rs + pw_gx1rsd + pw_gxwrsa, pw_gy1rsa + pw_gy1rs + pw_gy1rsd,
                      pw_gzkbsrsa + pw_gzkbsrs + pw_gzkbsrsd);

    min_rste  = _min_rste.fixedflag ?            ((void)(RUP_GRD(rst_exb+temp_time+pw_rfbrs+temp_time2+psd_grd_wait+pw_gxwrs/2.0)), min_rste) : RUP_GRD(rst_exb+temp_time+pw_rfbrs+temp_time2+psd_grd_wait+pw_gxwrs/2.0);

    temp_time = IMax(3, pw_gxwrsd + pw_gxkrsa + pw_gxkrs + pw_gxkrsd, pw_gy1rrsa + pw_gy1rrs + pw_gy1rrsd,
                     pw_gzkrsa + pw_gzkrs + pw_gzkrsd);

    tr_rs  = _tr_rs.fixedflag ?              ((void)(RUP_GRD(td0rs+rst_exa+min_rste+pw_gxwrs/2.0+temp_time+time_ssirs+(rfshim_etl-1)*rs_esp)), tr_rs) : RUP_GRD(td0rs+rst_exa+min_rste+pw_gxwrs/2.0+temp_time+time_ssirs+(rfshim_etl-1)*rs_esp);

    return SUCCESS;
} /* end RScveval */

/* 
 *  DTGcveval
 *  Description:
 *  CV eval for DynTG B1map 
 *  
 *  Type: Public Function
 *  
 *  
 */
STATUS
DTGcveval( void )
{
    INT temp_time, temp_time2;
    FLOAT area_gz1dtg, area_gx1dtg;
    FLOAT area_gxkbsdtg, area_gxkdtg, area_gzkbsdtg, area_gzkdtg, area_gx2dtg;
    FLOAT temp_float;
    LONG bw_rf1dtg;
    int maptg_newgeo = 1;
    int rotation_index;

    if ( PSD_ON == enableMapTg)
    {
		for( rotation_index = 0; rotation_index < 9; rotation_index++)
		{
			maptgscan_info[0].oprot[rotation_index] = 0.0;
		}

        /* Axial Scan with Freq R/L */
		maptgscan_info[0].oprot[0] = maptgscan_info[0].oprot[4] = maptgscan_info[0].oprot[8] = 1.0;

		if (obloptimize(&maptgloggrd, &phygrd, maptgscan_info, 1, PSD_OBL,
					0, obl_method, ps1obl_debug, &maptg_newgeo,
					cfsrmode) == FAILURE)
		{
			epic_error(use_ermes, "%s failed in DTGcvinit.", EM_PSD_SUPPORT_FAILURE,
					EE_ARGS(1), STRING_ARG, "obloptimize"); 
			return FAILURE;
		}

		/* derate SR for silent PSC */ 
		sr_derate(&maptgloggrd, PSsr_derate_factor, PSamp_derate_factor);

        dtgloggrd = maptgloggrd; /* Map TG uses Axial scan */
    }
    else
    {
        dtgloggrd = loggrd; /* same as imaging loggrd */
    }

    echo1bwdtg  = _echo1bwdtg.fixedflag ?  ((void)(31.25), echo1bwdtg) : 31.25;
    dynTG_baseline  = _dynTG_baseline.fixedflag ?  ((void)(0), dynTG_baseline) : 0;
    dynTG_xres  = _dynTG_xres.fixedflag ?  ((void)(64), dynTG_xres) : 64;
    dynTG_yres  = _dynTG_yres.fixedflag ?  ((void)(64), dynTG_yres) : 64;
    dynTG_slthick  = _dynTG_slthick.fixedflag ?    ((void)(FMax(2,exist(opslthick),10.0)), dynTG_slthick) : FMax(2,exist(opslthick),10.0);  /* limit min slthick to 10mm */

    if(PSD_ON == enableMapTg)
    {
        /* Setting FOV for map TG */
        dynTG_fov  = _dynTG_fov.fixedflag ?    ((void)(FMin(2,480.0,cfsystemmaxfov)), dynTG_fov) : FMin(2,480.0,cfsystemmaxfov);
    }
    else
    {
        dynTG_fov  = _dynTG_fov.fixedflag ?    ((void)(FMax(2,exist(opfov),80.0)), dynTG_fov) : FMax(2,exist(opfov),80.0);  /* limit to min FOV of 80mm */
        dynTG_fov  = _dynTG_fov.fixedflag ?    ((void)(FMin(2,dynTG_fov,(float)FOV_MAX)), dynTG_fov) : FMin(2,dynTG_fov,(float)FOV_MAX);
    }

    flip_rfbdtg  = _flip_rfbdtg.fixedflag ?  ((void)(180), flip_rfbdtg) : 180;
    flip_rf1dtg  = _flip_rf1dtg.fixedflag ?  ((void)(10), flip_rf1dtg) : 10;

    dynTG_flipangle  = _dynTG_flipangle.fixedflag ?  ((void)(flip_rf1dtg), dynTG_flipangle) : flip_rf1dtg;

    pw_rf1dtg  = _pw_rf1dtg.fixedflag ?  ((void)(RUP_GRD(pw_rf1dtg)), pw_rf1dtg) : RUP_GRD(pw_rf1dtg);

    switch (rf1dtg_type)
    {
        case B1RF1_SINC:
            bw_rf1dtg = (LONG)(4*cyc_rf1dtg/((float)pw_rf1dtg/(float)1000000));
            dtg_iso_delay   = _dtg_iso_delay.fixedflag ?      
 ((void)(RUP_GRD(pw_rf1dtg/2.0+(float)dtg_off90*pw_rf1dtg/rfpulse[RF1_DYNTG_SLOT].nom_pw)), dtg_iso_delay) : RUP_GRD(pw_rf1dtg/2.0+(float)dtg_off90*pw_rf1dtg/rfpulse[RF1_DYNTG_SLOT].nom_pw);
            break;
        case B1RF1_TBW:
        default:
            bw_rf1dtg = (LONG)(rfpulse[RF1_DYNTG_SLOT].nom_bw*rfpulse[RF1_DYNTG_SLOT].nom_pw/pw_rf1dtg);
            dtg_iso_delay  = _dtg_iso_delay.fixedflag ?  
                                          ((void)(RUP_GRD((int)((float)rfpulse[RF1_DYNTG_SLOT].isodelay*pw_rf1dtg/rfpulse[RF1_DYNTG_SLOT].nom_pw))), dtg_iso_delay) : RUP_GRD((int)((float)rfpulse[RF1_DYNTG_SLOT].isodelay*pw_rf1dtg/rfpulse[RF1_DYNTG_SLOT].nom_pw));
            break;
    }

    if(PSD_ON == enableMapTg)
    {
        dynTG_slquant  = _dynTG_slquant.fixedflag ?  ((void)(MAPTG_SLQ), dynTG_slquant) : MAPTG_SLQ;
    }
    else
    {
        if (exist(opslquant)<=DYNTG_SLQ)
        {
            if (1 == (exist(opslquant) % 2))
            {
                dynTG_slquant  = _dynTG_slquant.fixedflag ?  ((void)(exist(opslquant)), dynTG_slquant) : exist(opslquant);
            }
            else
            {
                dynTG_slquant  = _dynTG_slquant.fixedflag ?    ((void)(exist(opslquant)-1), dynTG_slquant) : exist(opslquant)-1;
            }
        }
        else
        {
            dynTG_slquant  = _dynTG_slquant.fixedflag ?  ((void)(DYNTG_SLQ), dynTG_slquant) : DYNTG_SLQ;
        }
    }

    /********************************************************/
    /*   Z Board                                            */
    /*   Slice Selection                                    */
    /********************************************************/
    pw_gzrf1dtg  = _pw_gzrf1dtg.fixedflag ?  ((void)(pw_rf1dtg), pw_gzrf1dtg) : pw_rf1dtg;

    if (FAILURE==ampslice(_a_gzrf1dtg.fixedflag ? (_temp367_a_gzrf1dtg=a_gzrf1dtg,&_temp367_a_gzrf1dtg) : &a_gzrf1dtg, bw_rf1dtg, dynTG_slthick, gscale_rf1dtg, TYPDEF))
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "ampslice for gzrf1dtg.");

        return FAILURE;
    }

    if (FAILURE==optramp(_pw_gzrf1dtga.fixedflag ? (_temp368_pw_gzrf1dtga=pw_gzrf1dtga,&_temp368_pw_gzrf1dtga) : &pw_gzrf1dtga, a_gzrf1dtg, dtgloggrd.tz_xyz, dtgloggrd.zrt, TYPDEF))
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "optramp for gzrf1dtga.");
        return FAILURE;
    }
    pw_gzrf1dtgd  = _pw_gzrf1dtgd.fixedflag ?  ((void)(pw_gzrf1dtga), pw_gzrf1dtgd) : pw_gzrf1dtga;

    /* Z BLS killer */
    area_gzkbsdtg = 1.0E6*3.0*10.0/GAM/exist(dynTG_slthick);

    if (FAILURE==amppwgrad(area_gzkbsdtg, dtgloggrd.tz_xyz, 0.0, 0.0, dtgloggrd.zrt,
                           MIN_PLATEAU_TIME, _a_gzkbsdtg.fixedflag ? (_temp369_a_gzkbsdtg=a_gzkbsdtg,&_temp369_a_gzkbsdtg) : &a_gzkbsdtg, _pw_gzkbsdtga.fixedflag ? (_temp370_pw_gzkbsdtga=pw_gzkbsdtga,&_temp370_pw_gzkbsdtga) : &pw_gzkbsdtga,
                           _pw_gzkbsdtg.fixedflag ? (_temp371_pw_gzkbsdtg=pw_gzkbsdtg,&_temp371_pw_gzkbsdtg) : &pw_gzkbsdtg, _pw_gzkbsdtgd.fixedflag ? (_temp372_pw_gzkbsdtgd=pw_gzkbsdtgd,&_temp372_pw_gzkbsdtgd) : &pw_gzkbsdtgd ))
    {
        epic_error(use_ermes, "%s failed in DTGcveval.",
                   EM_PSD_SUPPORT_FAILURE,EE_ARGS(1),
                   STRING_ARG,"amppwgrad:gzkbsdtg"); 
        return FAILURE;
    }

    if (a_gzrf1dtg>0.0)
    {
        a_gzkbsdtg  = _a_gzkbsdtg.fixedflag ?  ((void)(-1.0*fabsf(a_gzkbsdtg)), a_gzkbsdtg) : -1.0*fabsf(a_gzkbsdtg);
    } else {
        a_gzkbsdtg  = _a_gzkbsdtg.fixedflag ?  ((void)(fabsf(a_gzkbsdtg)), a_gzkbsdtg) : fabsf(a_gzkbsdtg);
    }

    dtgt_exa  = _dtgt_exa.fixedflag ?      ((void)(RUP_GRD(pw_gzrf1dtga+pw_gzrf1dtg-dtg_iso_delay)), dtgt_exa) : RUP_GRD(pw_gzrf1dtga+pw_gzrf1dtg-dtg_iso_delay);
    dtgt_exb  = _dtgt_exb.fixedflag ?  ((void)(dtg_iso_delay), dtgt_exb) : dtg_iso_delay;

    area_gz1dtg = (dtg_iso_delay + (pw_gzrf1dtgd/ 2.0)) * a_gzrf1dtg;
    if (area_gz1dtg > 0.0)
    {
        area_gz1dtg -= fabsf(area_gzkbsdtg);
    }
    else
    {
        area_gz1dtg += fabsf(area_gzkbsdtg);
    }

    if (amppwgz1(_a_gz1dtg.fixedflag ? (_temp373_a_gz1dtg=a_gz1dtg,&_temp373_a_gz1dtg) : &a_gz1dtg,_pw_gz1dtg.fixedflag ? (_temp374_pw_gz1dtg=pw_gz1dtg,&_temp374_pw_gz1dtg) : &pw_gz1dtg,_pw_gz1dtga.fixedflag ? (_temp375_pw_gz1dtga=pw_gz1dtga,&_temp375_pw_gz1dtga) : &pw_gz1dtga,_pw_gz1dtgd.fixedflag ? (_temp376_pw_gz1dtgd=pw_gz1dtgd,&_temp376_pw_gz1dtgd) : &pw_gz1dtgd,area_gz1dtg,
                 (int)(1000000),MIN_PLATEAU_TIME,dtgloggrd.zrt,dtgloggrd.tz_xz) == FAILURE)
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgz1 for gz1dtg.");
        return FAILURE;
    }

    /* Z killer */
    area_gzkdtg = 980;

    if (FAILURE==amppwgrad(area_gzkdtg, dtgloggrd.tz_xyz, 0.0, 0.0, dtgloggrd.zrt,
                           MIN_PLATEAU_TIME, _a_gzkdtg.fixedflag ? (_temp377_a_gzkdtg=a_gzkdtg,&_temp377_a_gzkdtg) : &a_gzkdtg, _pw_gzkdtga.fixedflag ? (_temp378_pw_gzkdtga=pw_gzkdtga,&_temp378_pw_gzkdtga) : &pw_gzkdtga,
                           _pw_gzkdtg.fixedflag ? (_temp379_pw_gzkdtg=pw_gzkdtg,&_temp379_pw_gzkdtg) : &pw_gzkdtg, _pw_gzkdtgd.fixedflag ? (_temp380_pw_gzkdtgd=pw_gzkdtgd,&_temp380_pw_gzkdtgd) : &pw_gzkdtgd ))
    {
        epic_error(use_ermes, "%s failed in DTGcveval.",
                   EM_PSD_SUPPORT_FAILURE,EE_ARGS(1),
                   STRING_ARG,"amppwgrad:gzkdtg"); 
        return FAILURE;
    }

    /*****************************************************************/
    /*  X Board - readout and dephaser                               */
    /*****************************************************************/

    if ( FAILURE==calcfilter( &echo1dtg_filt, echo1bwdtg, dynTG_xres, OVERWRITE_NONE) ) 
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "calcfilter for echo1dtg_filt");

        return FAILURE;
    }

    if ( FAILURE==ampfov(&temp_float, echo1dtg_filt.bw, dtgloggrd.tx) )
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "ampfov");
        return FAILURE;
    }

    temp_float = ceil(temp_float/ 10.0) * 10.0;
    if( temp_float > dynTG_fov )
    {
        dynTG_fov  = _dynTG_fov.fixedflag ?  ((void)(temp_float), dynTG_fov) : temp_float;
    }

    if ( FAILURE==ampfov(_a_gxwdtg.fixedflag ? (_temp381_a_gxwdtg=a_gxwdtg,&_temp381_a_gxwdtg) : &a_gxwdtg, echo1dtg_filt.bw, dynTG_fov) )
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "ampfov for gxwdtg.");
        return FAILURE;
    }

    if (FAILURE==optramp(_pw_gxwdtga.fixedflag ? (_temp382_pw_gxwdtga=pw_gxwdtga,&_temp382_pw_gxwdtga) : &pw_gxwdtga, a_gxwdtg, dtgloggrd.tx_xyz, dtgloggrd.xrt, TYPDEF)) 
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "optramp for pw_gxwdtga.");
        return FAILURE;
    }

    pw_gxwdtgd  = _pw_gxwdtgd.fixedflag ?  ((void)(pw_gxwdtga), pw_gxwdtgd) : pw_gxwdtga;
    pw_acqdtg1  = _pw_acqdtg1.fixedflag ?  ((void)(echo1dtg_filt.tdaq), pw_acqdtg1) : echo1dtg_filt.tdaq;  /* one echo data */

    rd_ext_dtg  = _rd_ext_dtg.fixedflag ?  
                           ((void)(RUP_GRD(attenlen+tns_len+XTR_length[bd_index]+RBA_length[bd_index]+DAB_length[bd_index]+fast_xtr)), rd_ext_dtg) : RUP_GRD(attenlen+tns_len+XTR_length[bd_index]+RBA_length[bd_index]+DAB_length[bd_index]+fast_xtr);

    pw_gxwdtg  = _pw_gxwdtg.fixedflag ?      ((void)(pw_acqdtg1+e2_delay_dtg+rd_ext_dtg), pw_gxwdtg) : pw_acqdtg1+e2_delay_dtg+rd_ext_dtg;  /* total readout */

    /* X BLS killer */
    area_gxkbsdtg = area_gzkbsdtg;

    if (FAILURE==amppwgrad(area_gxkbsdtg, dtgloggrd.tx_xyz, 0.0, 0.0, dtgloggrd.xrt,
                           MIN_PLATEAU_TIME, _a_gxkbsdtg.fixedflag ? (_temp383_a_gxkbsdtg=a_gxkbsdtg,&_temp383_a_gxkbsdtg) : &a_gxkbsdtg, _pw_gxkbsdtga.fixedflag ? (_temp384_pw_gxkbsdtga=pw_gxkbsdtga,&_temp384_pw_gxkbsdtga) : &pw_gxkbsdtga,
                           _pw_gxkbsdtg.fixedflag ? (_temp385_pw_gxkbsdtg=pw_gxkbsdtg,&_temp385_pw_gxkbsdtg) : &pw_gxkbsdtg, _pw_gxkbsdtgd.fixedflag ? (_temp386_pw_gxkbsdtgd=pw_gxkbsdtgd,&_temp386_pw_gxkbsdtgd) : &pw_gxkbsdtgd ))
    {
        epic_error(use_ermes, "%s failed in DTGcveval.",
                   EM_PSD_SUPPORT_FAILURE,EE_ARGS(1),
                   STRING_ARG,"amppwgrad:gxkbsdtg"); 
        return FAILURE;
    }

    if (a_gxwdtg>0.0)
    {
        a_gxkbsdtg  = _a_gxkbsdtg.fixedflag ?  ((void)(-1.0*fabsf(a_gxkbsdtg)), a_gxkbsdtg) : -1.0*fabsf(a_gxkbsdtg);
    } else {
        a_gxkbsdtg  = _a_gxkbsdtg.fixedflag ?  ((void)(fabsf(a_gxkbsdtg)), a_gxkbsdtg) : fabsf(a_gxkbsdtg);
    }

    /* combine gxkbs and gx1dtg */
    area_gx1dtg = area_gxkbsdtg - (pw_gxwdtg+pw_gxwdtga)/2.0*a_gxwdtg;

    if (FAILURE==amppwgrad(area_gx1dtg, dtgloggrd.tx_xyz, 0.0, 0.0, dtgloggrd.xrt,
                           MIN_PLATEAU_TIME, _a_gx1dtg.fixedflag ? (_temp387_a_gx1dtg=a_gx1dtg,&_temp387_a_gx1dtg) : &a_gx1dtg, _pw_gx1dtga.fixedflag ? (_temp388_pw_gx1dtga=pw_gx1dtga,&_temp388_pw_gx1dtga) : &pw_gx1dtga,
                           _pw_gx1dtg.fixedflag ? (_temp389_pw_gx1dtg=pw_gx1dtg,&_temp389_pw_gx1dtg) : &pw_gx1dtg, _pw_gx1dtgd.fixedflag ? (_temp390_pw_gx1dtgd=pw_gx1dtgd,&_temp390_pw_gx1dtgd) : &pw_gx1dtgd ))
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgx1 for gx1dtg.");
        return FAILURE;
    }

    /* X Killer */
    area_gxkdtg = 980;
    if (FAILURE==amppwgrad(area_gxkdtg, dtgloggrd.tx_xyz, 0.0, 0.0, dtgloggrd.xrt,
                           MIN_PLATEAU_TIME, _a_gxkdtg.fixedflag ? (_temp391_a_gxkdtg=a_gxkdtg,&_temp391_a_gxkdtg) : &a_gxkdtg, _pw_gxkdtga.fixedflag ? (_temp392_pw_gxkdtga=pw_gxkdtga,&_temp392_pw_gxkdtga) : &pw_gxkdtga,
                           _pw_gxkdtg.fixedflag ? (_temp393_pw_gxkdtg=pw_gxkdtg,&_temp393_pw_gxkdtg) : &pw_gxkdtg, _pw_gxkdtgd.fixedflag ? (_temp394_pw_gxkdtgd=pw_gxkdtgd,&_temp394_pw_gxkdtgd) : &pw_gxkdtgd ))
    {
        epic_error(use_ermes, "%s failed in DTGcveval.",
                   EM_PSD_SUPPORT_FAILURE,EE_ARGS(1),
                   STRING_ARG,"amppwgrad:gxkdtg"); 
        return FAILURE;
    }

    /* echo train */
    if(dynTG_etl >= 2)
    {
        pw_gxw2dtg  = _pw_gxw2dtg.fixedflag ?  ((void)(pw_gxwdtg), pw_gxw2dtg) : pw_gxwdtg;
        pw_gxw2dtga  = _pw_gxw2dtga.fixedflag ?  ((void)(pw_gxwdtga), pw_gxw2dtga) : pw_gxwdtga;
        pw_gxw2dtgd  = _pw_gxw2dtgd.fixedflag ?  ((void)(pw_gxwdtgd), pw_gxw2dtgd) : pw_gxwdtgd;
        a_gxw2dtg  = _a_gxw2dtg.fixedflag ?  ((void)(a_gxwdtg), a_gxw2dtg) : a_gxwdtg;

        area_gx2dtg = -(pw_gxwdtg+(pw_gxwdtga+pw_gxwdtgd)/2.0)*a_gxwdtg;

        if (FAILURE==amppwgrad(area_gx2dtg, dtgloggrd.tx_xy, 0.0, 0.0, dtgloggrd.xrt,
                               MIN_PLATEAU_TIME, _a_gx2dtg.fixedflag ? (_temp395_a_gx2dtg=a_gx2dtg,&_temp395_a_gx2dtg) : &a_gx2dtg, _pw_gx2dtga.fixedflag ? (_temp396_pw_gx2dtga=pw_gx2dtga,&_temp396_pw_gx2dtga) : &pw_gx2dtga,
                               _pw_gx2dtg.fixedflag ? (_temp397_pw_gx2dtg=pw_gx2dtg,&_temp397_pw_gx2dtg) : &pw_gx2dtg, _pw_gx2dtgd.fixedflag ? (_temp398_pw_gx2dtgd=pw_gx2dtgd,&_temp398_pw_gx2dtgd) : &pw_gx2dtgd ))
        {
            epic_error(use_ermes, "%s failed in DTGcveval.",
                       EM_PSD_SUPPORT_FAILURE,EE_ARGS(1),
                       STRING_ARG,"amppwgrad:gx2dtg"); 
            return FAILURE;
        }

        dtg_esp  = _dtg_esp.fixedflag ?                
                                        
                                            
                                        
                                          ((void)(RUP_GRD(pw_gxwdtg+IMax(3,(pw_gxwdtgd+pw_gxw2dtga+pw_gx2dtga+pw_gx2dtg+pw_gx2dtgd),attenlen+tns_len+IMax(2,DABSETUP,(XTRSETLNG+XTR_length[bd_index]+DAB_length[bd_index]))+RBA_length[bd_index]+psd_grd_wait,pw_gy2dtga+pw_gy2dtg+pw_gy2dtgd))), dtg_esp) : RUP_GRD(pw_gxwdtg+IMax(3,(pw_gxwdtgd+pw_gxw2dtga+pw_gx2dtga+pw_gx2dtg+pw_gx2dtgd),attenlen+tns_len+IMax(2,DABSETUP,(XTRSETLNG+XTR_length[bd_index]+DAB_length[bd_index]))+RBA_length[bd_index]+psd_grd_wait,pw_gy2dtga+pw_gy2dtg+pw_gy2dtgd));
    }

    /***************************************************************/
    /*   Y Board - Dephaser and Killer                             */
    /*                                                             */
    /*   Calculate Y Phase encode amp and pw.                      */
    /*                                                             */
    /***************************************************************/

    /* Scale the waveform amps for the phase encodes 
     * so each phase instruction jump is an integer step */
    if ( FAILURE==endview((int)(dynTG_yres), _endview_iampdtg.fixedflag ? (_temp399_endview_iampdtg=endview_iampdtg,&_temp399_endview_iampdtg) : &endview_iampdtg) )
    {
        epic_error(use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "endview:DynTG B1 map");
        return FAILURE;
    } 
  
    endview_scaledtg  = _endview_scaledtg.fixedflag ?   ((void)((float)max_pg_iamp/(float)endview_iampdtg), endview_scaledtg) : (float)max_pg_iamp/(float)endview_iampdtg;

    if ( FAILURE==amppwtpe(_a_gy1dtga.fixedflag ? (_temp400_a_gy1dtga=a_gy1dtga,&_temp400_a_gy1dtga) : &a_gy1dtga, _a_gy1dtgb.fixedflag ? (_temp401_a_gy1dtgb=a_gy1dtgb,&_temp401_a_gy1dtgb) : &a_gy1dtgb, _pw_gy1dtg.fixedflag ? (_temp402_pw_gy1dtg=pw_gy1dtg,&_temp402_pw_gy1dtg) : &pw_gy1dtg, _pw_gy1dtga.fixedflag ? (_temp403_pw_gy1dtga=pw_gy1dtga,&_temp403_pw_gy1dtga) : &pw_gy1dtga, _pw_gy1dtgd.fixedflag ? (_temp404_pw_gy1dtgd=pw_gy1dtgd,&_temp404_pw_gy1dtgd) : &pw_gy1dtgd,
                           dtgloggrd.ty_xyz/endview_scaledtg,dtgloggrd.yrt,
                           (0.5 * (FLOAT)(dynTG_yres-1))/(dynTG_fov * 0.1) * 1.0e6/ GAM) ) 
    {
        epic_error(use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwtpe:DynTG map");
        return FAILURE;
    }

    /* phase rewinders */
    a_gy1rdtg  = _a_gy1rdtg.fixedflag ?  ((void)(a_gy1dtg), a_gy1rdtg) : a_gy1dtg;
    a_gy1rdtga  = _a_gy1rdtga.fixedflag ?  ((void)(a_gy1dtga), a_gy1rdtga) : a_gy1dtga;
    a_gy1rdtgb  = _a_gy1rdtgb.fixedflag ?  ((void)(a_gy1dtgb), a_gy1rdtgb) : a_gy1dtgb;
    pw_gy1rdtg  = _pw_gy1rdtg.fixedflag ?  ((void)(pw_gy1dtg), pw_gy1rdtg) : pw_gy1dtg;
    pw_gy1rdtga  = _pw_gy1rdtga.fixedflag ?  ((void)(pw_gy1dtga), pw_gy1rdtga) : pw_gy1dtga;
    pw_gy1rdtgd  = _pw_gy1rdtgd.fixedflag ?  ((void)(pw_gy1dtgd), pw_gy1rdtgd) : pw_gy1dtgd;

    a_gy2dtg  = _a_gy2dtg.fixedflag ?  ((void)(a_gy1dtg), a_gy2dtg) : a_gy1dtg;
    a_gy2dtga  = _a_gy2dtga.fixedflag ?  ((void)(a_gy1dtga), a_gy2dtga) : a_gy1dtga;
    a_gy2dtgb  = _a_gy2dtgb.fixedflag ?  ((void)(a_gy1dtgb), a_gy2dtgb) : a_gy1dtgb;
    pw_gy2dtg  = _pw_gy2dtg.fixedflag ?  ((void)(pw_gy1dtg), pw_gy2dtg) : pw_gy1dtg;
    pw_gy2dtga  = _pw_gy2dtga.fixedflag ?  ((void)(pw_gy1dtga), pw_gy2dtga) : pw_gy1dtga;
    pw_gy2dtgd  = _pw_gy2dtgd.fixedflag ?  ((void)(pw_gy1dtgd), pw_gy2dtgd) : pw_gy1dtgd;

    td0dtg  = _td0dtg.fixedflag ?      ((void)(RUP_GRD((int)(GRAD_UPDATE_TIME+tleaddtg+minimumPreRfSspTime()))), td0dtg) : RUP_GRD((int)(GRAD_UPDATE_TIME+tleaddtg+minimumPreRfSspTime()));

    temp_time = IMax(2, pw_gzrf1dtgd + pw_gz1dtga + pw_gz1dtg + pw_gz1dtgd, pw_gxkbsdtga + pw_gxkbsdtg + pw_gxkbsdtgd);
    temp_time2 = IMax(3, pw_gx1dtga + pw_gx1dtg + pw_gx1dtgd + pw_gxwdtga, pw_gy1dtga + pw_gy1dtg + pw_gy1dtgd,
                      pw_gzkbsdtga + pw_gzkbsdtg + pw_gzkbsdtgd);

    min_dtgte  = _min_dtgte.fixedflag ?            ((void)(RUP_GRD(dtgt_exb+temp_time+pw_rfbdtg+temp_time2+psd_grd_wait+pw_gxwdtg/2.0)), min_dtgte) : RUP_GRD(dtgt_exb+temp_time+pw_rfbdtg+temp_time2+psd_grd_wait+pw_gxwdtg/2.0); 

    temp_time = IMax(3, pw_gxwdtgd + pw_gxkdtga + pw_gxkdtg + pw_gxkdtgd, pw_gy1rdtga + pw_gy1rdtg + pw_gy1rdtgd,
                     pw_gzkdtga + pw_gzkdtg + pw_gzkdtgd);

    tr_dtg  = _tr_dtg.fixedflag ?              ((void)(RUP_GRD(td0dtg+dtgt_exa+min_dtgte+pw_gxwdtg/2.0+temp_time+time_ssidtg+(dynTG_etl-1)*dtg_esp)), tr_dtg) : RUP_GRD(td0dtg+dtgt_exa+min_dtgte+pw_gxwdtg/2.0+temp_time+time_ssidtg+(dynTG_etl-1)*dtg_esp);

    return SUCCESS;
} /* end DTGcveval */


/* 
 *  ExtCalcveval
 *  Description:
 *  CV eval for ExtCal entry point 
 *  
 *  Type: Public Function
 *  
 *  
 */
STATUS
ExtCalcveval( void )
{
    FLOAT temp_area;
    FLOAT refocus_cal;
    FLOAT encode_cal = 0.0;
    FLOAT a_delta_cal = 0.0;
    FLOAT encode_cal2 = 0.0;
    FLOAT a_delta_cal2 = 0.0;
    FLOAT area_gxwcal;
    FLOAT target_amp = 1.0;
    INT target_risetime = 4;
    INT temp_time;


    if(coilInfo[0].pureCompatible > 0)
    {
        cvoverride(cal_pass, 2, PSD_FIX_ON, PSD_EXIST_ON);
    }
    else
    {
        cvoverride(cal_pass, 1, PSD_FIX_ON, PSD_EXIST_ON);
    }

    /* freq/phase scaling for image cut reduction */
    cal_freq_scale  = _cal_freq_scale.fixedflag ?  ((void)(calscan_info[0].opfov_freq_scale), cal_freq_scale) : calscan_info[0].opfov_freq_scale;
    cal_phase_scale  = _cal_phase_scale.fixedflag ?  ((void)(calscan_info[0].opfov_phase_scale), cal_phase_scale) : calscan_info[0].opfov_phase_scale;

    if(cal_freq_scale <= 0.0)
    {
        cal_freq_scale  = _cal_freq_scale.fixedflag ?  ((void)(1.0), cal_freq_scale) : 1.0;
    }
    if(cal_phase_scale <= 0.0)
    {
        cal_phase_scale  = _cal_phase_scale.fixedflag ?  ((void)(1.0), cal_phase_scale) : 1.0;
    }
    cal_xfov  = _cal_xfov.fixedflag ?  ((void)(cal_fov*cal_freq_scale), cal_xfov) : cal_fov*cal_freq_scale;
    cal_yfov  = _cal_yfov.fixedflag ?  ((void)(cal_fov*cal_phase_scale), cal_yfov) : cal_fov*cal_phase_scale;

    /*****************************************************/
    /*   Z gradients                                     */  
    /*****************************************************/
    pw_gzrf1cal  = _pw_gzrf1cal.fixedflag ?  ((void)(pw_rf1cal), pw_gzrf1cal) : pw_rf1cal;

    cal_vthick  = _cal_vthick.fixedflag ?    ((void)(cal_slthick*cal_slq), cal_vthick) : cal_slthick*cal_slq;
    bw_rf1cal  = _bw_rf1cal.fixedflag ?  ((void)((int)rfpulse[RF1_EXTCAL_SLOT].nom_bw*rfpulse[RF1_EXTCAL_SLOT].nom_pw/pw_rf1cal), bw_rf1cal) : (int)rfpulse[RF1_EXTCAL_SLOT].nom_bw*rfpulse[RF1_EXTCAL_SLOT].nom_pw/pw_rf1cal;

    if (ampslice(_a_gzrf1cal.fixedflag ? (_temp405_a_gzrf1cal=a_gzrf1cal,&_temp405_a_gzrf1cal) : &a_gzrf1cal, bw_rf1cal, cal_vthick, 1.0, TYPDEF) == FAILURE) {
        epic_error(use_ermes, supfailfmt,
                   EM_PSD_SUPPORT_FAILURE,EE_ARGS(1),STRING_ARG,"amplice (for gzrf1cal)");
        return FAILURE;
    }

    a_gzrf1cal  = _a_gzrf1cal.fixedflag ?    ((void)(cal_ampscale*cal_slq/(cal_slq-4)*a_gzrf1cal), a_gzrf1cal) : cal_ampscale*cal_slq/(cal_slq-4)*a_gzrf1cal;   /* scale for slice blank of 2 */

    amp_rt_dbdtopt(_cal_amplimit.fixedflag ? (_temp406_cal_amplimit=cal_amplimit,&_temp406_cal_amplimit) : &cal_amplimit, &target_risetime, cal_slewrate, 1.0, calloggrd.tz);

    if(a_gzrf1cal <= cal_amplimit)
    {
        target_amp = cal_amplimit;
    }
    else
    {
        target_amp = calloggrd.tz;
        target_risetime = calloggrd.zrta.z;  /* rise time for target amp */
    }

    if (optramp(_pw_gzrf1cala.fixedflag ? (_temp407_pw_gzrf1cala=pw_gzrf1cala,&_temp407_pw_gzrf1cala) : &pw_gzrf1cala, a_gzrf1cal, target_amp, target_risetime, TYPDEF) == FAILURE) {
        epic_error(use_ermes, supfailfmt,
                   EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                   STRING_ARG, "optramp (for gzrf1cala)");
        return FAILURE;
    }
    pw_gzrf1cald  = _pw_gzrf1cald.fixedflag ?  ((void)(pw_gzrf1cala), pw_gzrf1cald) : pw_gzrf1cala;

    if (endview(cal_slq, _endviewz_iampcal.fixedflag ? (_temp408_endviewz_iampcal=endviewz_iampcal,&_temp408_endviewz_iampcal) : &endviewz_iampcal) == FAILURE)
    {
        epic_error(use_ermes,supfailfmt,EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1),STRING_ARG,"endview:gzcombcal");
        return FAILURE;
    } 

    endviewz_scalecal  = _endviewz_scalecal.fixedflag ?   ((void)((float)max_pg_iamp/(float)endviewz_iampcal), endviewz_scalecal) : (float)max_pg_iamp/(float)endviewz_iampcal;

    refocus_cal = fabs(a_gzrf1cal)*(cal_iso_delay + pw_gzrf1cald/2.0);
    temp_area = (0.5 * (FLOAT)(cal_slq-1))/(cal_vthick * 0.1) * 1.0e6/ GAM;

    /* Z slice encode + gzrf1 refocus */
    amp_rt_dbdtopt(_cal_amplimit.fixedflag ? (_temp409_cal_amplimit=cal_amplimit,&_temp409_cal_amplimit) : &cal_amplimit, &target_risetime, cal_slewrate, 1.0, calloggrd.tz_xyz);
    target_amp = cal_amplimit/endviewz_scalecal;
    target_risetime = RUP_GRD(ceil(target_risetime/endviewz_scalecal));  /* rise time for target amp */
    if ( FAILURE==amppwtpe(_a_gzcombcala.fixedflag ? (_temp410_a_gzcombcala=a_gzcombcala,&_temp410_a_gzcombcala) : &a_gzcombcala, _a_gzcombcalb.fixedflag ? (_temp411_a_gzcombcalb=a_gzcombcalb,&_temp411_a_gzcombcalb) : &a_gzcombcalb, _pw_gzcombcal.fixedflag ? (_temp412_pw_gzcombcal=pw_gzcombcal,&_temp412_pw_gzcombcal) : &pw_gzcombcal, 
                           _pw_gzcombcala.fixedflag ? (_temp413_pw_gzcombcala=pw_gzcombcala,&_temp413_pw_gzcombcala) : &pw_gzcombcala, _pw_gzcombcald.fixedflag ? (_temp414_pw_gzcombcald=pw_gzcombcald,&_temp414_pw_gzcombcald) : &pw_gzcombcald,
                           target_amp, target_risetime,
                           temp_area + refocus_cal) )
    {
        epic_error(use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwtpe: slice encode cal");
        return FAILURE;
    }

    encode_cal = 0.5*(float)pw_gzcombcala*a_gzcombcala + 0.5*(float)pw_gzcombcal*(a_gzcombcala
             + a_gzcombcalb) + 0.5*(float)pw_gzcombcald*a_gzcombcalb - fabs(refocus_cal);

    a_delta_cal = 4.0*encode_cal/(float)(cal_slq-1.0)/(PSDRAMPEDTRAP*(float)pw_gzcombcala +
              (1.0+PSDRAMPEDTRAP)*(float)pw_gzcombcal + (float)pw_gzcombcald);
    
    /* max neg amp */
    a_combcal  = _a_combcal.fixedflag ?  ((void)(a_gzcombcalb), a_combcal) : a_gzcombcalb;

    /* max positive amp */
    a_endcal  = _a_endcal.fixedflag ?    ((void)(a_combcal-a_delta_cal*(float)(cal_slq-1)), a_endcal) : a_combcal-a_delta_cal*(float)(cal_slq-1);

    a_gzcombcal  = _a_gzcombcal.fixedflag ?  ((void)(-a_combcal), a_gzcombcal) : -a_combcal;

    /* Z rewinder */
    if ( FAILURE==amppwtpe(_a_gzprcala.fixedflag ? (_temp415_a_gzprcala=a_gzprcala,&_temp415_a_gzprcala) : &a_gzprcala, _a_gzprcalb.fixedflag ? (_temp416_a_gzprcalb=a_gzprcalb,&_temp416_a_gzprcalb) : &a_gzprcalb, _pw_gzprcal.fixedflag ? (_temp417_pw_gzprcal=pw_gzprcal,&_temp417_pw_gzprcal) : &pw_gzprcal, 
                           _pw_gzprcala.fixedflag ? (_temp418_pw_gzprcala=pw_gzprcala,&_temp418_pw_gzprcala) : &pw_gzprcala, _pw_gzprcald.fixedflag ? (_temp419_pw_gzprcald=pw_gzprcald,&_temp419_pw_gzprcald) : &pw_gzprcald,
                           target_amp, target_risetime,
                           temp_area + area_gzkcal) )
    {
        epic_error(use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwtpe:gzpr cal rewinder");
        return FAILURE;
    }
    encode_cal2 = 0.5*(float)pw_gzprcala*a_gzprcala + 0.5*(float)pw_gzprcal*(a_gzprcala
             + a_gzprcalb) + 0.5*(float)pw_gzprcald*a_gzprcalb - area_gzkcal;

    a_delta_cal2 = 4.0*encode_cal2/(float)(cal_slq-1.0)/(PSDRAMPEDTRAP*(float)pw_gzprcala +
              (1.0+PSDRAMPEDTRAP)*(float)pw_gzprcal + (float)pw_gzprcald);
    
    /* max neg amp */
    a_combcal2  = _a_combcal2.fixedflag ?  ((void)(a_gzprcalb), a_combcal2) : a_gzprcalb;

    /* max positive amp */
    a_endcal2  = _a_endcal2.fixedflag ?    ((void)(a_combcal2-a_delta_cal2*(float)(cal_slq-1.0)), a_endcal2) : a_combcal2-a_delta_cal2*(float)(cal_slq-1.0);

    a_gzprcal  = _a_gzprcal.fixedflag ?  ((void)(a_combcal2), a_gzprcal) : a_combcal2;

    /*****************************************************************/
    /*  X Board - readout and dephaser                               */
    /*****************************************************************/

    if ( FAILURE==calcfilter( &echo1cal_filt, echo1bwcal, cal_xres, OVERWRITE_NONE) )
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "calcfilter for echo1cal_filt");

        return FAILURE;
    }

    if((echo1bwcal > 0) && (cal_xfov > 0.0))
    {
        a_gxwcal  = _a_gxwcal.fixedflag ?          ((void)((FLOAT)(2*echo1bwcal*1000/GAM)*(10.0/cal_xfov)), a_gxwcal) : (FLOAT)(2*echo1bwcal*1000/GAM)*(10.0/cal_xfov);
    }
    else
    {
        epic_error(use_ermes,"%s failed",EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1),STRING_ARG,"ampfov for a_gxwcal");
        return FAILURE;
    }

    amp_rt_dbdtopt(_cal_amplimit.fixedflag ? (_temp420_cal_amplimit=cal_amplimit,&_temp420_cal_amplimit) : &cal_amplimit, &target_risetime, cal_slewrate, 1.0, calloggrd.tx_xyz);
    if(a_gxwcal <= cal_amplimit)
    {
        target_amp = cal_amplimit;
    }
    else
    {
        target_amp = calloggrd.tx_xyz;
        target_risetime = calloggrd.xrta.x;  /* rise time for target amp */
    }

    if (FAILURE==optramp(_pw_gxwcala.fixedflag ? (_temp421_pw_gxwcala=pw_gxwcala,&_temp421_pw_gxwcala) : &pw_gxwcala, a_gxwcal, target_amp, target_risetime, TYPDEF))
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "optramp for pw_gxwcala.");
        return FAILURE;
    }
    pw_gxwcald  = _pw_gxwcald.fixedflag ?  ((void)(pw_gxwcala), pw_gxwcald) : pw_gxwcala;

    tacq_cal  = _tacq_cal.fixedflag ?  ((void)(RUP_GRD(echo1cal_filt.tdaq)), tacq_cal) : RUP_GRD(echo1cal_filt.tdaq);

    /* Gx1 */
    area_gxwcal = a_gxwcal*tacq_cal;
    temp_area = 0.5*a_gxwcal*pw_gxwcala;
    amp_rt_dbdtopt(_cal_amplimit.fixedflag ? (_temp422_cal_amplimit=cal_amplimit,&_temp422_cal_amplimit) : &cal_amplimit, &target_risetime, cal_slewrate, 1.0, calloggrd.tx_xyz);
    if (amppwgx1(_a_gx1cal.fixedflag ? (_temp423_a_gx1cal=a_gx1cal,&_temp423_a_gx1cal) : &a_gx1cal, _pw_gx1cal.fixedflag ? (_temp424_pw_gx1cal=pw_gx1cal,&_temp424_pw_gx1cal) : &pw_gx1cal, _pw_gx1cala.fixedflag ? (_temp425_pw_gx1cala=pw_gx1cala,&_temp425_pw_gx1cala) : &pw_gx1cala, _pw_gx1cald.fixedflag ? (_temp426_pw_gx1cald=pw_gx1cald,&_temp426_pw_gx1cald) : &pw_gx1cald,
                 (int)TYPGRAD, area_gxwcal, temp_area,
                 1000000, 1.0, MIN_PLATEAU_TIME,
                 target_risetime, cal_amplimit) == FAILURE)
    {
        epic_error(use_ermes,supfailfmt,EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1),STRING_ARG,"amppwgx1:gx1cal");
    }

    /* X killer -- ext gxwcal */
    temp_area = 5.0e6 * cal_xres/(cal_fov*GAM);
    pw_gxwcal  = _pw_gxwcal.fixedflag ?        ((void)(IMax(2,tacq_cal,RUP_GRD(tacq_cal+temp_area/a_gxwcal-pw_gxwcald/2))), pw_gxwcal) : IMax(2,tacq_cal,RUP_GRD(tacq_cal+temp_area/a_gxwcal-pw_gxwcald/2));


    /***********************************************/
    /*    Y phase encode                           */
    /**********************************************/
    if (endview(cal_yres, _endview_iampcal.fixedflag ? (_temp427_endview_iampcal=endview_iampcal,&_temp427_endview_iampcal) : &endview_iampcal) == FAILURE)
    {
        epic_error(use_ermes,supfailfmt,EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1),STRING_ARG,"endview y for cal");
        return FAILURE;
    } 

    endview_scalecal  = _endview_scalecal.fixedflag ?   ((void)((float)max_pg_iamp/(float)endview_iampcal), endview_scalecal) : (float)max_pg_iamp/(float)endview_iampcal;
    amp_rt_dbdtopt(_cal_amplimit.fixedflag ? (_temp428_cal_amplimit=cal_amplimit,&_temp428_cal_amplimit) : &cal_amplimit, &target_risetime, cal_slewrate, 1.0, calloggrd.ty_xyz);
    target_amp = cal_amplimit/endview_scalecal;
    target_risetime = RUP_GRD(ceil(target_risetime/endview_scalecal));  /* rise time for target amp */
    
    if ( FAILURE==amppwtpe(_a_gy1cala.fixedflag ? (_temp429_a_gy1cala=a_gy1cala,&_temp429_a_gy1cala) : &a_gy1cala, _a_gy1calb.fixedflag ? (_temp430_a_gy1calb=a_gy1calb,&_temp430_a_gy1calb) : &a_gy1calb, _pw_gy1cal.fixedflag ? (_temp431_pw_gy1cal=pw_gy1cal,&_temp431_pw_gy1cal) : &pw_gy1cal, _pw_gy1cala.fixedflag ? (_temp432_pw_gy1cala=pw_gy1cala,&_temp432_pw_gy1cala) : &pw_gy1cala, _pw_gy1cald.fixedflag ? (_temp433_pw_gy1cald=pw_gy1cald,&_temp433_pw_gy1cald) : &pw_gy1cald,
                           target_amp, target_risetime,
                           (0.5 * (FLOAT)(cal_yres-1))/(cal_yfov * 0.1) * 1.0e6/ GAM) )
    {
        epic_error(use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwtpe: cal ");
        return FAILURE;
    }

    /* phase rewinders */
    a_gy1rcal  = _a_gy1rcal.fixedflag ?  ((void)(a_gy1cal), a_gy1rcal) : a_gy1cal;
    a_gy1rcala  = _a_gy1rcala.fixedflag ?  ((void)(a_gy1cala), a_gy1rcala) : a_gy1cala;
    a_gy1rcalb  = _a_gy1rcalb.fixedflag ?  ((void)(a_gy1calb), a_gy1rcalb) : a_gy1calb;
    pw_gy1rcal  = _pw_gy1rcal.fixedflag ?  ((void)(pw_gy1cal), pw_gy1rcal) : pw_gy1cal;
    pw_gy1rcala  = _pw_gy1rcala.fixedflag ?  ((void)(pw_gy1cala), pw_gy1rcala) : pw_gy1cala;
    pw_gy1rcald  = _pw_gy1rcald.fixedflag ?  ((void)(pw_gy1cald), pw_gy1rcald) : pw_gy1cald;


    td0cal  = _td0cal.fixedflag ?  
                                 
                                  ((void)(RUP_GRD((INT)IMax(2,GRAD_UPDATE_TIME,DAB_length[bd_index]+minimumPreRfSspTime()-psd_rf_wait))), td0cal) : RUP_GRD((INT)IMax(2,GRAD_UPDATE_TIME,DAB_length[bd_index]+minimumPreRfSspTime()-psd_rf_wait));
    td0cal  = _td0cal.fixedflag ?    ((void)(RUP_GRD((int)(td0cal+tleadcal))), td0cal) : RUP_GRD((int)(td0cal+tleadcal));

    cal_iso_delay  = _cal_iso_delay.fixedflag ?  
                                     ((void)(RUP_GRD((int)((float)rfpulse[RF1_EXTCAL_SLOT].isodelay*pw_rf1cal/rfpulse[RF1_EXTCAL_SLOT].nom_pw))), cal_iso_delay) : RUP_GRD((int)((float)rfpulse[RF1_EXTCAL_SLOT].isodelay*pw_rf1cal/rfpulse[RF1_EXTCAL_SLOT].nom_pw));

    calt_exa  = _calt_exa.fixedflag ?      ((void)(RUP_GRD(pw_gzrf1cala+pw_gzrf1cal-cal_iso_delay)), calt_exa) : RUP_GRD(pw_gzrf1cala+pw_gzrf1cal-cal_iso_delay);
    calt_exb  = _calt_exb.fixedflag ?  ((void)(cal_iso_delay), calt_exb) : cal_iso_delay;
    temp_time = IMax(4, cfrfupd + cal_btw_rf_rba_ssp + RBA_length[bd_index] + cal_grd_rf_delays,
                     pw_gxwcala + pw_gx1cala + pw_gx1cal + pw_gx1cald,
                     pw_gy1cala + pw_gy1cal + pw_gy1cald,
                     pw_gzrf1cald + pw_gzcombcala + pw_gzcombcal + pw_gzcombcald);

    te_cal  = _te_cal.fixedflag ?        ((void)(IMax(2,500,RUP_GRD(calt_exb+temp_time+tacq_cal/2.0))), te_cal) : IMax(2,500,RUP_GRD(calt_exb+temp_time+tacq_cal/2.0));

    temp_time = IMax(3, pw_gxwcald + pw_gxwcal - tacq_cal,
                     pw_gy1rcala + pw_gy1rcal + pw_gy1rcald,
                     pw_gzprcala + pw_gzprcal + pw_gzprcald);
    tr_cal  = _tr_cal.fixedflag ?              ((void)(RUP_GRD(td0cal+calt_exa+te_cal+tacq_cal/2.0+temp_time+psd_grd_wait+time_ssical)), tr_cal) : RUP_GRD(td0cal+calt_exa+te_cal+tacq_cal/2.0+temp_time+psd_grd_wait+time_ssical);

    cal_tr_interleave  = _cal_tr_interleave.fixedflag ?  ((void)(PSD_OFF), cal_tr_interleave) : PSD_OFF;
    cal_nex_interleave  = _cal_nex_interleave.fixedflag ?  ((void)(PSD_OFF), cal_nex_interleave) : PSD_OFF;

    if(cal_pass > 1)
    {
        if (B0_30000 == cffield)
        {
            if ((isDVSystem() || isRioSystem() || isHRMbSystem()) &&
                ((isCategoryMatchForAnatomy(exist(opanatomy), ATTRIBUTE_CATEGORY_CHEST) && strcmp(PSattribute_codeMeaning, "Breast"))
                 || isCategoryMatchForAnatomy(exist(opanatomy), ATTRIBUTE_CATEGORY_ABDOMEN)
                 || isCategoryMatchForAnatomy(exist(opanatomy), ATTRIBUTE_CATEGORY_PELVIS)))
            {
                cal_nex_interleave  = _cal_nex_interleave.fixedflag ?  ((void)(PSD_OFF), cal_nex_interleave) : PSD_OFF;
                cal_tr_interleave  = _cal_tr_interleave.fixedflag ?  ((void)(PSD_ON), cal_tr_interleave) : PSD_ON;
            }
            else
            {
                cal_nex_interleave  = _cal_nex_interleave.fixedflag ?  ((void)(PSD_ON), cal_nex_interleave) : PSD_ON;
                cal_tr_interleave  = _cal_tr_interleave.fixedflag ?  ((void)(PSD_OFF), cal_tr_interleave) : PSD_OFF;
            }
        }
        else
        {
            cal_nex_interleave  = _cal_nex_interleave.fixedflag ?  ((void)(PSD_OFF), cal_nex_interleave) : PSD_OFF;
            cal_tr_interleave  = _cal_tr_interleave.fixedflag ?  ((void)(PSD_OFF), cal_tr_interleave) : PSD_OFF;
        }
    }

    /* set up CV cal_interleave mode */
    if (cal_nex_interleave)
    {
        cal_interleave  = _cal_interleave.fixedflag ?  ((void)(CAL_NEX_INTERLEAVED), cal_interleave) : CAL_NEX_INTERLEAVED;
        cal_tr_interleave  = _cal_tr_interleave.fixedflag ?  ((void)(PSD_OFF), cal_tr_interleave) : PSD_OFF;
    }
    else if (cal_tr_interleave)
    {
        cal_interleave  = _cal_interleave.fixedflag ?  ((void)(CAL_TR_INTERLEAVED), cal_interleave) : CAL_TR_INTERLEAVED;
    }
    else
    {
        cal_interleave  = _cal_interleave.fixedflag ?  ((void)(CAL_NONE_INTERLEAVED), cal_interleave) : CAL_NONE_INTERLEAVED;
    }

    cal_delay_dda  = _cal_delay_dda.fixedflag ?  ((void)(((int)(cal_delay/(float)tr_cal)/2)*2), cal_delay_dda) : ((int)(cal_delay/(float)tr_cal)/2)*2;  /* delay for long T1 signal to recover */


    return SUCCESS;
} /* End of ExtCalcveval */


/* 
 *  AutoCoilcveval
 *  Description:
 *  CV eval for AutoCoil entry point 
 *  
 *  Type: Public Function
 *  
 *  
 */
STATUS
AutoCoilcveval( void )
{
    FLOAT temp_area;
    FLOAT refocus_coil;
    FLOAT encode_coil = 0.0;
    FLOAT a_delta_coil = 0.0;
    FLOAT encode_coil2 = 0.0;
    FLOAT a_delta_coil2 = 0.0;
    FLOAT area_gxwcoil;
    FLOAT area_gzkcoil = 300.0;
    INT temp_time;
    FLOAT target_amp = 1.0;
    INT target_risetime = 4;

    /* freq/phase scaling for image cut reduction */
    coil_freq_scale  = _coil_freq_scale.fixedflag ?  ((void)(coilscan_info[0].opfov_freq_scale), coil_freq_scale) : coilscan_info[0].opfov_freq_scale;
    coil_phase_scale  = _coil_phase_scale.fixedflag ?  ((void)(coilscan_info[0].opfov_phase_scale), coil_phase_scale) : coilscan_info[0].opfov_phase_scale;

    if(coil_freq_scale <= 0.0)
    {
        coil_freq_scale  = _coil_freq_scale.fixedflag ?  ((void)(1.0), coil_freq_scale) : 1.0;
    }
    if(coil_phase_scale <= 0.0)
    {
        coil_phase_scale  = _coil_phase_scale.fixedflag ?  ((void)(1.0), coil_phase_scale) : 1.0;
    }
    coil_xfov  = _coil_xfov.fixedflag ?  ((void)(coil_fov*coil_freq_scale), coil_xfov) : coil_fov*coil_freq_scale;
    coil_yfov  = _coil_yfov.fixedflag ?  ((void)(coil_fov*coil_phase_scale), coil_yfov) : coil_fov*coil_phase_scale;

    /*****************************************************/
    /*   Z gradients                                     */  
    /*****************************************************/
    pw_gzrf1coil  = _pw_gzrf1coil.fixedflag ?  ((void)(pw_rf1coil), pw_gzrf1coil) : pw_rf1coil;

    coil_vthick  = _coil_vthick.fixedflag ?    ((void)(coil_slthick*coil_slq), coil_vthick) : coil_slthick*coil_slq;
    bw_rf1coil  = _bw_rf1coil.fixedflag ?  ((void)((int)rfpulse[RF1_AUTOCOIL_SLOT].nom_bw*rfpulse[RF1_AUTOCOIL_SLOT].nom_pw/pw_rf1coil), bw_rf1coil) : (int)rfpulse[RF1_AUTOCOIL_SLOT].nom_bw*rfpulse[RF1_AUTOCOIL_SLOT].nom_pw/pw_rf1coil;

    if (ampslice(_a_gzrf1coil.fixedflag ? (_temp434_a_gzrf1coil=a_gzrf1coil,&_temp434_a_gzrf1coil) : &a_gzrf1coil, bw_rf1coil, coil_vthick, 1.0, TYPDEF) == FAILURE) {
        epic_error(use_ermes, supfailfmt,
                   EM_PSD_SUPPORT_FAILURE,EE_ARGS(1),STRING_ARG,"amplice (for gzrf1coil)");
        return FAILURE;
    }

    a_gzrf1coil  = _a_gzrf1coil.fixedflag ?    ((void)(1.05*coil_slq/(coil_slq-4)*a_gzrf1coil), a_gzrf1coil) : 1.05*coil_slq/(coil_slq-4)*a_gzrf1coil;   /* scale for slice blank of 2 */

    amp_rt_dbdtopt(_coil_amplimit.fixedflag ? (_temp435_coil_amplimit=coil_amplimit,&_temp435_coil_amplimit) : &coil_amplimit, &target_risetime, coil_slewrate, 1.0, coilloggrd.tz);
    if(a_gzrf1coil <= coil_amplimit)
    {
        target_amp = coil_amplimit;
    }
    else
    {
        target_amp = coilloggrd.tz;
        target_risetime = coilloggrd.zrta.z;  /* rise time for target amp */
    }

    if (optramp(_pw_gzrf1coila.fixedflag ? (_temp436_pw_gzrf1coila=pw_gzrf1coila,&_temp436_pw_gzrf1coila) : &pw_gzrf1coila, a_gzrf1coil, target_amp, target_risetime, TYPDEF) == FAILURE) {
        epic_error(use_ermes, supfailfmt,
                   EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                   STRING_ARG, "optramp (for gzrf1coila)");
        return FAILURE;
    }
    pw_gzrf1coild  = _pw_gzrf1coild.fixedflag ?  ((void)(pw_gzrf1coila), pw_gzrf1coild) : pw_gzrf1coila;

    if (endview(coil_slq, _endviewz_iampcoil.fixedflag ? (_temp437_endviewz_iampcoil=endviewz_iampcoil,&_temp437_endviewz_iampcoil) : &endviewz_iampcoil) == FAILURE)
    {
        epic_error(use_ermes,supfailfmt,EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1),STRING_ARG,"endview:gzcombcoil");
        return FAILURE;
    } 
    endviewz_scalecoil  = _endviewz_scalecoil.fixedflag ?   ((void)((float)max_pg_iamp/(float)endviewz_iampcoil), endviewz_scalecoil) : (float)max_pg_iamp/(float)endviewz_iampcoil;

    refocus_coil = fabs(a_gzrf1coil)*(coil_iso_delay + pw_gzrf1coild/2.0);
    temp_area = (0.5 * (FLOAT)(coil_slq-1))/(coil_vthick * 0.1) * 1.0e6/ GAM;

    amp_rt_dbdtopt(_coil_amplimit.fixedflag ? (_temp438_coil_amplimit=coil_amplimit,&_temp438_coil_amplimit) : &coil_amplimit, &target_risetime, coil_slewrate, 1.0, coilloggrd.tz_xyz);
    target_amp = coil_amplimit/endviewz_scalecal;
    target_risetime = RUP_GRD(ceil(target_risetime/endviewz_scalecal));  /* rise time for target amp */
    /* Z slice encode + gzrf1 refocus */
    if ( FAILURE==amppwtpe(_a_gzcombcoila.fixedflag ? (_temp439_a_gzcombcoila=a_gzcombcoila,&_temp439_a_gzcombcoila) : &a_gzcombcoila, _a_gzcombcoilb.fixedflag ? (_temp440_a_gzcombcoilb=a_gzcombcoilb,&_temp440_a_gzcombcoilb) : &a_gzcombcoilb, _pw_gzcombcoil.fixedflag ? (_temp441_pw_gzcombcoil=pw_gzcombcoil,&_temp441_pw_gzcombcoil) : &pw_gzcombcoil, 
                           _pw_gzcombcoila.fixedflag ? (_temp442_pw_gzcombcoila=pw_gzcombcoila,&_temp442_pw_gzcombcoila) : &pw_gzcombcoila, _pw_gzcombcoild.fixedflag ? (_temp443_pw_gzcombcoild=pw_gzcombcoild,&_temp443_pw_gzcombcoild) : &pw_gzcombcoild,
                           target_amp, target_risetime,
                           temp_area + refocus_coil) )
    {
        epic_error(use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwtpe: slice encode for auto coil");
        return FAILURE;
    }

    encode_coil = 0.5*(float)pw_gzcombcoila*a_gzcombcoila + 0.5*(float)pw_gzcombcoil*(a_gzcombcoila
             + a_gzcombcoilb) + 0.5*(float)pw_gzcombcoild*a_gzcombcoilb - fabs(refocus_coil);

    a_delta_coil = 4.0*encode_coil/(float)(coil_slq-1.0)/(PSDRAMPEDTRAP*(float)pw_gzcombcoila +
              (1.0+PSDRAMPEDTRAP)*(float)pw_gzcombcoil + (float)pw_gzcombcoild);
    
    /* max neg amp */
    a_combcoil  = _a_combcoil.fixedflag ?  ((void)(a_gzcombcoilb), a_combcoil) : a_gzcombcoilb;

    /* max positive amp */
    a_endcoil  = _a_endcoil.fixedflag ?    ((void)(a_combcoil-a_delta_coil*(float)(coil_slq-1.0)), a_endcoil) : a_combcoil-a_delta_coil*(float)(coil_slq-1.0);

    a_gzcombcoil  = _a_gzcombcoil.fixedflag ?  ((void)(-a_combcoil), a_gzcombcoil) : -a_combcoil;

    /* Z rewinder */
    if ( FAILURE==amppwtpe(_a_gzprcoila.fixedflag ? (_temp444_a_gzprcoila=a_gzprcoila,&_temp444_a_gzprcoila) : &a_gzprcoila, _a_gzprcoilb.fixedflag ? (_temp445_a_gzprcoilb=a_gzprcoilb,&_temp445_a_gzprcoilb) : &a_gzprcoilb, _pw_gzprcoil.fixedflag ? (_temp446_pw_gzprcoil=pw_gzprcoil,&_temp446_pw_gzprcoil) : &pw_gzprcoil, 
                           _pw_gzprcoila.fixedflag ? (_temp447_pw_gzprcoila=pw_gzprcoila,&_temp447_pw_gzprcoila) : &pw_gzprcoila, _pw_gzprcoild.fixedflag ? (_temp448_pw_gzprcoild=pw_gzprcoild,&_temp448_pw_gzprcoild) : &pw_gzprcoild,
                           target_amp, target_risetime,
                           temp_area + area_gzkcoil) )
    {
        epic_error(use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwtpe:gzpr autocoil rewinder");
        return FAILURE;
    }
    encode_coil2 = 0.5*(float)pw_gzprcoila*a_gzprcoila + 0.5*(float)pw_gzprcoil*(a_gzprcoila
             + a_gzprcoilb) + 0.5*(float)pw_gzprcoild*a_gzprcoilb - area_gzkcoil;

    a_delta_coil2 = 4.0*encode_coil2/(float)(coil_slq-1.0)/(PSDRAMPEDTRAP*(float)pw_gzprcoila +
              (1.0+PSDRAMPEDTRAP)*(float)pw_gzprcoil + (float)pw_gzprcoild);
    
    /* max neg amp */
    a_combcoil2  = _a_combcoil2.fixedflag ?  ((void)(a_gzprcoilb), a_combcoil2) : a_gzprcoilb;

    /* max positive amp */
    a_endcoil2  = _a_endcoil2.fixedflag ?    ((void)(a_combcoil2-a_delta_coil2*(float)(coil_slq-1.0)), a_endcoil2) : a_combcoil2-a_delta_coil2*(float)(coil_slq-1.0);

    a_gzprcoil  = _a_gzprcoil.fixedflag ?  ((void)(a_combcoil2), a_gzprcoil) : a_combcoil2;

    /*****************************************************************/
    /*  X Board - readout and dephaser                               */
    /*****************************************************************/

    if ( FAILURE==calcfilter( &echo1coil_filt, echo1bwcoil, coil_xres, OVERWRITE_NONE) )
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "coilcfilter for echo1coil_filt");

        return FAILURE;
    }

    if ((echo1bwcoil > 0) && (coil_xfov > 0.0))
    {
        a_gxwcoil  = _a_gxwcoil.fixedflag ?         ((void)((FLOAT)(2*echo1bwcoil*1000/GAM)*(10.0/coil_xfov)), a_gxwcoil) : (FLOAT)(2*echo1bwcoil*1000/GAM)*(10.0/coil_xfov);
    }   
    else
    {
        epic_error(use_ermes,"%s failed",EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1),STRING_ARG,"ampfov for a_gxwcoil");
        return FAILURE;
    }

    amp_rt_dbdtopt(_coil_amplimit.fixedflag ? (_temp449_coil_amplimit=coil_amplimit,&_temp449_coil_amplimit) : &coil_amplimit, &target_risetime, coil_slewrate, 1.0, coilloggrd.tx_xyz);
    if(a_gxwcoil <= coil_amplimit)
    {
        target_amp = coil_amplimit;
    }
    else
    {
        target_amp = coilloggrd.tx_xyz;
        target_risetime = coilloggrd.xrta.x;  /* rise time for target amp */
    }

    if (FAILURE==optramp(_pw_gxwcoila.fixedflag ? (_temp450_pw_gxwcoila=pw_gxwcoila,&_temp450_pw_gxwcoila) : &pw_gxwcoila, a_gxwcoil, target_amp, target_risetime, TYPDEF))
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "optramp for pw_gxwcoila.");
        return FAILURE;
    }
    pw_gxwcoild  = _pw_gxwcoild.fixedflag ?  ((void)(pw_gxwcoila), pw_gxwcoild) : pw_gxwcoila;

    tacq_coil  = _tacq_coil.fixedflag ?  ((void)(RUP_GRD(echo1coil_filt.tdaq)), tacq_coil) : RUP_GRD(echo1coil_filt.tdaq);

    /* Gx1 */
    area_gxwcoil = a_gxwcoil*tacq_coil;
    temp_area = 0.5*a_gxwcoil*pw_gxwcoila;

    amp_rt_dbdtopt(_coil_amplimit.fixedflag ? (_temp451_coil_amplimit=coil_amplimit,&_temp451_coil_amplimit) : &coil_amplimit, &target_risetime, coil_slewrate, 1.0, coilloggrd.tx_xyz);
    if (amppwgx1(_a_gx1coil.fixedflag ? (_temp452_a_gx1coil=a_gx1coil,&_temp452_a_gx1coil) : &a_gx1coil, _pw_gx1coil.fixedflag ? (_temp453_pw_gx1coil=pw_gx1coil,&_temp453_pw_gx1coil) : &pw_gx1coil, _pw_gx1coila.fixedflag ? (_temp454_pw_gx1coila=pw_gx1coila,&_temp454_pw_gx1coila) : &pw_gx1coila, _pw_gx1coild.fixedflag ? (_temp455_pw_gx1coild=pw_gx1coild,&_temp455_pw_gx1coild) : &pw_gx1coild,
                 (int)TYPGRAD, area_gxwcoil, temp_area,
                 1000000, 1.0, MIN_PLATEAU_TIME,
                 target_risetime, coil_amplimit) == FAILURE)
    {
        epic_error(use_ermes,supfailfmt,EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1),STRING_ARG,"amppwgx1:gx1coil");
    }

    /* X killer -- ext gxwcoil */
    temp_area = 5.0e6 * coil_xres/(coil_fov*GAM);
    pw_gxwcoil  = _pw_gxwcoil.fixedflag ?        ((void)(IMax(2,tacq_coil,RUP_GRD(tacq_coil+temp_area/a_gxwcoil-pw_gxwcoild/2))), pw_gxwcoil) : IMax(2,tacq_coil,RUP_GRD(tacq_coil+temp_area/a_gxwcoil-pw_gxwcoild/2));


    /***********************************************/
    /*    Y phase encode                           */
    /**********************************************/
    if (endview(coil_yres, _endview_iampcoil.fixedflag ? (_temp456_endview_iampcoil=endview_iampcoil,&_temp456_endview_iampcoil) : &endview_iampcoil) == FAILURE)
    {
        epic_error(use_ermes,supfailfmt,EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1),STRING_ARG,"endview y for coil");
        return FAILURE;
    } 
    endview_scalecoil  = _endview_scalecoil.fixedflag ?   ((void)((float)max_pg_iamp/(float)endview_iampcoil), endview_scalecoil) : (float)max_pg_iamp/(float)endview_iampcoil;

    amp_rt_dbdtopt(_coil_amplimit.fixedflag ? (_temp457_coil_amplimit=coil_amplimit,&_temp457_coil_amplimit) : &coil_amplimit, &target_risetime, coil_slewrate, 1.0, coilloggrd.ty_xyz);
    target_amp = coil_amplimit/endview_scalecoil;
    target_risetime = RUP_GRD(ceil(target_risetime/endview_scalecoil));  /* rise time for target amp */

    if ( FAILURE==amppwtpe(_a_gy1coila.fixedflag ? (_temp458_a_gy1coila=a_gy1coila,&_temp458_a_gy1coila) : &a_gy1coila, _a_gy1coilb.fixedflag ? (_temp459_a_gy1coilb=a_gy1coilb,&_temp459_a_gy1coilb) : &a_gy1coilb, _pw_gy1coil.fixedflag ? (_temp460_pw_gy1coil=pw_gy1coil,&_temp460_pw_gy1coil) : &pw_gy1coil, _pw_gy1coila.fixedflag ? (_temp461_pw_gy1coila=pw_gy1coila,&_temp461_pw_gy1coila) : &pw_gy1coila, _pw_gy1coild.fixedflag ? (_temp462_pw_gy1coild=pw_gy1coild,&_temp462_pw_gy1coild) : &pw_gy1coild,
                           target_amp, target_risetime,
                           (0.5 * (FLOAT)(coil_yres-1))/(coil_yfov * 0.1) * 1.0e6/ GAM) )
    {
        epic_error(use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwtpe: coil ");
        return FAILURE;
    }

    /* phase rewinders */
    a_gy1rcoil  = _a_gy1rcoil.fixedflag ?  ((void)(a_gy1coil), a_gy1rcoil) : a_gy1coil;
    a_gy1rcoila  = _a_gy1rcoila.fixedflag ?  ((void)(a_gy1coila), a_gy1rcoila) : a_gy1coila;
    a_gy1rcoilb  = _a_gy1rcoilb.fixedflag ?  ((void)(a_gy1coilb), a_gy1rcoilb) : a_gy1coilb;
    pw_gy1rcoil  = _pw_gy1rcoil.fixedflag ?  ((void)(pw_gy1coil), pw_gy1rcoil) : pw_gy1coil;
    pw_gy1rcoila  = _pw_gy1rcoila.fixedflag ?  ((void)(pw_gy1coila), pw_gy1rcoila) : pw_gy1coila;
    pw_gy1rcoild  = _pw_gy1rcoild.fixedflag ?  ((void)(pw_gy1coild), pw_gy1rcoild) : pw_gy1coild;


    td0coil  = _td0coil.fixedflag ?  
                                 
                                  ((void)(RUP_GRD((INT)IMax(2,GRAD_UPDATE_TIME,DAB_length[bd_index]+minimumPreRfSspTime()-psd_rf_wait))), td0coil) : RUP_GRD((INT)IMax(2,GRAD_UPDATE_TIME,DAB_length[bd_index]+minimumPreRfSspTime()-psd_rf_wait));
    td0coil  = _td0coil.fixedflag ?    ((void)(RUP_GRD((int)(td0coil+tleadcoil))), td0coil) : RUP_GRD((int)(td0coil+tleadcoil));

    coil_iso_delay  = _coil_iso_delay.fixedflag ?  
                                     ((void)(RUP_GRD((int)((float)rfpulse[RF1_AUTOCOIL_SLOT].isodelay*pw_rf1coil/rfpulse[RF1_AUTOCOIL_SLOT].nom_pw))), coil_iso_delay) : RUP_GRD((int)((float)rfpulse[RF1_AUTOCOIL_SLOT].isodelay*pw_rf1coil/rfpulse[RF1_AUTOCOIL_SLOT].nom_pw));

    coilt_exa  = _coilt_exa.fixedflag ?      ((void)(RUP_GRD(pw_gzrf1coila+pw_gzrf1coil-coil_iso_delay)), coilt_exa) : RUP_GRD(pw_gzrf1coila+pw_gzrf1coil-coil_iso_delay);
    coilt_exb  = _coilt_exb.fixedflag ?  ((void)(coil_iso_delay), coilt_exb) : coil_iso_delay;
    temp_time = IMax(4, cfrfupd + cal_btw_rf_rba_ssp + RBA_length[bd_index] + cal_grd_rf_delays,
                     pw_gxwcoila + pw_gx1coila + pw_gx1coil + pw_gx1coild,
                     pw_gy1coila + pw_gy1coil + pw_gy1coild,
                     pw_gzrf1coild + pw_gzcombcoila + pw_gzcombcoil + pw_gzcombcoild);

    te_coil  = _te_coil.fixedflag ?        ((void)(IMax(2,500,RUP_GRD(coilt_exb+temp_time+tacq_coil/2.0))), te_coil) : IMax(2,500,RUP_GRD(coilt_exb+temp_time+tacq_coil/2.0));

    temp_time = IMax(3, pw_gxwcoild + pw_gxwcoil - tacq_coil,
                     pw_gy1rcoila + pw_gy1rcoil + pw_gy1rcoild,
                     pw_gzprcoila + pw_gzprcoil + pw_gzprcoild);
    tr_coil  = _tr_coil.fixedflag ?              ((void)(RUP_GRD(td0coil+coilt_exa+te_coil+tacq_coil/2.0+psd_grd_wait+temp_time+time_ssicoil)), tr_coil) : RUP_GRD(td0coil+coilt_exa+te_coil+tacq_coil/2.0+psd_grd_wait+temp_time+time_ssicoil);

    coil_interleave  = _coil_interleave.fixedflag ?      ((void)(coil_nex_interleave?CAL_NEX_INTERLEAVED:0), coil_interleave) : coil_nex_interleave?CAL_NEX_INTERLEAVED:0;

    return SUCCESS;
} /* End of AutoCoilcveval */


/*
 *  RGcvinit
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
RGcvinit( void )
{
    return SUCCESS;
}


/*
 *  RGcveval
 *
 *  Type: Public Function
 *
 *  Description:
 *
 */
STATUS
RGcveval( void )
{
    if (PSD_ON == rgfeature_enable) 
    { 
        cvmod( opuser39, RG_CAL_MODE_MEASURED, RG_CAL_MODE_HIGH_FIXED, RG_CAL_MODE_HIGH_FIXED, 
               "Receiver Gain (0:Prescan Measured, 1:Predefined)", 0, "" );

        if ( (PSD_2D == exist(opimode)) &&
             ((PSD_SE == exist(oppseq)) || (PSD_IR == exist(oppseq))) &&
             (exist(opptsize) == 4) &&
             (exist(opslthick) <= 10) ) 
        {
            opuser39  = _opuser39.fixedflag ?  ((void)(_opuser39.defval), opuser39) : _opuser39.defval;
            activate_reserved_usercv(39);

            if( existcv(opuser39) && 
                !floatsAlmostEqualEpsilons(exist(opuser39), _opuser39.minval, 2) &&
                !floatsAlmostEqualEpsilons(exist(opuser39), _opuser39.maxval, 2) )
            {
                epic_error(use_ermes, "%s must be 0 or 1", EM_PSD_CV_0_OR_1,
                           EE_ARGS(1), STRING_ARG, "UserCV39");

                return FAILURE;
            }

            oprgcalmode  = _oprgcalmode.fixedflag ?  ((void)((int)rint(exist(opuser39))), oprgcalmode) : (int)rint(exist(opuser39));
        }
        else 
        {
            opuser39  = _opuser39.fixedflag ?  ((void)(0), opuser39) : 0;
            deactivate_reserved_usercv(39);

            oprgcalmode  = _oprgcalmode.fixedflag ?  ((void)(RG_CAL_MODE_MEASURED), oprgcalmode) : RG_CAL_MODE_MEASURED;
        }
    } 
    else 
    {
        opuser39  = _opuser39.fixedflag ?  ((void)(0), opuser39) : 0;
        deactivate_reserved_usercv(39);

        oprgcalmode  = _oprgcalmode.fixedflag ?  ((void)(RG_CAL_MODE_MEASURED), oprgcalmode) : RG_CAL_MODE_MEASURED;
    }

    return SUCCESS;
}   /* end RGcveval() */

/*
 *  PSfilter
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
PSfilter( void )
{
    if (setfilter( &echo1cfl,PRESCAN) == FAILURE) {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "setfilter");
        return FAILURE;
    }
    filter_cfl_fid  = _filter_cfl_fid.fixedflag ?  ((void)(echo1cfl.fslot), filter_cfl_fid) : echo1cfl.fslot;

    if (setfilter( &echo1rcvn,PRESCAN) == FAILURE) {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "setfilter");
        return FAILURE;
    }
    filter_rcvn_fid  = _filter_rcvn_fid.fixedflag ?  ((void)(echo1rcvn.fslot), filter_rcvn_fid) : echo1rcvn.fslot;

    if (setfilter(&echo1cfh, PRESCAN) == FAILURE) {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "setfilter");
        return FAILURE;
    }
    filter_cfh_fid  = _filter_cfh_fid.fixedflag ?  ((void)(echo1cfh.fslot), filter_cfh_fid) : echo1cfh.fslot;


    if (setfilter(&echo1mps1_filt, PRESCAN) == FAILURE) {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "setfilter");
        return FAILURE;
    }
    filter_echo1mps1  = _filter_echo1mps1.fixedflag ?  ((void)(echo1mps1_filt.fslot), filter_echo1mps1) : echo1mps1_filt.fslot;

    if (setfilter(&echo1ftg_filt, PRESCAN) == FAILURE) {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "setfilter");
        return FAILURE;
    }
    filter_echo1ftg   = _filter_echo1ftg.fixedflag ?  ((void)(echo1ftg_filt.fslot), filter_echo1ftg) : echo1ftg_filt.fslot; /* 11/24/94 YI */
    filter_echo2ftg  = _filter_echo2ftg.fixedflag ?   ((void)(filter_echo1ftg), filter_echo2ftg) : filter_echo1ftg;

    if (setfilter(&echo1xtg_filt, PRESCAN) == FAILURE) {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "setfilter");
        return FAILURE;
    }
    filter_echo1xtg   = _filter_echo1xtg.fixedflag ?  ((void)(echo1xtg_filt.fslot), filter_echo1xtg) : echo1xtg_filt.fslot;

    if (setfilter(&echo1as_filt, PRESCAN)  == FAILURE) {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "setfilter");
        return FAILURE;
    }
    filter_echo1as  = _filter_echo1as.fixedflag ?  ((void)(echo1as_filt.fslot), filter_echo1as) : echo1as_filt.fslot;

    if (setfilter(&echo1rs_filt, PRESCAN)  == FAILURE) {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "setfilter rs");
        return FAILURE;
    }
    filter_echo1rs  = _filter_echo1rs.fixedflag ?  ((void)(echo1rs_filt.fslot), filter_echo1rs) : echo1rs_filt.fslot;

    if (setfilter(&echo1dtg_filt, PRESCAN)  == FAILURE) {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "setfilter dtg");
        return FAILURE;
    }
    filter_echo1dtg  = _filter_echo1dtg.fixedflag ?  ((void)(echo1dtg_filt.fslot), filter_echo1dtg) : echo1dtg_filt.fslot;

    if (setfilter(&echo1cal_filt, PRESCAN)  == FAILURE) {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "setfilter cal");
        return FAILURE;
    }
    filter_echo1cal  = _filter_echo1cal.fixedflag ?  ((void)(echo1cal_filt.fslot), filter_echo1cal) : echo1cal_filt.fslot;

    if (setfilter(&echo1coil_filt, PRESCAN)  == FAILURE) {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "setfilter coil");
        return FAILURE;
    }
    filter_echo1coil  = _filter_echo1coil.fixedflag ?  ((void)(echo1coil_filt.fslot), filter_echo1coil) : echo1coil_filt.fslot;

    return SUCCESS;
}   /* end PSfilter() */


/*
 *  PS1predownload
 *  
 *  Type: Private Function
 *  
 *  Description:
 *  
 */
STATUS
PS1predownload( void )
{
    /* Set xmtaddAPS1 according to maximum B1 and rescale for powermon,
       adding additional (audio) scaling if xmtaddAPS1 is too big.
       Add in coilatten, too. */
    xmtaddAPS1  = _xmtaddAPS1.fixedflag ?    ((void)(-200*log10(maxB1[L_APS1]/maxB1Seq)+getCoilAtten()), xmtaddAPS1) : -200*log10(maxB1[L_APS1]/maxB1Seq)+getCoilAtten();
    if (xmtaddAPS1 > cfdbmax)
    {
        ps1scale  = _ps1scale.fixedflag ?      ((void)((float)pow(10.0,(cfdbmax-xmtaddAPS1)/200.0)), ps1scale) : (float)pow(10.0,(cfdbmax-xmtaddAPS1)/200.0);
        xmtaddAPS1  = _xmtaddAPS1.fixedflag ?  ((void)(cfdbmax), xmtaddAPS1) : cfdbmax;
    }
    else
    {
        ps1scale  = _ps1scale.fixedflag ?  ((void)(1.0), ps1scale) : 1.0;
    }
  
    if( ((B0_30000 == cffield) && (PSD_XRMW_COIL == cfgcoiltype || PSD_VRMW_COIL == cfgcoiltype)) 
        || isRioSystem() || isHRMbSystem())
    {
        /* MRIhc57081: Limit TG to coil peak B1 on MR750w */
        calcTGLimit(_tgcap.fixedflag ? (_temp463_tgcap=tgcap,&_temp463_tgcap) : &tgcap, _tgwindow.fixedflag ? (_temp464_tgwindow=tgwindow,&_temp464_tgwindow) : &tgwindow, maxB1Seq, txCoilInfo[getTxIndex(coilInfo[0])]);
    }
    else
    {
        /* Otherwise use defaults */
        tgcap  = _tgcap.fixedflag ?  ((void)(_tgcap.defval), tgcap) : _tgcap.defval;
        tgwindow  = _tgwindow.fixedflag ?  ((void)(_tgwindow.defval), tgwindow) : _tgwindow.defval;
    }

    if (setScale(L_APS1, RF_FREE, rfpulse, maxB1[L_APS1], 
                 ps1scale) == FAILURE)
    {
        epic_error(use_ermes, "%s failed.",
                   EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                   STRING_ARG, "setScale ps1");
        return FAILURE;
    }

    ia_rf1mps1  = _ia_rf1mps1.fixedflag ?  ((void)((int)(max_pg_iamp*(*rfpulse[RF1_APS1_SLOT].amp))), ia_rf1mps1) : (int)(max_pg_iamp*(*rfpulse[RF1_APS1_SLOT].amp));
    ia_rf2mps1  = _ia_rf2mps1.fixedflag ?  ((void)((int)(max_pg_iamp*(*rfpulse[RF2_APS1_SLOT].amp))), ia_rf2mps1) : (int)(max_pg_iamp*(*rfpulse[RF2_APS1_SLOT].amp));

    entry_point_table[L_APS1].epxmtadd = (short) rint((double)xmtaddAPS1);
    /* APS1 & MPS1 */
    strcpy(entry_point_table[L_APS1].epname,"aps1");
    entry_point_table[L_APS1].epfilter=(n8)filter_echo1mps1;

    /* MRIge75651 */
    if( powermon( &entry_point_table[L_APS1],
                  L_APS1,
                  (int)RF_FREE,
                  rfpulse,
                  ps1_tr ) == FAILURE )
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "powermon ps1");
        return FAILURE;
    }

    /* Check for multiple Tx coils. This routine is optimized only
     * for single Tx coil. */ 
    if (1 != getNumTxCoils(coilInfo, opncoils))
    {
        epic_error( use_ermes,
                    "%s does not support more than one transmit coil",
                    EM_PSD_MULTI_TX_NOT_SUPPORTED, EE_ARGS(1), STRING_ARG,
                    "Prescan");
        return FAILURE;
    }

#ifdef BURST_MODE_SUPPORT
    /* Call minseq() to calculate Burst Mode model inputs.
       Disable writing corner points files for prescan entry points. */
    int gradHeatFile_save = gradHeatFile;
    gradHeatFile  = _gradHeatFile.fixedflag ?  ((void)(FALSE), gradHeatFile) : FALSE;
    if ( FAILURE == minseq( _min_seqgrad.fixedflag ? (_temp465_min_seqgrad=min_seqgrad,&_temp465_min_seqgrad) : &min_seqgrad,
                            gradx, GX_FREE,
                            grady, GY_FREE,
                            gradz, GZ_FREE,
                            &loggrd, idx_seqmps1, tsamp, tmin,
                            use_ermes, seg_debug ) ) {
        epic_error( use_ermes, "%s failed.",
                    EM_PSD_ROUTINE_FAILURE, EE_ARGS(1), STRING_ARG, "minseq" );
        return FAILURE;
    }
    gradHeatFile  = _gradHeatFile.fixedflag ?  ((void)(gradHeatFile_save), gradHeatFile) : gradHeatFile_save;
#endif

    /* If aps1_mod set to 1 and NOT breast R or L coil, use volRec coil to set TG */
    if ( (getAps1Mod() > 0) && (PSD_OFF == ps1_rxcoil) )
    {
        if (volRecCoilInfo[0].hubIndex != coilInfo[0].hubIndex)
        {
            UpdateEntryTabRecCoil(&entry_point_table[L_APS1], &volRecCoilInfo[0]);
        }
    }

    /* copy APS1 to MPS1 */
    entry_point_table[L_MPS1] = entry_point_table[L_APS1];

    strcpy(entry_point_table[L_MPS1].epname, "mps1");

    /* This is usually equal to the scan entry point.
       Make sure it is continuous for manual prescan */
    entry_point_table[L_MPS1].eppmtable.pmContinuousUpdate = 1;
    entry_point_table[L_MPS2].eppmtable.pmContinuousUpdate = 1;

    return SUCCESS;
}

/*
 *  CFLpredownload
 *  
 *  Type: Private Function
 *  
 *  Description:
 *  
 */
STATUS
CFLpredownload( void )
{
    /* Sample time for cfl */
    pitsp1 = echo1cfl.tdaq/echo1cfl.outputs;

    xmtaddCFL  = _xmtaddCFL.fixedflag ?    ((void)(-200*log10(maxB1[L_CFL]/maxB1Seq)+getCoilAtten()), xmtaddCFL) : -200*log10(maxB1[L_CFL]/maxB1Seq)+getCoilAtten();
    if (xmtaddCFL > cfdbmax)
    {
        cflscale  = _cflscale.fixedflag ?      ((void)((float)pow(10.0,(cfdbmax-xmtaddCFL)/200.0)), cflscale) : (float)pow(10.0,(cfdbmax-xmtaddCFL)/200.0);
        xmtaddCFL  = _xmtaddCFL.fixedflag ?  ((void)(cfdbmax), xmtaddCFL) : cfdbmax;
    }
    else
    {
        cflscale  = _cflscale.fixedflag ?  ((void)(1.0), cflscale) : 1.0;
    }

    if (setScale(L_CFL, RF_FREE, rfpulse, maxB1[L_CFL], 
                 cflscale) == FAILURE)
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "setScale cfl");
        return FAILURE;
    }

    ia_rf1cfl  = _ia_rf1cfl.fixedflag ?  ((void)((int)(max_pg_iamp*(*rfpulse[RF1_CFL_SLOT].amp))), ia_rf1cfl) : (int)(max_pg_iamp*(*rfpulse[RF1_CFL_SLOT].amp));

    entry_point_table[L_CFL].epxmtadd = (short) rint((double)xmtaddCFL);

    entry_point_table[L_CFL].epprexres = (s16)CFLxres; /* MRIhc54366 */

    strcpy(entry_point_table[L_CFL].epname,"cfl");
    entry_point_table[L_CFL].epfilter=(n8)filter_cfl_fid;
    
    /* MRIge75651 */
    if( powermon( &entry_point_table[L_CFL],
                  L_CFL,
                  (int)RF_FREE,
                  rfpulse,
                  cfl_tr ) == FAILURE )
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "powermon cfl");
        return FAILURE;
    }

#ifdef BURST_MODE_SUPPORT
    /* Call minseq() to calculate Burst Mode model inputs.
       Disable writing corner points files for prescan entry points. */
    int gradHeatFile_save = gradHeatFile;
    gradHeatFile  = _gradHeatFile.fixedflag ?  ((void)(FALSE), gradHeatFile) : FALSE;
    if ( FAILURE == minseq( _min_seqgrad.fixedflag ? (_temp466_min_seqgrad=min_seqgrad,&_temp466_min_seqgrad) : &min_seqgrad,
                            gradx, GX_FREE,
                            grady, GY_FREE,
                            gradz, GZ_FREE,
                            &loggrd, idx_seqcfl, tsamp, tmin,
                            use_ermes, seg_debug ) ) {
        epic_error( use_ermes, "%s failed.",
                    EM_PSD_ROUTINE_FAILURE, EE_ARGS(1), STRING_ARG, "minseq" );
        return FAILURE;
    }
    gradHeatFile  = _gradHeatFile.fixedflag ?  ((void)(gradHeatFile_save), gradHeatFile) : gradHeatFile_save;
#endif

    return SUCCESS;
}

/*
 *  RCVNpredownload
 *  
 *  Type: Private Function
 *  
 *  Description:
 *  
 */
STATUS
RCVNpredownload( void )
{
    entry_point_table[L_RCVN] = entry_point_table[L_MPS2];
    entry_point_table[L_RCVN].enableReceiveFreqBands  = _enableReceiveFreqBands.fixedflag ?  ((void)(0), enableReceiveFreqBands) : 0;
    entry_point_table[L_RCVN].offsetReceiveFreqLower  = _offsetReceiveFreqLower.fixedflag ?  ((void)(0), offsetReceiveFreqLower) : 0;
    entry_point_table[L_RCVN].offsetReceiveFreqHigher  = _offsetReceiveFreqHigher.fixedflag ?  ((void)(0), offsetReceiveFreqHigher) : 0;

    xmtaddRCVN  = _xmtaddRCVN.fixedflag ?  ((void)(xmtaddCFL), xmtaddRCVN) : xmtaddCFL;
    entry_point_table[L_RCVN].epxmtadd = (short) rint((double)xmtaddRCVN);

    strcpy(entry_point_table[L_RCVN].epname,"rcvn");
    
    entry_point_table[L_RCVN].epfilter  = (n8)filter_rcvn_fid;
    entry_point_table[L_RCVN].epprexres = rcvn_xres;

#ifdef BURST_MODE_SUPPORT
    /* Call minseq() to calculate Burst Mode model inputs.
       Disable writing corner points files for prescan entry points. */
    int gradHeatFile_save = gradHeatFile;
    gradHeatFile  = _gradHeatFile.fixedflag ?  ((void)(FALSE), gradHeatFile) : FALSE;
    if ( FAILURE == minseq( _min_seqgrad.fixedflag ? (_temp467_min_seqgrad=min_seqgrad,&_temp467_min_seqgrad) : &min_seqgrad,
                            gradx, GX_FREE,
                            grady, GY_FREE,
                            gradz, GZ_FREE,
                            &loggrd, idx_seqrcvn, tsamp, tmin,
                            use_ermes, seg_debug ) ) {
        epic_error( use_ermes, "%s failed.",
                    EM_PSD_ROUTINE_FAILURE, EE_ARGS(1), STRING_ARG, "minseq" );
        return FAILURE;
    }
    gradHeatFile  = _gradHeatFile.fixedflag ?  ((void)(gradHeatFile_save), gradHeatFile) : gradHeatFile_save;
#endif

    return SUCCESS;
}

/*
 *  CFHpredownload
 *  
 *  Type: Private Function
 *  
 *  Description:
 *  
 */
STATUS
CFHpredownload( void )
{
    /* Sample time for cfh */
    pitsp2 = echo1cfh.tdaq/echo1cfh.outputs;

    xmtaddCFH  = _xmtaddCFH.fixedflag ?    ((void)(-200*log10(maxB1[L_CFH]/maxB1Seq)+getCoilAtten()), xmtaddCFH) : -200*log10(maxB1[L_CFH]/maxB1Seq)+getCoilAtten();
    if (xmtaddCFH > cfdbmax)
    {
        cfhscale  = _cfhscale.fixedflag ?      ((void)((float)pow(10.0,(cfdbmax-xmtaddCFH)/200.0)), cfhscale) : (float)pow(10.0,(cfdbmax-xmtaddCFH)/200.0);
        xmtaddCFH  = _xmtaddCFH.fixedflag ?  ((void)(cfdbmax), xmtaddCFH) : cfdbmax;
    }
    else
    {
        cfhscale  = _cfhscale.fixedflag ?  ((void)(1.0), cfhscale) : 1.0;
    }

    if (setScale(L_CFH, RF_FREE, rfpulse, maxB1[L_CFH], 
                 cfhscale) == FAILURE)
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "setScale cfh");
        return FAILURE;
    }

    ia_rf1cfh  = _ia_rf1cfh.fixedflag ?  ((void)((int)(max_pg_iamp*(*rfpulse[RF1_CFH_SLOT].amp))), ia_rf1cfh) : (int)(max_pg_iamp*(*rfpulse[RF1_CFH_SLOT].amp));
    ia_rf2cfh  = _ia_rf2cfh.fixedflag ?  ((void)((int)(max_pg_iamp*(*rfpulse[RF2_CFH_SLOT].amp))), ia_rf2cfh) : (int)(max_pg_iamp*(*rfpulse[RF2_CFH_SLOT].amp));
    if(presscfh_ctrl != PRESSCFH_NONE)
    {
        ia_rf3cfh  = _ia_rf3cfh.fixedflag ?  ((void)((int)(max_pg_iamp*(*rfpulse[RF3_CFH_SLOT].amp))), ia_rf3cfh) : (int)(max_pg_iamp*(*rfpulse[RF3_CFH_SLOT].amp));
        if(presscfh_ctrl == PRESSCFH_SHIMVOL_SLICE)
        {
            ia_rf4cfh  = _ia_rf4cfh.fixedflag ?  ((void)((int)(max_pg_iamp*(*rfpulse[RF4_CFH_SLOT].amp))), ia_rf4cfh) : (int)(max_pg_iamp*(*rfpulse[RF4_CFH_SLOT].amp));
        }
    }

#ifdef PSD_CFH_CHEMSAT
    if ((cs_sat == PSD_ON) && PScs_sat)
    {
        ia_rfcssatcfh = (int)(max_pg_iamp*(*rfpulse[RFCSSAT_CFH_SLOT].amp));
    }
#endif
    if (PSD_ON == PSir)
    {
        ia_rf0cfh  = _ia_rf0cfh.fixedflag ?  ((void)((int)(max_pg_iamp*(*rfpulse[RF0_CFH_SLOT].amp))), ia_rf0cfh) : (int)(max_pg_iamp*(*rfpulse[RF0_CFH_SLOT].amp));
    }

    if( (presscfh_ctrl != PRESSCFH_SHIMVOL) && (presscfh_ctrl != PRESSCFH_SHIMVOL_SLICE) )
    {
        cfh_rf1freq  = _cfh_rf1freq.fixedflag ?           ((void)((GAM*a_gzrf1cfh*PStloc/(10*TARDIS_FREQ_RES))), cfh_rf1freq) : (GAM*a_gzrf1cfh*PStloc/(10*TARDIS_FREQ_RES));
    }
    else
    {
        cfh_rf1freq  = _cfh_rf1freq.fixedflag ?           ((void)((GAM*a_gzrf1cfh*psc_info[0].oppsctloc/(10*TARDIS_FREQ_RES))), cfh_rf1freq) : (GAM*a_gzrf1cfh*psc_info[0].oppsctloc/(10*TARDIS_FREQ_RES));
    }

    if( ( (opcoax != 0) && cfh_newmode ) || (presscfh != PRESSCFH_NONE) )
    {
        if( presscfh_ctrl == PRESSCFH_SLICE || presscfh_ctrl == PRESSCFH_SLAB )
        {
            cfh_rf2freq  = _cfh_rf2freq.fixedflag ?          ((void)(GAM*presscfh_info[0].oppscrloc*a_gxrf2cfh/(10*TARDIS_FREQ_RES)), cfh_rf2freq) : GAM*presscfh_info[0].oppscrloc*a_gxrf2cfh/(10*TARDIS_FREQ_RES);
            cfh_rf3freq  = _cfh_rf3freq.fixedflag ?          ((void)(GAM*presscfh_info[0].oppscphasoff*a_gyrf3cfh/(10*TARDIS_FREQ_RES)), cfh_rf3freq) : GAM*presscfh_info[0].oppscphasoff*a_gyrf3cfh/(10*TARDIS_FREQ_RES);
        }
        else if(presscfh_ctrl == PRESSCFH_SHIMVOL)
        {
            cfh_rf2freq  = _cfh_rf2freq.fixedflag ?          ((void)(GAM*psc_info[0].oppscrloc*a_gxrf2cfh/(10*TARDIS_FREQ_RES)), cfh_rf2freq) : GAM*psc_info[0].oppscrloc*a_gxrf2cfh/(10*TARDIS_FREQ_RES);
            cfh_rf3freq  = _cfh_rf3freq.fixedflag ?           ((void)(GAM*psc_info[0].oppscphasoff*a_gyrf3cfh/(10*TARDIS_FREQ_RES)), cfh_rf3freq) : GAM*psc_info[0].oppscphasoff*a_gyrf3cfh/(10*TARDIS_FREQ_RES);
            if((presscfh != presscfh_ctrl) && presscfh_debug)
            {
                printf("\n  presscfh %d changes to presscfh_ctrl %d \n",presscfh, presscfh_ctrl);
                fflush(stdout);
            }
        }
        else if (presscfh_ctrl == PRESSCFH_SHIMVOL_SLICE)
        {
            cfh_rf2freq  = _cfh_rf2freq.fixedflag ?          ((void)(GAM*psc_info[0].oppscrloc*a_gxrf2cfh/(10*TARDIS_FREQ_RES)), cfh_rf2freq) : GAM*psc_info[0].oppscrloc*a_gxrf2cfh/(10*TARDIS_FREQ_RES);
            cfh_rf3freq  = _cfh_rf3freq.fixedflag ?          ((void)(GAM*psc_info[0].oppscphasoff*a_gyrf3cfh/(10*TARDIS_FREQ_RES)), cfh_rf3freq) : GAM*psc_info[0].oppscphasoff*a_gyrf3cfh/(10*TARDIS_FREQ_RES);
            cfh_rf4freq  = _cfh_rf4freq.fixedflag ?          ((void)(GAM*PStloc*a_gzrf4cfh/(10*TARDIS_FREQ_RES)), cfh_rf4freq) : GAM*PStloc*a_gzrf4cfh/(10*TARDIS_FREQ_RES);
        }
        else
        {
            cfh_rf2freq  = _cfh_rf2freq.fixedflag ?              
    ((void)((GAM*(opspf?PSphasoff*a_gyrf2cfh:PSrloc*a_gxrf2cfh)/(10*TARDIS_FREQ_RES))), cfh_rf2freq) : (GAM*(opspf?PSphasoff*a_gyrf2cfh:PSrloc*a_gxrf2cfh)/(10*TARDIS_FREQ_RES));
        /* factor 10 is because rloc/phasoff is in mm */
    }
    }
    else
    {
        /* For non-coaxials (multi angle), center cfh_rf2freq and up the
           excitation region to 40 cm to cover lots of ground 
        */
        cfh_rf2freq  = _cfh_rf2freq.fixedflag ?  ((void)(0), cfh_rf2freq) : 0;
    }

    entry_point_table[L_CFH].epxmtadd = (short) rint((double)xmtaddCFH);
    strcpy(entry_point_table[L_CFH].epname,"cfh");
    entry_point_table[L_CFH].epfilter=(n8)filter_cfh_fid;
    entry_point_table[L_CFH].epprexres = (s16)CFHxres; /* MRIhc08633 */
    
    /* MRIge75651 */
    if( powermon( &entry_point_table[L_CFH],
                  L_CFH,
                  (int)RF_FREE,
                  rfpulse,
                  cfh_tr) == FAILURE )
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "powermon cfh");
        return FAILURE;
    }

#ifdef BURST_MODE_SUPPORT
    /* Call minseq() to calculate Burst Mode model inputs.
       Disable writing corner points files for prescan entry points. */
    int gradHeatFile_save = gradHeatFile;
    gradHeatFile  = _gradHeatFile.fixedflag ?  ((void)(FALSE), gradHeatFile) : FALSE;
    if ( FAILURE == minseq( _min_seqgrad.fixedflag ? (_temp468_min_seqgrad=min_seqgrad,&_temp468_min_seqgrad) : &min_seqgrad,
                            gradx, GX_FREE,
                            grady, GY_FREE,
                            gradz, GZ_FREE,
                            &loggrd, idx_seqcfh, tsamp, tmin,
                            use_ermes, seg_debug ) ) {
        epic_error( use_ermes, "%s failed.",
                    EM_PSD_ROUTINE_FAILURE, EE_ARGS(1), STRING_ARG, "minseq" );
        return FAILURE;
    }
    gradHeatFile  = _gradHeatFile.fixedflag ?  ((void)(gradHeatFile_save), gradHeatFile) : gradHeatFile_save;
#endif

    switch (getTxCoilType()) /* Only 0.5/0.2T will use. */ /* vmx 07/27/95 YO */
    {
        case TX_COIL_LOCAL:
            cfh_ec_position  = _cfh_ec_position.fixedflag ?   ((void)((10.0/256.0)), cfh_ec_position) : (10.0/256.0);
            break;
        default:
            cfh_ec_position  = _cfh_ec_position.fixedflag ?   ((void)((16.0/256.0)), cfh_ec_position) : (16.0/256.0);
            break;
    }

    return SUCCESS;
}

/*
 *  PSpredownload
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
PSpredownload( void )
{
    STATUS ps_status;
    INT i;
    INT j;
    INT index, vidx;
    
    /* Check for multiple Tx coils. This routine is optimized only for
     * single Tx coil. */
    if (1 != getNumTxCoils(coilInfo, opncoils))
    {
        epic_error( use_ermes,
                    "%s does not support more than one transmit coil",
                    EM_PSD_MULTI_TX_NOT_SUPPORTED, EE_ARGS(1), STRING_ARG,
                    "prescan");
        return FAILURE;
    }
    
    /***********************************************************************
     * Generic SECTION
     ***********************************************************************/

    if(PSD_ON == exist(oprtcgate)) {
        phys_record_flag  = _phys_record_flag.fixedflag ?  ((void)(PSD_ON), phys_record_flag) : PSD_ON; /* flag for rt data recording */
    } else {
        phys_record_flag  = _phys_record_flag.fixedflag ?  ((void)(PSD_OFF), phys_record_flag) : PSD_OFF;
    }

    /* go through entry point table and set frequency offset based on receiver */
    for( i = 0; i < ENTRY_POINT_MAX; i++ )
    {
        PSfreq_offset[i] = cfreceiveroffsetfreq;
    }

    pw_omegarf0cfh  = _pw_omegarf0cfh.fixedflag ?  ((void)(pw_rf0cfh), pw_omegarf0cfh) : pw_rf0cfh; /* adiabatic pulse */

    PSslice_ind  = _PSslice_ind.fixedflag ?  ((void)(PSslice_num), PSslice_ind) : PSslice_num;  /* MRIge90312 -- for smart prescan */

    PStloc     = _PStloc.fixedflag ?       ((void)(scan_info[PSslice_num].optloc+scan_info[PSslice_num].optloc_shift), PStloc) : scan_info[PSslice_num].optloc+scan_info[PSslice_num].optloc_shift;
    PSrloc     = _PSrloc.fixedflag ?       ((void)(scan_info[PSslice_num].oprloc+scan_info[PSslice_num].oprloc_shift), PSrloc) : scan_info[PSslice_num].oprloc+scan_info[PSslice_num].oprloc_shift;
    PSphasoff  = _PSphasoff.fixedflag ?    ((void)(scan_info[PSslice_num].opphasoff+scan_info[PSslice_num].opphasoff_shift), PSphasoff) : scan_info[PSslice_num].opphasoff+scan_info[PSslice_num].opphasoff_shift;

    /* begin aps1_mod changes (GE) */
    if ( (getAps1Mod() > 0) && (PSD_OFF == local_tg) )
    {
        cvunlock(PStloc_mod);
        cvunlock(PSrloc_mod);
        PStloc_mod  = _PStloc_mod.fixedflag ?  ((void)(getAps1ModPsTloc()), PStloc_mod) : getAps1ModPsTloc();
        PSrloc_mod  = _PSrloc_mod.fixedflag ?  ((void)(getAps1ModPsRloc()), PSrloc_mod) : getAps1ModPsRloc();
        PSphasoff_mod  = _PSphasoff_mod.fixedflag ?  ((void)(0), PSphasoff_mod) : 0; /* phase offset is not used */
        if(PSD_AXIAL == opplane)  /* To handle table delta */
        {
            PStloc_mod  = _PStloc_mod.fixedflag ?  ((void)(PStloc), PStloc_mod) : PStloc;
            if(2 == opentry)    /* Feet First */
            {
                PStloc_mod  = _PStloc_mod.fixedflag ?  ((void)(-PStloc), PStloc_mod) : -PStloc;
            }
        }
    }
    else if (PSD_ON == local_tg)
    {
        if (oppscvquant > 0)  /* use shim vol */
        {
            /* The default case for Localized TG = use Shim Vol info */

            PStloc_mod  = _PStloc_mod.fixedflag ?  ((void)(psc_info[0].oppsctloc), PStloc_mod) : psc_info[0].oppsctloc;
            PSrloc_mod  = _PSrloc_mod.fixedflag ?  ((void)(psc_info[0].oppscrloc), PSrloc_mod) : psc_info[0].oppscrloc;    
            PSphasoff_mod  = _PSphasoff_mod.fixedflag ?  ((void)(psc_info[0].oppscphasoff), PSphasoff_mod) : psc_info[0].oppscphasoff;    
        }
        else
        {
            /* For Research purpose only. Localized TG is normally enabled only if
             * Shim volume has been set by user via GRx. If this case is reached, 
             * local_tg flag was intentionally modified by user for Research purposes. */

            PStloc_mod  = _PStloc_mod.fixedflag ?  ((void)(PStloc), PStloc_mod) : PStloc;
            PSrloc_mod  = _PSrloc_mod.fixedflag ?  ((void)(PSrloc), PSrloc_mod) : PSrloc;
            PSphasoff_mod  = _PSphasoff_mod.fixedflag ?  ((void)(PSphasoff), PSphasoff_mod) : PSphasoff;
        }
    }
    else  /* use imaging locs */
    { 
        PStloc_mod  = _PStloc_mod.fixedflag ?  ((void)(PStloc), PStloc_mod) : PStloc;
        PSrloc_mod  = _PSrloc_mod.fixedflag ?      ((void)(opspf?PSphasoff:PSrloc), PSrloc_mod) : opspf?PSphasoff:PSrloc;    
    }
    /* end aps1_mod changes (GE) */

   /* Create rsp_psc_info table based on psc_info */
    for ( i=0; i < exist(oppscvquant); i ++) {
        rsp_psc_info[i].rsppsctloc = psc_info[i].oppsctloc;
        rsp_psc_info[i].rsppscrloc = psc_info[i].oppscrloc;
        rsp_psc_info[i].rsppscphasoff = psc_info[i].oppscphasoff;

        rsp_psc_info[i].rsppsclenx = psc_info[i].oppsclenx;
        rsp_psc_info[i].rsppscleny = psc_info[i].oppscleny;
        rsp_psc_info[i].rsppsclenz = psc_info[i].oppsclenz; 
    }

    /* Check the rotation matrix for rsp_psc_info */
    for (i=0; i< exist(oppscvquant); i++) {
        for (j=0; j<9; j++) {
            rsp_psc_info[i].rsppscrot[j] = hostToRspRotMat(psc_info[0].oppscrot[j]);
        }
    } 

    /* fill in the prescan rotation array for the prescan slice.
       PSrot is an ipgexport defined in epic.h  */

    /*
     * MRIge43971 BJM: loop over 2D PSrot array to be consistent with other
     *                 rotation matrices and since scalerotmats() expects a 2D
     *                 argument.
     */
    for (index = 0; index < 9; index++)
    {
        PSrot[0][index] = hostToRspRotMat(scan_info[PSslice_num].oprot[index]);
        PSrot_mod[0][index] = hostToRspRotMat(ps1scan_info[0].oprot[index]); 
        rsp_PSrot[0][index] = hostToRspRotMat(cfh_info[0].oprot[index]);
        rsp_rcvnrot[0][index] = hostToRspRotMat(rcvnscan_info[0].oprot[index]);


        /* set up rot for CFH */
        for( vidx = 1; vidx < oppscvquant; vidx++ )
        {
            rsp_PSrot[vidx][index] = hostToRspRotMat(cfh_info[vidx].oprot[index]);

        }
    }

    /* Scale Rot matrix for RCVN */
    if(scalerotmats(rsp_rcvnrot, &rcvnloggrd, &phygrd, 1, ps1obl_debug) == FAILURE)
    {
        epic_error(use_ermes,"System configuration data integrity violation detected in PSD.\nPlease try again or restart the system.", 
                   EM_PSD_PSDCRUCIAL_CONFIG_FAILURE,EE_ARGS(0));
        return FAILURE;
    }

    /* Scale Rot matrix for CFH */
    if(scalerotmats(rsp_PSrot, &cfhloggrd, &phygrd, IMax(2,1,exist(oppscvquant)), cfhobl_debug) == FAILURE) /* YMSmr09211  04/26/2006 YI */
    {
        epic_error(use_ermes,"System configuration data integrity violation detected in PSD.\nPlease try again or restart the system.", 
                   EM_PSD_PSDCRUCIAL_CONFIG_FAILURE,EE_ARGS(0));
        return FAILURE;
    }
    
    /* Scale Rot matrix for CFL */
    if(scalerotmats(PSrot, &loggrd, &phygrd, 1, ps1obl_debug) == FAILURE)
    {
        epic_error(use_ermes,"System configuration data integrity violation detected in PSD.\nPlease try again or restart the system.", 
                   EM_PSD_PSDCRUCIAL_CONFIG_FAILURE,EE_ARGS(0));
        return FAILURE;
    }

    /* Scale Rot matrix for ps1 & FTG  & XTG */
    if(scalerotmats(PSrot_mod, &ps1loggrd, &phygrd, 1, ps1obl_debug) == FAILURE) 
    {
        epic_error(use_ermes,"System configuration data integrity violation detected in PSD.\nPlease try again or restart the system.", 
                   EM_PSD_PSDCRUCIAL_CONFIG_FAILURE,EE_ARGS(0));
        return FAILURE;
    }

    PStrigger  = _PStrigger.fixedflag ?  ((void)(TRIG_LINE), PStrigger) : TRIG_LINE;

    /* For Prescan: Inform 'Auto' Prescan about prescan parameters 	*/
    pitr = 2000000;	        /* 1st pass prescan TR 	*/
    pichop = 0;		/* No chop		*/

    /* find minimum rfamp te time based on duty cycle */
    min180te  = _min180te.fixedflag ?    
                                 
                                ((void)(RUP_GRD((int)((float)(pw_rf1mps1+cfrfminblank)/((TX_COIL_LOCAL==getTxCoilType())?cfrfmdch:cfrfmdcb)))*2), min180te) : RUP_GRD((int)((float)(pw_rf1mps1+cfrfminblank)/((TX_COIL_LOCAL==getTxCoilType())?cfrfmdch:cfrfmdcb)))*2;

    /***********************************************************************
     * MPS1/APS1 SECTION
     ***********************************************************************/

    if ( SUCCESS != (ps_status = PS1predownload()) ) {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "PS1predownload");
        return ps_status;
    }


    /***********************************************************************
     * CFL SECTION
     ***********************************************************************/

    if ( SUCCESS != (ps_status = CFLpredownload()) ) {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "CFLpredownload");  /* MRIhc08595 */
        return ps_status;
    }

    /***********************************************************************
     * CFH SECTION
     ***********************************************************************/

    if ( SUCCESS != (ps_status = CFHpredownload()) ) {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "CFHpredownload");  /* MRIhc08595 */
        return ps_status;
    }

    /***********************************************************************
     * RCVN SECTION
     ***********************************************************************/

    if ( SUCCESS != (ps_status = RCVNpredownload()) ) {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "RCVNpredownload");
        return ps_status;
    }

    /* xmtaddRef is used for calculating TG value to be stored in smart prescan DB wrt a
     * reference maxB1 used in TG entry point */
    xmtaddRef = -200*log10(cfmaxb1ref/100.0/maxB1Seq) + getCoilAtten();

    /* HCSDM00184619 : Tools PSD dont inline PSpreDwonload.
     * This should move to a routine which  psdIF can handle. */

    /* Copy coilInfo, volRecCoilInfo, txCoilInfo to target side */
    copyCoilInfo();

    chksum_rampdir_tgt = chksum_rampdir;
    cframpdir_tgt = cframpdir;

    if(exist(opquickstep))  /* skip TG for quickstep */
    {
        psd_psctg  = _psd_psctg.fixedflag ?  ((void)(PSD_CONTROL_PSC_SKIP), psd_psctg) : PSD_CONTROL_PSC_SKIP;
    }
    else
    {
        psd_psctg  = _psd_psctg.fixedflag ?  ((void)(APS_CONTROL_PSC), psd_psctg) : APS_CONTROL_PSC;
    }
    pidotg = doTG(psd_psctg);  /* set PSC TG control flag */

    return SUCCESS;

}   /* end PSpredownload() */


/*
 *  FTGpredownload
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
FTGpredownload( void )
{
    /* Set xmtaddFTG according to maximum B1 and rescale for powermon,
       adding additional (audio) scaling if xmtaddFTG is too big.
       We are assuming that the pulse shapes used in CFH are the
       same as in scan. */
    xmtaddFTG  = _xmtaddFTG.fixedflag ?    ((void)(-200*log10(maxB1[L_FTG]/maxB1Seq)+getCoilAtten()), xmtaddFTG) : -200*log10(maxB1[L_FTG]/maxB1Seq)+getCoilAtten();
    if (xmtaddFTG > cfdbmax)
    {
        ftgscale  = _ftgscale.fixedflag ?      ((void)((float)pow(10.0,(cfdbmax-xmtaddFTG)/200.0)), ftgscale) : (float)pow(10.0,(cfdbmax-xmtaddFTG)/200.0);
        xmtaddFTG  = _xmtaddFTG.fixedflag ?  ((void)(cfdbmax), xmtaddFTG) : cfdbmax;
    }
    else
    {
        ftgscale  = _ftgscale.fixedflag ?  ((void)(1.0), ftgscale) : 1.0;
    }

    if (setScale(L_FTG,RF_FREE,rfpulse,maxB1[L_FTG],ftgscale) == FAILURE)
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "setScale ftg");
        return FAILURE;
    }
    
    /* Set the amplitude scale factors. */
    ia_rf1ftg  = _ia_rf1ftg.fixedflag ?  ((void)((int)(max_pg_iamp*(*rfpulse[RF1_FTG_SLOT].amp))), ia_rf1ftg) : (int)(max_pg_iamp*(*rfpulse[RF1_FTG_SLOT].amp));
    ia_rf2ftg  = _ia_rf2ftg.fixedflag ?  ((void)((int)(max_pg_iamp*(*rfpulse[RF2_FTG_SLOT].amp))), ia_rf2ftg) : (int)(max_pg_iamp*(*rfpulse[RF2_FTG_SLOT].amp));
    ia_rf3ftg  = _ia_rf3ftg.fixedflag ?  ((void)((int)(max_pg_iamp*(*rfpulse[RF3_FTG_SLOT].amp))), ia_rf3ftg) : (int)(max_pg_iamp*(*rfpulse[RF3_FTG_SLOT].amp));
    
    entry_point_table[L_FTG].epxmtadd = (short)rint((double)xmtaddFTG);

    /* MRIge75651 */
    if( powermon( &entry_point_table[L_FTG],
                  L_FTG,
                  (int)RF_FREE,
                  rfpulse,
                  ftgtr ) == FAILURE )
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "powermon ftg");
        return FAILURE;
    }
    xmtadd  = _xmtadd.fixedflag ?  ((void)(xmtaddFTG), xmtadd) : xmtaddFTG;

    entry_point_table[L_FTG].epfilter = (n8)filter_echo1ftg; /* 11/24/94 YI */
    entry_point_table[L_FTG].epprexres = 256;
    
    FTGxmtadd  = _FTGxmtadd.fixedflag ?  ((void)(entry_point_table[L_APS1].epxmtadd-entry_point_table[L_FTG].epxmtadd), FTGxmtadd) : entry_point_table[L_APS1].epxmtadd-entry_point_table[L_FTG].epxmtadd;

#ifdef BURST_MODE_SUPPORT
    {
        /* Call minseq() to calculate Burst Mode model inputs.
           Disable writing corner points files for prescan entry points. */
        int gradHeatFile_save = gradHeatFile;
        gradHeatFile  = _gradHeatFile.fixedflag ?  ((void)(FALSE), gradHeatFile) : FALSE;
        if ( FAILURE == minseq( _min_seqgrad.fixedflag ? (_temp469_min_seqgrad=min_seqgrad,&_temp469_min_seqgrad) : &min_seqgrad,
                                gradx, GX_FREE,
                                grady, GY_FREE,
                                gradz, GZ_FREE,
                                &loggrd, idx_seqftg, tsamp, tmin,
                                use_ermes, seg_debug ) )
        {
            epic_error( use_ermes, "%s failed.",
                        EM_PSD_ROUTINE_FAILURE, EE_ARGS(1), STRING_ARG, "minseq" );
            return FAILURE;
        }
        gradHeatFile  = _gradHeatFile.fixedflag ?  ((void)(gradHeatFile_save), gradHeatFile) : gradHeatFile_save;
    }
#endif

    /* Use volRec coil for FTG */
    if (volRecCoilInfo[0].hubIndex != coilInfo[0].hubIndex)
    {
        UpdateEntryTabRecCoil(&entry_point_table[L_FTG],&volRecCoilInfo[0]);
    } 

    return SUCCESS;
}   /* end FTGpredownload() */


/*
 *  XTGpredownload
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
XTGpredownload( void )
{
    {
        float trsarscale = 1.0;
        int xtg_maxseqsar = 0;

        if(FAILURE == maxseqsar(&xtg_maxseqsar, RF_FREE, rfpulse, L_XTG))
        {
            epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                       EE_ARGS(1), STRING_ARG, "maxseqsar xtg");
            return FAILURE;
        }

        if( isLowSarEnabled() )
        {
            trsarscale = 1.2;   /* HCSDM00381012: adding 20% tr to prevent UPM trip for low SAR */
        }

        if(xtgtr < (int)(xtg_maxseqsar*trsarscale))
        {
            xtgtr  = _xtgtr.fixedflag ?  ((void)(RUP_GRD((int)(xtg_maxseqsar*trsarscale))), xtgtr) : RUP_GRD((int)(xtg_maxseqsar*trsarscale));
        }
    }
    
    /* Set xmtaddXTG according to maximum B1 and rescale for powermon,
       adding additional (audio) scaling if xmtaddXTG is too big. */
    xmtaddXTG  = _xmtaddXTG.fixedflag ?    ((void)(-200*log10(maxB1[L_XTG]/maxB1Seq)+getCoilAtten()), xmtaddXTG) : -200*log10(maxB1[L_XTG]/maxB1Seq)+getCoilAtten();

    if (xmtaddXTG > cfdbmax)
    {
        xtgscale  = _xtgscale.fixedflag ?      ((void)((float)pow(10.0,(cfdbmax-xmtaddXTG)/200.0)), xtgscale) : (float)pow(10.0,(cfdbmax-xmtaddXTG)/200.0);
        xmtaddXTG  = _xmtaddXTG.fixedflag ?  ((void)(cfdbmax), xmtaddXTG) : cfdbmax;
    }
    else
    {
        xtgscale  = _xtgscale.fixedflag ?  ((void)(1.0), xtgscale) : 1.0;
    }

    if (setScale(L_XTG,RF_FREE,rfpulse,maxB1[L_XTG],xtgscale) == FAILURE)  
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "setScale xtg");
        return FAILURE;
    }  
    
    /* Set the amplitude scale factors. */
    ia_rf1xtg  = _ia_rf1xtg.fixedflag ?  ((void)((int)(max_pg_iamp*(*rfpulse[RF1_XTG_SLOT].amp))), ia_rf1xtg) : (int)(max_pg_iamp*(*rfpulse[RF1_XTG_SLOT].amp));
    ia_rf2xtg  = _ia_rf2xtg.fixedflag ?  ((void)((int)(max_pg_iamp*(*rfpulse[RF2_XTG_SLOT].amp))), ia_rf2xtg) : (int)(max_pg_iamp*(*rfpulse[RF2_XTG_SLOT].amp));
    ia_rf4xtg  = _ia_rf4xtg.fixedflag ?  ((void)((int)(max_pg_iamp*(*rfpulse[RF4_XTG_SLOT].amp))), ia_rf4xtg) : (int)(max_pg_iamp*(*rfpulse[RF4_XTG_SLOT].amp));
    ia_rf3xtg  = _ia_rf3xtg.fixedflag ?  ((void)(-ia_rf4xtg), ia_rf3xtg) : -ia_rf4xtg;
    a_rf3xtg   = _a_rf3xtg.fixedflag ?  ((void)(-a_rf4xtg), a_rf3xtg) : -a_rf4xtg;
    
    entry_point_table[L_XTG].epxmtadd = (short)rint((double)xmtaddXTG);

    /* MRIge75651 */
    if( powermon( &entry_point_table[L_XTG],
                  L_XTG,
                  (int)RF_FREE,
                  rfpulse,
                  xtgtr ) == FAILURE )
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "powermon xtg");
        return FAILURE;
    }
    xmtadd  = _xmtadd.fixedflag ?  ((void)(xmtaddXTG), xmtadd) : xmtaddXTG;

    entry_point_table[L_XTG].epfilter = (n8)filter_echo1xtg; /* 11/24/94 YI */
    entry_point_table[L_XTG].epprexres = 256;

#ifdef BURST_MODE_SUPPORT
    {
        /* Call minseq() to calculate Burst Mode model inputs.
           Disable writing corner points files for prescan entry points. */
        int gradHeatFile_save = gradHeatFile;
        gradHeatFile  = _gradHeatFile.fixedflag ?  ((void)(FALSE), gradHeatFile) : FALSE;
        if ( FAILURE == minseq( _min_seqgrad.fixedflag ? (_temp470_min_seqgrad=min_seqgrad,&_temp470_min_seqgrad) : &min_seqgrad,
                                gradx, GX_FREE,
                                grady, GY_FREE,
                                gradz, GZ_FREE,
                                &loggrd, idx_seqxtg, tsamp, tmin,
                                use_ermes, seg_debug ) ) {
            epic_error( use_ermes, "%s failed.",
                        EM_PSD_ROUTINE_FAILURE, EE_ARGS(1), STRING_ARG, "minseq" );
            return FAILURE;
        }
        gradHeatFile  = _gradHeatFile.fixedflag ?  ((void)(gradHeatFile_save), gradHeatFile) : gradHeatFile_save;
    }
#endif

    if ( (2 == getAps1Mod()) && (PSD_OFF == local_tg) )
    {
        xtg_volRecCoil  = _xtg_volRecCoil.fixedflag ?  ((void)(PSD_ON), xtg_volRecCoil) : PSD_ON;
    }
    else
    {
        xtg_volRecCoil  = _xtg_volRecCoil.fixedflag ?  ((void)(PSD_OFF), xtg_volRecCoil) : PSD_OFF;
    }

    if(PSD_ON == xtg_volRecCoil)
    {
        /* Use volRec coil for XTG */
        if (volRecCoilInfo[0].hubIndex != coilInfo[0].hubIndex)
        {
            UpdateEntryTabRecCoil(&entry_point_table[L_XTG], &volRecCoilInfo[0]);
        } 
    }

    return SUCCESS;
}   /* end XTGpredownload() */


/*
 *  ASpredownload
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
ASpredownload( void )
{
    FLOAT asscale;
 
    /******************************************************************/
    /* Set xmtaddas according to maximum B1 and rescale for powermon, */
    /* adding additional (audio) scaling if xmtaddas is too big.      */
    /* We are assuming that the pulse shapes used in CFH are the      */
    /* same as in scan.                                               */
    /******************************************************************/

    strcpy(entry_point_table[L_AUTOSHIM].epname, "autoshim");

    xmtaddas  = _xmtaddas.fixedflag ?    ((void)(-200*log10(maxB1[L_AUTOSHIM]/maxB1Seq)+getCoilAtten()), xmtaddas) : -200*log10(maxB1[L_AUTOSHIM]/maxB1Seq)+getCoilAtten();
    if (xmtaddas > cfdbmax) 
    {
        asscale = (float) pow(10.0, (cfdbmax - xmtaddas)/200.0);
        xmtaddas  = _xmtaddas.fixedflag ?  ((void)(cfdbmax), xmtaddas) : cfdbmax;
    } 
    else
    {
        asscale = 1.0;
    }

    if (setScale(L_AUTOSHIM, RF_FREE, rfpulse, maxB1[L_AUTOSHIM],
                 asscale) == FAILURE) 
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "setScale autoshim");
        return FAILURE;
    }

    /* Set the amplitude scale factors. */
    ia_rf1as  = _ia_rf1as.fixedflag ?  ((void)((int)(max_pg_iamp*(*rfpulse[RF1_AUTOSHIM].amp))), ia_rf1as) : (int)(max_pg_iamp*(*rfpulse[RF1_AUTOSHIM].amp));

    entry_point_table[L_AUTOSHIM].epxmtadd=(short)rint((double)xmtaddas);
    
    /* MRIge75651 */
    if( powermon( &entry_point_table[L_AUTOSHIM],
                  L_AUTOSHIM,
                  (int)RF_FREE,
                  rfpulse,
                  tr_as ) == FAILURE )
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "powermon autoshim");
        return FAILURE;
    }

#ifdef BURST_MODE_SUPPORT
    {
    /* Call minseq() to calculate Burst Mode model inputs.
       Disable writing corner points files for prescan entry points. */
    int gradHeatFile_save = gradHeatFile;
    gradHeatFile  = _gradHeatFile.fixedflag ?  ((void)(FALSE), gradHeatFile) : FALSE;
    if ( FAILURE == minseq( _min_seqgrad.fixedflag ? (_temp471_min_seqgrad=min_seqgrad,&_temp471_min_seqgrad) : &min_seqgrad,
                            gradx, GX_FREE,
                            grady, GY_FREE,
                            gradz, GZ_FREE,
                            &loggrd, idx_seqaushim, tsamp, tmin,
                            use_ermes, seg_debug ) ) {
        epic_error( use_ermes, "%s failed.",
                    EM_PSD_ROUTINE_FAILURE, EE_ARGS(1), STRING_ARG, "minseq" );
        return FAILURE;
    }
    gradHeatFile  = _gradHeatFile.fixedflag ?  ((void)(gradHeatFile_save), gradHeatFile) : gradHeatFile_save;
    }
#endif

    entry_point_table[L_AUTOSHIM].epfilter = (n8)filter_echo1as;
    entry_point_table[L_AUTOSHIM].epprexres = asxres;
    
    /* Use volRec coil for autoshim */
    if (volRecCoilInfo[0].hubIndex != coilInfo[0].hubIndex)
    {
        UpdateEntryTabRecCoil(&entry_point_table[L_AUTOSHIM], &volRecCoilInfo[0]);
    } 

    if(exist(opquickstep))  /* skip AutoShim for quickstep */
    {
        psd_pscshim  = _psd_pscshim.fixedflag ?  ((void)(PSD_CONTROL_PSC_SKIP), psd_pscshim) : PSD_CONTROL_PSC_SKIP;
    }
    else
    {
        psd_pscshim  = _psd_pscshim.fixedflag ?  ((void)(APS_CONTROL_PSC), psd_pscshim) : APS_CONTROL_PSC;
    }
    pidoshim = doAS(psd_pscshim);  /* set PSC AutoShim control flag */ 

    return SUCCESS;
}   /* end ASpredownload() */

/*
 *  RSpredownload
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
RSpredownload( void )
{
    FLOAT rsscale;
    FLOAT b1map_factor = 0.0;

    INT i, j;
    INT rs_maxseqsar = 0;

    if(FAILURE == maxseqsar(&rs_maxseqsar, RF_FREE, rfpulse, L_RFSHIM))
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "maxseqsar RF Shim");
        return FAILURE;
    }
    if(tr_rs < rs_maxseqsar)
    {
        tr_rs  = _tr_rs.fixedflag ?  ((void)(RUP_GRD(rs_maxseqsar)), tr_rs) : RUP_GRD(rs_maxseqsar);
    }

    DD_nCh  = _DD_nCh.fixedflag ?  ((void)(DD_channels), DD_nCh) : DD_channels;

    /******************************************************************/
    /* Set xmtadd according to maximum B1 and rescale for powermon,   */
    /* adding additional scaling if xmtadd is too big.                */
    /******************************************************************/

    strcpy(entry_point_table[L_RFSHIM].epname,  "RFshim");

    xmtaddrs  = _xmtaddrs.fixedflag ?    ((void)(-200*log10(maxB1[L_RFSHIM]/maxB1Seq)+getCoilAtten()), xmtaddrs) : -200*log10(maxB1[L_RFSHIM]/maxB1Seq)+getCoilAtten();
    if (xmtaddrs > cfdbmax) 
    {
        rsscale = (float) pow(10.0, (cfdbmax - xmtaddrs)/200.0);
        xmtaddrs  = _xmtaddrs.fixedflag ?  ((void)(cfdbmax), xmtaddrs) : cfdbmax;
    } 
    else
    {
        rsscale = 1.0;
    }

    if (setScale(L_RFSHIM, RF_FREE, rfpulse, maxB1[L_RFSHIM],
                 rsscale) == FAILURE) 
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "setScale B1Map");
        return FAILURE;
    }

    /* Set the amplitude scale factors. */
    ia_rfbrs  = _ia_rfbrs.fixedflag ?  ((void)(max_pg_iamp*(*rfpulse[RFB_RFSHIM_SLOT].amp)), ia_rfbrs) : max_pg_iamp*(*rfpulse[RFB_RFSHIM_SLOT].amp);
    ia_thetarfbrs  = _ia_thetarfbrs.fixedflag ?  ((void)(max_pg_iamp), ia_thetarfbrs) : max_pg_iamp;
    pw_thetarfbrs  = _pw_thetarfbrs.fixedflag ?  ((void)(pw_rfbrs), pw_thetarfbrs) : pw_rfbrs;
    ia_rf1rs  = _ia_rf1rs.fixedflag ?  ((void)(max_pg_iamp*(*rfpulse[RF1_RFSHIM_SLOT].amp)), ia_rf1rs) : max_pg_iamp*(*rfpulse[RF1_RFSHIM_SLOT].amp);

    entry_point_table[L_RFSHIM].epxmtadd=(short)rint((double)xmtaddrs);

    if( powermon( &entry_point_table[L_RFSHIM],
                  L_RFSHIM,
                  (int)RF_FREE,
                  rfpulse,
                  tr_rs ) == FAILURE )
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "powermon DynTG B1 map");
        return FAILURE;
    }

#ifdef BURST_MODE_SUPPORT
    {
        /* Call minseq() to calculate Burst Mode model inputs.
           Disable writing corner points files for prescan entry points. */
        int gradHeatFile_save = gradHeatFile;
        gradHeatFile  = _gradHeatFile.fixedflag ?  ((void)(FALSE), gradHeatFile) : FALSE;
        if ( FAILURE == minseq( _min_seqgrad.fixedflag ? (_temp472_min_seqgrad=min_seqgrad,&_temp472_min_seqgrad) : &min_seqgrad,
                                gradx, GX_FREE,
                                grady, GY_FREE,
                                gradz, GZ_FREE,
                                &loggrd, idx_seqrs, tsamp, tmin,
                                use_ermes, seg_debug ) ) {
            epic_error( use_ermes, "%s failed.",
                        EM_PSD_ROUTINE_FAILURE, EE_ARGS(1), STRING_ARG, "minseq" );
            return FAILURE;
        }
        gradHeatFile  = _gradHeatFile.fixedflag ?  ((void)(gradHeatFile_save), gradHeatFile) : gradHeatFile_save;
    }
#endif

    entry_point_table[L_RFSHIM].epfilter = (n8)filter_echo1rs;
    entry_point_table[L_RFSHIM].epprexres = rfshim_xres;

    /* set up B1 Map slice orientation and location */
    for (j = 0; j < rfshim_slquant; j++)
    {
        if(PSD_ON == rsaxial_flag)
        {
            rsrsp_info[j].rsprloc = 0.0;
            rsrsp_info[j].rspphasoff = 0.0;
            rsrsp_info[j].rsptloc = 0.0;

            if(isCategoryMatchForAnatomy(exist(opanatomy), ATTRIBUTE_CATEGORY_CHEST) && strstr(PSattribute_codeMeaning, "Breast")
               && (2 == exist(oppos)))  /* Prone breast scans */

            {
                rsrsp_info[j].rsprloc = -120.0;  /* offset in A/P diresction for breast coils */
            }
        }
        else
        {
            rsrsp_info[j].rsprloc = scan_info[PSslice_num].oprloc + scan_info[PSslice_num].oprloc_shift;
            rsrsp_info[j].rspphasoff = scan_info[PSslice_num].opphasoff + scan_info[PSslice_num].opphasoff_shift;
            rsrsp_info[j].rsptloc = scan_info[PSslice_num].optloc + scan_info[PSslice_num].optloc_shift;
        }

        for (i = 0; i < 9; i++)
        {
            rsrsprot[j][i] = hostToRspRotMat(rsscan_info[0].oprot[i]); /* use Rxed slice rot */ 
        }
    }

    scalerotmats(rsrsprot, &rsloggrd, &phygrd, rfshim_slquant, ps1obl_debug);

    /* calc b1map factor */
    b1map_factor = 2.0*PI*(2392.9/180.0);
    b1map_factor = sqrtf(b1map_factor);
    rfshim_b1factor  = _rfshim_b1factor.fixedflag ?  ((void)((1.0/b1map_factor)/(0.036615*2000.0/pw_rfbrs*flip_rfbrs/90.0)*flip_rf1rs), rfshim_b1factor) : (1.0/b1map_factor)/(0.036615*2000.0/pw_rfbrs*flip_rfbrs/90.0)*flip_rf1rs; 

    return SUCCESS;
}   /* end RSpredownload() */

/*
 *  DTGpredownload
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
DTGpredownload( void )
{
    FLOAT dtgscale;
    FLOAT b1map_factor = 0.0;

    INT i, j;

    FLOAT *dynTG_loc = NULL;

    {
        INT dtg_maxseqsar = 0;

        if(FAILURE == maxseqsar(&dtg_maxseqsar, RF_FREE, rfpulse, L_DYNTG))
        {
            epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                       EE_ARGS(1), STRING_ARG, "maxseqsar dynamic tg");
            return FAILURE;
        }
        if(tr_dtg < dtg_maxseqsar)
        {
            tr_dtg  = _tr_dtg.fixedflag ?  ((void)(RUP_GRD(dtg_maxseqsar)), tr_dtg) : RUP_GRD(dtg_maxseqsar);
        }
    }

    /******************************************************************/
    /* Set xmtadd according to maximum B1 and rescale for powermon,   */
    /* adding additional scaling if xmtadd is too big.                */
    /******************************************************************/

    strcpy(entry_point_table[L_DYNTG].epname,  "DynTG");

    xmtadddtg  = _xmtadddtg.fixedflag ?    ((void)(-200*log10(maxB1[L_DYNTG]/maxB1Seq)+getCoilAtten()), xmtadddtg) : -200*log10(maxB1[L_DYNTG]/maxB1Seq)+getCoilAtten();
    if (xmtadddtg > cfdbmax) 
    {
        dtgscale = (float) pow(10.0, (cfdbmax - xmtadddtg)/200.0);
        xmtadddtg  = _xmtadddtg.fixedflag ?  ((void)(cfdbmax), xmtadddtg) : cfdbmax;
    } 
    else
    {
        dtgscale = 1.0;
    }

    if (setScale(L_DYNTG, RF_FREE, rfpulse, maxB1[L_DYNTG],
                 dtgscale) == FAILURE) 
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "setScale DynTG");
        return FAILURE;
    }

    /* Set the amplitude scale factors. */
    ia_rfbdtg  = _ia_rfbdtg.fixedflag ?  ((void)(max_pg_iamp*(*rfpulse[RFB_DYNTG_SLOT].amp)), ia_rfbdtg) : max_pg_iamp*(*rfpulse[RFB_DYNTG_SLOT].amp);
    ia_thetarfbdtg  = _ia_thetarfbdtg.fixedflag ?  ((void)(max_pg_iamp), ia_thetarfbdtg) : max_pg_iamp;
    pw_thetarfbdtg  = _pw_thetarfbdtg.fixedflag ?  ((void)(pw_rfbdtg), pw_thetarfbdtg) : pw_rfbdtg;
    ia_rf1dtg  = _ia_rf1dtg.fixedflag ?  ((void)(max_pg_iamp*(*rfpulse[RF1_DYNTG_SLOT].amp)), ia_rf1dtg) : max_pg_iamp*(*rfpulse[RF1_DYNTG_SLOT].amp);

    entry_point_table[L_DYNTG].epxmtadd=(short)rint((double)xmtadddtg);

    if( powermon( &entry_point_table[L_DYNTG],
                  L_DYNTG,
                  (int)RF_FREE,
                  rfpulse,
                  tr_dtg ) == FAILURE )
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "powermon dynTG B1 map");
        return FAILURE;
    }

#ifdef BURST_MODE_SUPPORT
    {
        /* Call minseq() to calculate Burst Mode model inputs.
           Disable writing corner points files for prescan entry points. */
        int gradHeatFile_save = gradHeatFile;
        gradHeatFile  = _gradHeatFile.fixedflag ?  ((void)(FALSE), gradHeatFile) : FALSE;
        if ( FAILURE == minseq( _min_seqgrad.fixedflag ? (_temp473_min_seqgrad=min_seqgrad,&_temp473_min_seqgrad) : &min_seqgrad,
                                gradx, GX_FREE,
                                grady, GY_FREE,
                                gradz, GZ_FREE,
                                &loggrd, idx_seqdtg, tsamp, tmin,
                                use_ermes, seg_debug ) ) {
            epic_error( use_ermes, "%s failed.",
                        EM_PSD_ROUTINE_FAILURE, EE_ARGS(1), STRING_ARG, "minseq" );
            return FAILURE;
        }
        gradHeatFile  = _gradHeatFile.fixedflag ?  ((void)(gradHeatFile_save), gradHeatFile) : gradHeatFile_save;
    }
#endif

    entry_point_table[L_DYNTG].epfilter = (n8)filter_echo1dtg;
    entry_point_table[L_DYNTG].epprexres = dynTG_xres;

    /* Now copy into Map TG */
    entry_point_table[L_MAPTG] = entry_point_table[L_DYNTG];
    strcpy(entry_point_table[L_MAPTG].epname,  "mapTg");

    dynTG_loc =  (float*)AllocNode(dynTG_slquant*sizeof(float));
    if (NULL == dynTG_loc)
    {
        epic_error( use_ermes, "%s failed.",
                    EM_PSD_ROUTINE_FAILURE, EE_ARGS(1), STRING_ARG, "AllocNode for dynTG_loc" );
        return FAILURE;
    }

    if(PSD_OFF == enableMapTg)
    {
        dynTG_sliceloc(dynTG_loc, dynTG_slquant, exist(opslquant), 1);
    }
    /* set up B1 Map slice orientation and location */
    for (j = 0; j < dynTG_slquant; j++)
    {
        if(PSD_ON == enableMapTg)
        {
            dtgrsp_info[j].rsprloc = 0.0;
            dtgrsp_info[j].rspphasoff = 0.0;
            dtgrsp_info[j].rsptloc = 0.0;

            if (ps1obl_debug)
            {
                printf("index=%d,dtg.rsprloc=%f,dtg.rspphaseoff=%f,dtg.rsptloc=%f\n",
                       j,dtgrsp_info[j].rsprloc,dtgrsp_info[j].rspphasoff,dtgrsp_info[j].rsptloc);
            }

            for (i = 0; i < 9; i++)
            {
                dtgrsprot[j][i] = hostToRspRotMat(maptgscan_info[0].oprot[i]); /* use axial slice rot */
            }
        }
        else
        {
            int index0, index1;
            index0 = (int)dynTG_loc[j];
            if(index0<0)
            {
                index0=0;
            }
            index1 = index0+1;
            if(index1>=exist(opslquant))
            {
                index1=exist(opslquant)-1;
            }
            dtgrsp_info[j].rsprloc = scan_info[index0].oprloc + scan_info[index0].oprloc_shift;
            dtgrsp_info[j].rspphasoff = scan_info[index0].opphasoff + scan_info[index0].opphasoff_shift;
            dtgrsp_info[j].rsptloc = scan_info[index0].optloc + scan_info[index0].optloc_shift +
                (dynTG_loc[j]-(float)index0) *
                (scan_info[index1].optloc + scan_info[index1].optloc_shift - scan_info[index0].optloc - scan_info[index0].optloc_shift);

            if (ps1obl_debug)
            {
                printf("index=%d,dtg.rsprloc=%f,dtg.rspphaseoff=%f,dtg.rsptloc=%f\n",
                       j,dtgrsp_info[j].rsprloc,dtgrsp_info[j].rspphasoff,dtgrsp_info[j].rsptloc);
            }

            for (i = 0; i < 9; i++)
            {
                dtgrsprot[j][i] = hostToRspRotMat(scan_info[index0].oprot[i]); /* use Rxed slice rot */ 
            }
        }
    }

    FreeNode(dynTG_loc);

    scalerotmats(dtgrsprot, &dtgloggrd, &phygrd, dynTG_slquant, ps1obl_debug);

    /* calc b1map factor */
    b1map_factor = 2.0*PI*(2392.9/180.0);
    b1map_factor = sqrtf(b1map_factor);
    dynTG_b1factor  = _dynTG_b1factor.fixedflag ?  ((void)((1.0/b1map_factor)/(0.036615*2000.0/pw_rfbdtg*flip_rfbdtg/90.0)*flip_rf1dtg), dynTG_b1factor) : (1.0/b1map_factor)/(0.036615*2000.0/pw_rfbdtg*flip_rfbdtg/90.0)*flip_rf1dtg; 

    if( (PSD_ON == enableMapTg) && (PSD_ON == xtg_volRecCoil))
    {
        /* Use volRec coil for mapTG */
        if (volRecCoilInfo[0].hubIndex != coilInfo[0].hubIndex)
        {
            UpdateEntryTabRecCoil(&entry_point_table[L_MAPTG], &volRecCoilInfo[0]);
        } 
    }

    return SUCCESS;
}   /* end DTGpredownload() */



/*
 *  ExtCalpredownload
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
ExtCalpredownload( void )
{
    INT i, j;
    FLOAT calscale = 1.0;

    /* SAR check */
    {
        INT cal_maxseqsar = 0;

        if(FAILURE == maxseqsar(&cal_maxseqsar, RF_FREE, rfpulse, L_EXTCAL))
        {
            epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                       EE_ARGS(1), STRING_ARG, "maxseqsar Cal");
            return FAILURE;
        }
        if(tr_cal < cal_maxseqsar)
        {
            tr_cal  = _tr_cal.fixedflag ?  ((void)(RUP_GRD(cal_maxseqsar)), tr_cal) : RUP_GRD(cal_maxseqsar);
        }
    }

    /******************************************************************/
    /*  Set xmtadd according to maximum B1 and rescale for powermon,  */
    /* adding additional scaling if xmtadd is too big.                */
    /******************************************************************/
    strcpy(entry_point_table[L_EXTCAL].epname,  "extcal");

    xmtaddcal  = _xmtaddcal.fixedflag ?    ((void)(-200*log10(maxB1[L_EXTCAL]/maxB1Seq)+getCoilAtten()), xmtaddcal) : -200*log10(maxB1[L_EXTCAL]/maxB1Seq)+getCoilAtten();
    if (xmtaddcal > cfdbmax)
    {
        calscale = (float) pow(10.0, (cfdbmax - xmtaddcal)/200.0);
        xmtaddcal  = _xmtaddcal.fixedflag ?  ((void)(cfdbmax), xmtaddcal) : cfdbmax;
    } 
    else
    {
        calscale = 1.0;
    }

    if (setScale(L_EXTCAL, RF_FREE, rfpulse, maxB1[L_EXTCAL],
                 calscale) == FAILURE)
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "setScale cal");
        return FAILURE;
    }

    /* Set the amplitude scale factors. */
    ia_rf1cal  = _ia_rf1cal.fixedflag ?  ((void)(max_pg_iamp*(*rfpulse[RF1_EXTCAL_SLOT].amp)), ia_rf1cal) : max_pg_iamp*(*rfpulse[RF1_EXTCAL_SLOT].amp);

    entry_point_table[L_EXTCAL].epxmtadd=(short)rint((double)xmtaddcal);

    if( powermon( &entry_point_table[L_EXTCAL],
                  L_EXTCAL,
                  (int)RF_FREE,
                  rfpulse,
                  tr_cal ) == FAILURE )
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "powermon cal");
        return FAILURE;
    }

#ifdef BURST_MODE_SUPPORT
    {
        /* Call minseq() to calculate Burst Mode model inputs.
           Disable writing corner points files for prescan entry points. */

        int gradHeatFile_save = gradHeatFile;
        gradHeatFile  = _gradHeatFile.fixedflag ?  ((void)(FALSE), gradHeatFile) : FALSE;
        if ( FAILURE == minseq( _min_seqgrad.fixedflag ? (_temp474_min_seqgrad=min_seqgrad,&_temp474_min_seqgrad) : &min_seqgrad,
                                gradx, GX_FREE,
                                grady, GY_FREE,
                                gradz, GZ_FREE,
                                &loggrd, idx_seqcal, tsamp, tmin,
                                use_ermes, seg_debug ) ) {
            epic_error( use_ermes, "%s failed.",
                        EM_PSD_ROUTINE_FAILURE, EE_ARGS(1), STRING_ARG, "minseq" );
            return FAILURE;
        }
        gradHeatFile  = _gradHeatFile.fixedflag ?  ((void)(gradHeatFile_save), gradHeatFile) : gradHeatFile_save;
    }
#endif

    entry_point_table[L_EXTCAL].epfilter = (n8)filter_echo1cal;
    entry_point_table[L_EXTCAL].epprexres = cal_xres;


    if(cal_tr_interleave)  /* always set body coil ON for cal scan */
    {
        entry_point_table[L_EXTCAL].epRxCoilType = (n32)volRecCoilInfo[0].rxCoilType;
    }

    for( j = 0; j < cal_slq; j++)
    {
        calrsp_info[j].rsptloc = (calscan_info[cal_slq/2].optloc + calscan_info[cal_slq/2].optloc_shift
                                  + calscan_info[cal_slq/2-1].optloc + calscan_info[cal_slq/2-1].optloc_shift)/2.0;
        calrsp_info[j].rsprloc = calscan_info[0].oprloc + calscan_info[0].oprloc_shift;
        calrsp_info[j].rspphasoff = calscan_info[0].opphasoff + calscan_info[0].opphasoff_shift;

        for (i = 0; i < 9; i++)
        {
            calrsprot[j][i] = hostToRspRotMat(calscan_info[0].oprot[i]); 
        }
    }

    if (((cffield == B0_30000) || ((cffield == B0_15000)))&& (opsilentmr || opsilent))
    {
        scalerotmats(calrsprot, &calloggrd, &phygrd, cal_slq, ps1obl_debug);
    }
    else
    {
        scalerotmats(calrsprot, &calloggrd, &original_pgrd, cal_slq, ps1obl_debug);
    }

    /* corner cutting */
    cal_pfkr_fraction  = _cal_pfkr_fraction.fixedflag ?  ((void)(PI/4.0), cal_pfkr_fraction) : PI/4.0;  /* same as task based 3D Cal */
    cal_pfkr_flag  = _cal_pfkr_flag.fixedflag ?  ((void)(PSD_ON), cal_pfkr_flag) : PSD_ON;

    /* create zy encoding index and sort removed points to the end */
    /* sequential order for z & y */
    if (FAILURE == generateZyIndex( cal_zyindex,
                                    cal_yres,
                                    cal_slq,
                                    cal_yfov,
                                    cal_vthick,
                                    cal_pfkr_flag,
                                    cal_pfkr_fraction,
                                    _cal_sampledPts.fixedflag ? (_temp475_cal_sampledPts=cal_sampledPts,&_temp475_cal_sampledPts) : &cal_sampledPts ))
    {
        epic_error(use_ermes, "%s failed",
                   EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "generateZyIndex");
        return FAILURE;
    }

    return SUCCESS;
}   /* end ExtCalpredownload() */


/*
 *  AutoCoilpredownload
 *  
 *  Type: Public Function
 *  
 *  Description: Predownload settings for AutoCoil entry point
 *  
 */
STATUS
AutoCoilpredownload( void )
{
    INT i, j;
    FLOAT coilscale = 1.0;

    /* SAR check */
    {
        INT coil_maxseqsar = 0;

        if(FAILURE == maxseqsar(&coil_maxseqsar, RF_FREE, rfpulse, L_AUTOCOIL))
        {
            epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                       EE_ARGS(1), STRING_ARG, "maxseqsar AutoCoil");
            return FAILURE;
        }
        if(tr_coil < coil_maxseqsar)
        {
            tr_coil  = _tr_coil.fixedflag ?  ((void)(RUP_GRD(coil_maxseqsar)), tr_coil) : RUP_GRD(coil_maxseqsar);
        }
    }

    /******************************************************************/
    /*  Set xmtadd according to maximum B1 and rescale for powermon,  */
    /* adding additional scaling if xmtadd is too big.                */
    /******************************************************************/
    strcpy(entry_point_table[L_AUTOCOIL].epname,  "Autocoil");

    xmtaddcoil  = _xmtaddcoil.fixedflag ?    ((void)(-200*log10(maxB1[L_AUTOCOIL]/maxB1Seq)+getCoilAtten()), xmtaddcoil) : -200*log10(maxB1[L_AUTOCOIL]/maxB1Seq)+getCoilAtten();
    if (xmtaddcoil > cfdbmax)
    {
        coilscale = (float) pow(10.0, (cfdbmax - xmtaddcoil)/200.0);
        xmtaddcoil  = _xmtaddcoil.fixedflag ?  ((void)(cfdbmax), xmtaddcoil) : cfdbmax;
    } 
    else
    {
        coilscale = 1.0;
    }

    if (setScale(L_AUTOCOIL, RF_FREE, rfpulse, maxB1[L_AUTOCOIL],
                 coilscale) == FAILURE)
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "setScale coil");
        return FAILURE;
    }

    /* Set the amplitude scale factors. */
    ia_rf1coil  = _ia_rf1coil.fixedflag ?  ((void)(max_pg_iamp*(*rfpulse[RF1_AUTOCOIL_SLOT].amp)), ia_rf1coil) : max_pg_iamp*(*rfpulse[RF1_AUTOCOIL_SLOT].amp);

    entry_point_table[L_AUTOCOIL].epxmtadd=(short)rint((double)xmtaddcoil);

    if( powermon( &entry_point_table[L_AUTOCOIL],
                  L_AUTOCOIL,
                  (int)RF_FREE,
                  rfpulse,
                  tr_coil ) == FAILURE )
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "powermon coil");
        return FAILURE;
    }

#ifdef BURST_MODE_SUPPORT
    {
        /* Call minseq() to calculate Burst Mode model inputs.
           Disable writing corner points files for prescan entry points. */

        int gradHeatFile_save = gradHeatFile;
        gradHeatFile  = _gradHeatFile.fixedflag ?  ((void)(FALSE), gradHeatFile) : FALSE;
        if ( FAILURE == minseq( _min_seqgrad.fixedflag ? (_temp476_min_seqgrad=min_seqgrad,&_temp476_min_seqgrad) : &min_seqgrad,
                                gradx, GX_FREE,
                                grady, GY_FREE,
                                gradz, GZ_FREE,
                                &loggrd, idx_seqcoil, tsamp, tmin,
                                use_ermes, seg_debug ) ) {
            epic_error( use_ermes, "%s failed.",
                        EM_PSD_ROUTINE_FAILURE, EE_ARGS(1), STRING_ARG, "minseq" );
            return FAILURE;
        }
        gradHeatFile  = _gradHeatFile.fixedflag ?  ((void)(gradHeatFile_save), gradHeatFile) : gradHeatFile_save;
    }
#endif

    /* setup entry point table for Auto Coil */
    entry_point_table[L_AUTOCOIL].epfilter = (n8)filter_echo1coil;
    entry_point_table[L_AUTOCOIL].epprexres = coil_xres;

    /* Full coil mode for auto coil */
    UpdateEntryTabRecCoil(&entry_point_table[L_AUTOCOIL], &fullRecCoilInfo[0]);

    for( j = 0; j < coil_slq; j++)
    {
        coilrsp_info[j].rsptloc = (coilscan_info[coil_slq/2].optloc + coilscan_info[coil_slq/2].optloc_shift
                                  + coilscan_info[coil_slq/2-1].optloc + coilscan_info[coil_slq/2-1].optloc_shift)/2.0;
        coilrsp_info[j].rsprloc = coilscan_info[0].oprloc + coilscan_info[0].oprloc_shift;
        coilrsp_info[j].rspphasoff = coilscan_info[0].opphasoff + coilscan_info[0].opphasoff_shift;

        for (i = 0; i < 9; i++)
        {
            coilrsprot[j][i] = hostToRspRotMat(coilscan_info[0].oprot[i]); 
        }
    }

    scalerotmats(coilrsprot, &coilloggrd, &phygrd, coil_slq, ps1obl_debug);

    /* corner cutting */
    coil_pfkr_fraction  = _coil_pfkr_fraction.fixedflag ?  ((void)(PI/4.0), coil_pfkr_fraction) : PI/4.0;
    coil_pfkr_flag  = _coil_pfkr_flag.fixedflag ?  ((void)(PSD_ON), coil_pfkr_flag) : PSD_ON;

    /* create zy encoding index and sort removed points to the end */
    /* sequential order for z & y */
    if (FAILURE == generateZyIndex( coil_zyindex,
                                    coil_yres,
                                    coil_slq,
                                    coil_yfov,
                                    coil_vthick,
                                    coil_pfkr_flag,
                                    coil_pfkr_fraction,
                                    _coil_sampledPts.fixedflag ? (_temp477_coil_sampledPts=coil_sampledPts,&_temp477_coil_sampledPts) : &coil_sampledPts ))
    {
        epic_error(use_ermes, "%s failed",
                   EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "generateZyIndex");
        return FAILURE;
    }


    return SUCCESS;
}   /* end AutoCoilpredownload() */


/* CoilSwitchGetTR (MRIhc15304)
 * 
 * Description:
 *   This function returns the TR for the coilSwitch SSP sequence based on
 *   the setRcvPortFlag as passed to CoilSwitchSetCoil.
 *
 *  Parameters:
 *  (I: for input parameters, O: for output parameters)
 *  (O) return: TR in usec
 *  (I) setRcvPortFlag - flag to indicate that setrcvportimm will be
 *        executed when switching coils.  See CoilSwitchSetCoil
 */
int
CoilSwitchGetTR(const int setRcvPortFlag)
{
    int wait_rspimm = 0;
    
    /* When asynchronous RSP function calls are needed, the wait time is
     * extended to accomodate the worst case RSP time */
    if( COIL_SWITCH_RSP_SETHUBINDEXIMM & cfcoilswitchmethod )
    {
        wait_rspimm = csw_wait_sethubindeximm;
    }

    if( setRcvPortFlag )
    {
        wait_rspimm = IMax(2, wait_rspimm, csw_wait_setrcvportimm);
    }

    return csw_tr + wait_rspimm;
}

/* doTG 
 *
 * Description:
 *  This function returns the doTG flag 
 *     PSD_CONTROL_PSC_SKIP -1: PSD force to skip TG
 *     APS_CONTROL_PSC       0: follow default smart prescan rules for TG
 *     PSD_CONTROL_PSC_RUN   1: force to run TG entry point for specific applications
 */
int
doTG(int psd_psc_control)
{
    int TG_control = psd_psc_control;
    if( ( exist(opdiffuse)
          || exist(opasl) 
          || (PSD_2D == exist(opimode) && PSD_SE == exist(oppseq) && PSD_OFF == exist(opfast)) 
          || (PSD_3D == exist(opimode) && PSD_SE == exist(oppseq) && exist(opinhance)) /* delta flow */ 
          || (PSD_SPECTRO == exist(opimode))
          || (PSD_OFF != exist(opflair)) || PSD_3PLANE == exist(opplane))
        && (!isValueSystem())
        && (APS_CONTROL_PSC == TG_control) )
    {
        TG_control = PSD_CONTROL_PSC_RUN;
    }

    if((TG_control != PSD_CONTROL_PSC_SKIP) && (TG_control != PSD_CONTROL_PSC_RUN) && (TG_control != APS_CONTROL_PSC))
    {
        TG_control = APS_CONTROL_PSC;
    }

    return TG_control;
}

/* doAS
 *
 * Description:
 *  This function returns the doAS flag 
 *     PSD_CONTROL_PSC_SKIP    -1: PSD force to skip autoshim 
 *     APS_CONTROL_PSC          0: follows default smart prescan rules for AS 
 *     PSD_CONTROL_PSC_RUN      1: forces to run Autoshim entry point for specific applications
 *     PSD_CONTROL_PSC_SPECIAL  2: forces to run global Autoshim for specific applications (breast DWI) 
 */
int
doAS(int psd_psc_control)
{
    int AS_control = psd_psc_control;
    if( ( PSD_ON == pimrsapsflg
          || PSD_ON == exist(opepi)
          || PSD_ON == exist(opspiral)
          || PSD_SSFP == oppseq
          || PSD_ON == exist(opvrg)
          || exist(opfat) || exist(opfatcl)
          || exist(opspecir) || exist(opwater))
        && (APS_CONTROL_PSC == AS_control)
        && (GRADSHIM_OFF != exist(opgradshim)) )
    {
        AS_control = PSD_CONTROL_PSC_RUN;
    }  /* Auto Shim is required for MRS, EPI, Spiral, VERSE and fiesta and Chem Sat */

    if((AS_control != PSD_CONTROL_PSC_SKIP) && (AS_control != PSD_CONTROL_PSC_RUN) 
       && (AS_control != APS_CONTROL_PSC) && (AS_control != PSD_CONTROL_PSC_SPECIAL))
    {
        AS_control = APS_CONTROL_PSC;
    }

    return AS_control;
}

/* generate zy encoding index for 3D acquisition for sequential order */
STATUS
generateZyIndex(ZY_INDEX * zy_index,
                const int zy_views,
                const int zy_slices,
                const float yFov,
                const float zFov,
                const int psc_pfkr_flag,
                const float psc_pfkr_fraction,
                int *zy_sampledPoints)
{
    n8 *xzPlanes = NULL;
    int i, j;
    int maxView = 0;
    float dist_ky, dist_kz;
    int superindex = 0;
    int sampledPts = 0;

    int zy_encodes = zy_views * zy_slices;
    float maskDist = 0;  /* Fake distance for sorting  masked encodess */

    float delta_ky = 1.0/yFov;  /* inverse mm */
    float delta_kz = 1.0/zFov;  /* inverse mm also */
    float origin_y = (float)(zy_views-1)/2.0 - 0.01;
    float origin_z = (float)(zy_slices-1)/2.0 - 0.01;
    float kr_fraction = 0.0;
    float max_dist_ky = 0.0;
    float max_dist_kz = 0.0;
    float sq_max_dist_ky = 0.0;
    float sq_max_dist_kz = 0.0;
    float sq_normdist_ky = 0.0;


    /*  Use dynamic memory allocation for zy_sort & zy_export */
    ZY_DIST1 *cal_zy_sort = NULL;
    if ((cal_zy_sort = (ZY_DIST1 *) malloc(sizeof(ZY_DIST1) * zy_encodes)) == NULL) {
        printf("%s: Failure allocating cal_zy_sort.\n", "generateZyIndex");
        return FAILURE;
    }
    memset(cal_zy_sort, 0, sizeof(ZY_DIST1) * zy_encodes);


    kr_fraction = sqrt(psc_pfkr_fraction*4.0/PI);
    max_dist_ky = 0.505*kr_fraction*delta_ky*(float)(zy_views-1);
    max_dist_kz = 0.505*kr_fraction*delta_kz*(float)(zy_slices-1);
    sq_max_dist_ky = max_dist_ky * max_dist_ky;
    sq_max_dist_kz = max_dist_kz * max_dist_kz;
    maskDist = 100.0*sqrt(sq_max_dist_ky + sq_max_dist_kz);

    if (maskDist < 10.0 * (float)(zy_encodes))
    {
        maskDist = 10.0 * (float)(zy_encodes);
    }

    superindex = 0;
    sampledPts = 0;

    for (i=0; i<zy_views; i++)
    {
        /*views start at 0*/
        dist_ky = delta_ky*(i - origin_y);
        sq_normdist_ky = pow(dist_ky, 2)/ sq_max_dist_ky;

        for (j=0; j<zy_slices; j++)
        {

            cal_zy_sort[superindex].view = i; /* sequential ordering: views start at 0*/
            cal_zy_sort[superindex].slice = j;  /*slices start at 0*/
            cal_zy_sort[superindex].flags  = 0; /* Initialized all flags to off */
            cal_zy_sort[superindex].distance =  (float) superindex;


            if (psc_pfkr_flag)
            {
                dist_kz = delta_kz*((float)(cal_zy_sort[superindex].slice) - origin_z);

                if ((sq_normdist_ky + (dist_kz*dist_kz)/ sq_max_dist_kz) > 1.0)
                {
                    cal_zy_sort[superindex].flags |= ZY_REMOVED;
                    cal_zy_sort[superindex].distance = maskDist;
                }
                else
                {
                    sampledPts +=1;
                }
            }
            else
            {
                sampledPts +=1;
            }

            superindex +=1;
        }
    }
    /* Sort to push the skipped and mask points to the end */
    qsort(cal_zy_sort, zy_encodes, sizeof(ZY_DIST1), psc_dist_compare);

    for (i=0; i < zy_encodes; i++)
    {
        zy_index[i].view = cal_zy_sort[i].view;
        zy_index[i].slice = cal_zy_sort[i].slice;
        zy_index[i].flags = cal_zy_sort[i].flags;
    }

    free(cal_zy_sort);

    maxView = 0;

    /* set flag for xz plane done */
    for (i=0; i < sampledPts; i++)
    {
        if (zy_index[i].view > maxView)
        {
            maxView = zy_index[i].view;
        }
    }
    /* Increment maxView such that it is the # of views to allocate */
    maxView++;

    /* Allocate buffer to keep track of XZ-planes completed */
    xzPlanes = (n8 *) malloc(sizeof(n8) * maxView);

    /* Initialize all XZ-planes */
    memset(xzPlanes, 1, sizeof(n8) * maxView);

    for (i = sampledPts - 1; i >= 0; i--)
    {
        if (xzPlanes[zy_index[i].view])
        {
            zy_index[i].flags |= ZY_XZ_PLANE_DONE;
            xzPlanes[zy_index[i].view] = 0;
        }
        else
        {
            zy_index[i].flags &= ~ZY_XZ_PLANE_DONE;
        }
    }

    free(xzPlanes);
    
    if(PSdebugstate)
    {
        const CHAR * export_filename = "pscCal.info";
        FILE * fid;
        fid = fopen(export_filename, "w");

        for (i = 0; i < zy_encodes; i++)
        {
            fprintf(fid, "PSC cal Info: superindex= %d view= %d slice=%d flags= %d \n",
                    i, zy_index[i].view, zy_index[i].slice, zy_index[i].flags);
        }

        fclose(fid);

    }

    *zy_sampledPoints = sampledPts;   /* fully sampled zy */


    return SUCCESS;
}

int psc_dist_compare(const void *dist1, const void *dist2)
{
        return (((ZY_DIST1 *)dist2)->distance < ((ZY_DIST1 *)dist1)->distance )? 1: -1;
}




#ifndef sys_psdiopt_h
#define sys_psdiopt_h
#include "psdIF.h"
#include "psdiopt.h"
#endif
#ifndef _SYSCHECK_
#define _SYSCHECK_
STATUS syscheck(INT *p_syscheck_limit, int *p_status_flag)
{
    /* Variables to hold the minseq  values. These are local to syscheck*/
    INT syscheck_min_seqgrad = 0;
    INT syscheck_min_seqrfamp = 0; 

    /* Flag to turn on or off syscheck logging */
    int syschecklog_on = 0;

    /* The file pointer to enable or disable RF check with the help of a file*/
    FILE *fp_rfon;
    FILE *fp_syschecklog_on;

    int iopt_num=0;/* Imaging option Num*/

    char im_opt_name[128];/* Imaging option String*/
    char logValues[1024];

    INT seq_entry_index = 0;

    char path[128] = "/usr/g/service/log/";
    char filename[64] = "psd_syscheck_error.log";
    char macro_name[32];
    float tolerance_percentage = 0.0;
    const int TOLERANCE_LIMIT = 5;
    int syscheck_limit = 0;
    float syscheck_limit_tolerance = 0.0;
    int debug_syscheck;
    debug_syscheck = (getenv("DEBUG_SYSCHECK")!='\0');

    INT syscheck_minseqgrddrvx_t = 0;
     INT syscheck_minseqgrddrvy_t = 0;
     INT syscheck_minseqgrddrvz_t = 0;

     INT syscheck_minseqgrddrv_t = 0;
     INT syscheck_minseqcoil_t = 0;
     INT syscheck_minseqcable_t = 0;
     INT syscheck_minseqbusbar_t = 0;
     if(debug_syscheck){
         printf(" Calling minseq for NPGOH from macro\n");
         fflush(stdout);
     }
    strcpy(macro_name,"SYSCHECK_MINSEQ_NPGOH");
  /* check the gradient driver heating */
    (void)seq_entry_index;
  if (minseqgrddrv(&syscheck_minseqgrddrvx_t, _powerx.fixedflag ? (_temp478_powerx=powerx,&_temp478_powerx) : &powerx, _pospowerx.fixedflag ? (_temp479_pospowerx=pospowerx,&_temp479_pospowerx) : &pospowerx, _negpowerx.fixedflag ? (_temp480_negpowerx=negpowerx,&_temp480_negpowerx) : &negpowerx,
                   (int)GX_FREE, gradx,
                   (INT)((sigrammode & XGRAM)/XGRAM),
                   loggrd.xirmspos, loggrd.xirmsneg,
                   loggrd.xirms, loggrd.xipeak, loggrd.xfs)
      == FAILURE)
     {
                log_error(path,filename,1,"%s \nfile:%s line:%d Error No:%d","Minseqgrdrv_x failed in syscheck",__FILE__,__LINE__,EM_PSD_SUPPORT_FAILURE);
                if(debug_syscheck){
                    printf(" Minseqgrddrv_x failed in syscheck \n");
                    fflush(stdout);
                }
                *p_status_flag = 1;
     }
if (minseqgrddrv(&syscheck_minseqgrddrvy_t, _powery.fixedflag ? (_temp481_powery=powery,&_temp481_powery) : &powery, _pospowery.fixedflag ? (_temp482_pospowery=pospowery,&_temp482_pospowery) : &pospowery, _negpowery.fixedflag ? (_temp483_negpowery=negpowery,&_temp483_negpowery) : &negpowery,
                   (int)GY_FREE, grady,
                   (INT)((sigrammode & YGRAM)/YGRAM),
                   loggrd.yirmspos, loggrd.yirmsneg,
                   loggrd.yirms, loggrd.yipeak, loggrd.yfs)
      == FAILURE)
    {
                log_error(path,filename,1,"%s \nfile:%s line:%d Error No:%d","Minseqgrddrv_y failed in syscheck",__FILE__,__LINE__,EM_PSD_SUPPORT_FAILURE);
                if(debug_syscheck){
                printf(" Minseqgrddrv_y failed in syscheck \n");
                fflush(stdout);
                }
                *p_status_flag = 1;
    }
if (minseqgrddrv(&syscheck_minseqgrddrvz_t, _powerz.fixedflag ? (_temp484_powerz=powerz,&_temp484_powerz) : &powerz, _pospowerz.fixedflag ? (_temp485_pospowerz=pospowerz,&_temp485_pospowerz) : &pospowerz, _negpowerz.fixedflag ? (_temp486_negpowerz=negpowerz,&_temp486_negpowerz) : &negpowerz,
                   (int)GZ_FREE, gradz,
                   (INT)((sigrammode & ZGRAM)/ZGRAM),
                   loggrd.zirmspos, loggrd.zirmsneg,
                   loggrd.zirms, loggrd.zipeak, loggrd.zfs)
      == FAILURE)
    {
        log_error(path,filename,1,"%s \nfile:%s line:%d Error No:%d","Minseqgrddrv_z failed in syscheck",__FILE__,__LINE__,EM_PSD_SUPPORT_FAILURE);
        if(debug_syscheck){
            printf(" Minseqgrddrv_z failed in syscheck \n");
            fflush(stdout);
        }
        *p_status_flag = 1;
    }
    syscheck_minseqgrddrv_t = IMax(3, syscheck_minseqgrddrvx_t, syscheck_minseqgrddrvy_t, syscheck_minseqgrddrvz_t);
    /* check gradient coil heating */
    if (minseqcoil(&syscheck_minseqcoil_t, _xa2s.fixedflag ? (_temp487_xa2s=xa2s,&_temp487_xa2s) : &xa2s, _ya2s.fixedflag ? (_temp488_ya2s=ya2s,&_temp488_ya2s) : &ya2s, _za2s.fixedflag ? (_temp489_za2s=za2s,&_temp489_za2s) : &za2s, cfsrmode,
                 gradx, grady, gradz,
                 (int)GX_FREE, (int)GY_FREE, (int)GZ_FREE, cfgcontirms)
      == FAILURE)
    {
               log_error(path,filename,1,"%s \nfile:%s line: %d Error No:%d","Minseqcoil failed in syscheck",__FILE__,__LINE__,EM_PSD_SUPPORT_FAILURE);
    }
    if (cfgradamp == 8920)
    {
        if (minseqcable(&syscheck_minseqcable_t, _xa2s.fixedflag ? (_temp490_xa2s=xa2s,&_temp490_xa2s) : &xa2s, _ya2s.fixedflag ? (_temp491_ya2s=ya2s,&_temp491_ya2s) : &ya2s, _za2s.fixedflag ? (_temp492_za2s=za2s,&_temp492_za2s) : &za2s, cfsrmode,
                        gradx, grady, gradz, (int)GX_FREE, (int)GY_FREE,
                        (int)GZ_FREE, cfgcontirms, tmin) == FAILURE)
        {
            log_error(path,filename,1,"%s \nfile:%s line: %d Error No:%d","Minseqcable failed in syscheck",__FILE__,__LINE__,EM_PSD_SUPPORT_FAILURE);
        }
         if (minseqbusbar(&syscheck_minseqbusbar_t, syscheck_minseqcable_t, tmin) == FAILURE)
        {
            log_error(path,filename,1,"%s \nfile:%s line: %d Error No:%d","Minseqbusbar failed in syscheck",__FILE__,__LINE__,EM_PSD_SUPPORT_FAILURE);
        }
    }
    /****** To include Rf calculation based on the choice made ****/

    fp_rfon = fopen("/usr/g/bin/.RFCHECKON","r");
    if(fp_rfon !=NULL)
    {
        if(debug_syscheck){
            printf("Calling minseqrfamp from macro\n");
            fflush(stdout);
        }
        if(minseqrfamp(&syscheck_min_seqrfamp,(int)RF_FREE,rfpulse,L_SCAN) == FAILURE)
        {
	     log_error(path,filename,1," %s \nfile:%s line:%d Error No:%d","Minseqrfamp failed in syscheck",__FILE__,__LINE__,EM_PSD_SUPPORT_FAILURE);
	     if(debug_syscheck){
                 printf(" Minseqrfamp failed in syscheck\n");
                 fflush(stdout);
              }
             *p_status_flag = 1;
         }
         else
         {
            if(debug_syscheck){
                printf("Completed minseqrfamp successfully with min_seqrfamp %d\n",syscheck_min_seqrfamp);
                fflush(stdout);
            }
        }
    }
    syscheck_min_seqgrad = IMax(4,syscheck_minseqcoil_t,syscheck_minseqgrddrv_t,syscheck_minseqcable_t,syscheck_minseqbusbar_t);

    /** to check for the environment variable whether logging has to be done or not ***/

    fp_syschecklog_on = fopen("/usr/g/bin/.SYSCHECKLOGON","r");
    syschecklog_on =((getenv("SYSCHECKLOGON")!='\0') || (fp_syschecklog_on!=NULL));
    /*** if RF check is on include the min_seqrfamp for syscheck_safety_limit and for comparison with optr ***/

        if(fp_rfon !=NULL)
        {
            if(debug_syscheck){
                printf("\nRF included");
                fflush(stdout);
            }
            syscheck_limit = IMax(2,syscheck_min_seqgrad,syscheck_min_seqrfamp);
        }
        else
        {
           if(debug_syscheck){
               printf("\nRf calculation not included");
               fflush(stdout);
           }
           syscheck_limit = syscheck_min_seqgrad;
        }
        if (9000 == cfgradamp) 
           syscheck_limit = syscheck_min_seqrfamp; 
        /*** Calculate the tolerance percentage to allow a maximum of 5% tolerance before comparision***/
        tolerance_percentage = 1-(TOLERANCE_LIMIT * 0.01);
        if(psd_tol_value!=0){
            if((((oppseq == PSD_GE) || (oppseq == PSD_SPGR) || (oppseq == PSD_TOF) || (oppseq == PSD_TOFSP) || (oppseq == PSD_SSFP)) &&
                (opfast == PSD_ON) && (opimode == PSD_3D) && ((opirprep == PSD_ON) || ((opgirmode == PSD_GIRMANUAL) && (opnumgir > 0)))) ||
               (((oppseq == PSD_GE) || (oppseq == PSD_SPGR)) && (opimode == PSD_2D) && (oprealtime == PSD_ON) && (opfast == PSD_ON))){
                if(debug_syscheck){
                    printf("Special case for syscheck considered");
                    printf(" VALUE OF PSD_TOL_VALUE = %d",psd_tol_value);
                    fflush(stdout);
                }
            }
            else{
                if(debug_syscheck){
                    printf("Not allowing a tolerance.Not a  special cases");
                }
                cvoverride(psd_tol_value,0,PSD_FIX_ON,PSD_EXIST_ON);
           }
        }
        syscheck_limit_tolerance = (syscheck_limit * tolerance_percentage) - psd_tol_value;
        *p_syscheck_limit = (int)(syscheck_limit_tolerance);
        /*** Compare the optr with the minseq values if found less than max of minseq values,log an error ***/
        /*** MRIhc37381: Bypass the optr check for Phase Contrast to avoid the download failure ***/
        /*** MRIhc42193: remove the code added by MRIhc37381, enable syscheck for Phase Contrast ***/
        if( (exist(optr)) < (*p_syscheck_limit) || (optr) < (*p_syscheck_limit ) )
        {
            log_error(path,filename,1,"%s \nfile:%s line:%d","ERROR : PSD SAFETY CHECK ERROR!!! ILLEGAL OPTR DETECTED IN SYSCHECK!!!",__FILE__,__LINE__);
            *p_status_flag = 2;
            if(debug_syscheck){
                printf("Illegal optr  value found %d\n",exist(optr));
                fflush(stdout);
            }
        }
        else
        {
            /**** Log a positive message for no error case *****/
            log_error(path,filename,1,"%s", "SAFETY CHECK RAN SUCCESSFULLY!OPTR VALUES FOUND SAFE!");
            *p_status_flag = 0;
        }
        if(((*p_status_flag ==0) && (syschecklog_on)) || (*p_status_flag ==2))
        {
            sprintf(logValues,"\noptr : %d\ntmin : %d\t\ttmin_total : %d\nmin_seqgrad : %d\tsyscheck_min_seqgrad : %d\nsyscheck_safety_limit : %d",exist(optr),tmin,tmin_total,min_seqgrad,syscheck_min_seqgrad,*p_syscheck_limit);
            log_error(path,filename,0,"%s %s","Values found:",logValues);
            if(fp_rfon!=NULL)
            {
                sprintf(logValues,"min_seqrfamp : %d\t syscheck_min_seqrfamp : %d\n",min_seqrfamp,syscheck_min_seqrfamp);
                log_error(path,filename,0,"%s",logValues);
            }
        }
            /************** Log the PSD name & IOPT selected *****/
            log_error(path,filename,0,"%s %s ","PSD:",get_psd_name());
            for(iopt_num = 0;iopt_num < PSD_NUM_IOPTS; iopt_num++){
                if(is_iopt_selected(iopt_num)){
                return_iopt_name(iopt_num,im_opt_name);
                log_error(path,filename,0,"%s %s","Imaging Option :",im_opt_name);
            }
        }

    log_error(path,filename,0,"%s",macro_name);
    if((*p_status_flag) != 0)
    {
        return FAILURE;
    }
    else
    {
        return SUCCESS;
    }
}
#endif
/***************************************************************/


/* Include special CV download code */
#include "grass.cvcopy.cpp"

